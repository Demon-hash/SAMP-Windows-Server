#include <a_samp>
#include <float>
#include <a_http>
#include <PME>
#include <foreach>

#define debug_mode 0
#define SERVER_UPDATE "02.02.2021"
#define SERVER_UPDATE_LOG "```\n-- Gang Wars\n```"

#if debug_mode == 0
	#include <discord-connector>
#endif

#include <sscanf2>
#include <dc_cmd>
#include <a_mysql>
#include <streamer>

#include <date>
#include <a_json>
#include <jit>
#include <a_actor>
#include <strlib>
#include <pawn_raknet>
#include <gravity>

/******************************************************************************/

#define SERVER_BUILD "16"
//#define SERVER_DEFINING_ROLE "707277359958458427"
#define SERVER_DEFINING_ROLE "622530465869594665"
#define SERVER_DEFINING_BUILD "16"

#define AC_MAX_REPORTS 3

#if !defined IsValidVehicle
native IsValidVehicle(vehicleid);
#endif

#define GOLD_VIP_PRICE 10
#define SILVER_VIP_PRICE 7
#define BRONZE_VIP_PRICE 4

/*

#define SERVER_BUILD "20"
#define SERVER_DEFINING_ROLE "707265103619162152" //BUILD 20
#define SERVER_DEFINING_BUILD "20"

*/

/******************************************************************************/

native SendClientCheck(playerid, actionid, memaddr, memOffset, bytesCount);

#pragma dynamic 15000

// SET YOUR DB VALUES HERE
#if debug_mode == 0
#define SQL_HOST ""
#define SQL_USER ""
#define SQL_PASS ""
#define SQL_DB ""
//////////////////////////
#else
#define SQL_HOST "127.0.0.1"
#define SQL_USER "root"
#define SQL_PASS ""
#define SQL_DB "zasamp"
#endif

#define MAX_SELLING_INFO 9

#define min(%0,%1) (%1 > %0) ? %0 : %1
#define max(%0,%1) (%1 > %0) ? %1 : %0

#define KEY_AIM 128
#define MIN_RECONNECT_TIME 5000

#undef MAX_PLAYERS
#define MAX_PLAYERS 50

#undef MAX_VEHICLES
#define MAX_VEHICLES 180

#define GetUnlockedSlot(%0,%1) (%0) >> (1 * (%1)) & 1
#define SetUnlockedSlot(%0,%1,%2) (%0) = ((%0) & (~0 ^ (1 << (1 * (%1))))) | ((%2) << (1 * (%1)))

#define GetBitSlot(%0,%1) (%0) >> (1 * (%1)) & 1
#define SetBitSlot(%0,%1,%2) (%0) = ((%0) & (~0 ^ (1 << (1 * (%1))))) | ((%2) << (1 * (%1)))

#define fun%0(%1) forward%0(%1);public%0(%1)

#define MAX_MAP_TIME 300
#define MAX_RESTART_TIME 5000
#define MAX_MAPUPDATE_TIME 5000
#define MAX_SHOW_CP_TIME 1000
#define MAX_END_TIME 60000
#define MAX_BALANCERUPDATE_TIME 10000
#if !defined isnull
    #define isnull(%1) \
                ((!(%1[0])) || (((%1[0]) == '\1') && (!(%1[1]))))
#endif

#define KEY(%0) (((newkeys & (%0)) == (%0)) && ((oldkeys & (%0)) != (%0)))

#define NAME "...|| ZOMBIE APOCALYPSE ||..."
#define SITE "sampzdm.net"
#define FORUM "SAMPZDM.NET"
#define DISCORD "discord.gg/mPNKjC5"

/// SetPlayerColor()
#define COLOR_HUMAN 0x00CCCCFF
#define COLOR_ZOMBIE 0x99CC00FF
#define COLOR_INFECTED 0xE68687FF
#define COLOR_EVACUATED 0xF2EF5BFF
///In-Chat colors
#define COLOR_GREY "{C0BFBF}"
#define COLOR_LIGHTBLUE "{33CCFF}"
#define COLOR_ABILITY "{009900}"
#define COLOR_ADMIN_CHAT "{6A8EE2}"
#define COLOR_MEDIC_CURE "{B2F558}"
#define COLOR_ACHS_UN "{66ccff}"
#define COLOR_ACHS_LO "{d5d5c3}"

///Formats
#define SendClientMessageFormat(%0,%1,%2,%3) do{new str[196];format(str,sizeof(str),%2,%3);SendClientMessage(%0,%1,str);}while(NeededforDefine)
#define SendMessageFormatToAll(%0,%1,%2) do{new str[196];format(str,sizeof(str),%1,%2);SendClientMessageToAll(%0,str);}while(NeededforDefine)
#define GetPlayerCountry(%0) Player[%0][p_Country]
#define GetPlayerISP(%0) Player[%0][p_ISP]
///GetPlayerTeamEx()
#define TEAM_HUMAN 0
#define TEAM_ZOMBIE 1

new castle_object[4];

new civilRandomSkins[] ={
	12, 14, 15, 18,
 	23, 33, 37, 40,
  	43, 44, 45, 51,
   	52, 56, 58, 76,
    90, 91, 93, 141,
    150, 188, 216, 226, 233
};

enum
{
	CIVILIAN = 0,	SAMURAI,			BOXER,	  			POLICEMAN,
	GANGSTER,		ADVANCEDCIVILIAN,	MEDIC,				SCOUT,
	HEAVYSUPPORT,	HEAVYMEDIC,			HERO,				ENGINEER,
	WARMPERSON,		ZOMBIEFAN,			MI7,
	SCAVENGER,		FIREMANIAC,			ADVANCEDENGINEER,	SWAT,
	TOUGHIE,		ADVANCEDMEDIC,		SAPPER,				ROLLERSKATER,
	RUNNER,			TERRORIST,			ADVANCEDSCOUT,		ROGUEHUMAN,
	TOURIST,		COPIER,				ADVANCEDZOMBIEFAN,	ADVANCEDSAMURAI,
	ADVANCEDBOXER,	SENIORMEDIC,		ROCKETMAN,			ADVANCEDPOLICEMAN,
	SHARPSHOOTER,	SPIDERMAN,			NURSE,				POISONER,
	IRONMAN,		ADVANCEDENGINEER_2,	HUMANQUEEN,			ADVANCEDHERO,
	END_OF_HUMAN_CLASSES, // MAX HUMAN CLASSES ON THE SERVER
};

enum
{
    STANDARDZOMBIE = 0,		MUTATEDZOMBIE,			BLINDZOMBIE,			REAPERZOMBIE,
	FLESHERZOMBIE,			TORNADOZOMBIE,			FASTZOMBIE,				BOOMERZOMBIE,
	DEMONZOMBIE, 			PIRATEZOMBIE,			CAMOUFLAGEZOMBIE,		KAMIKAZEZOMBIE,
	REGENERATOR, 			STOMPERZOMBIE,			ROGUEZOMBIE,			REMOVER,
	MEGAJUMPERZOMBIE, 		CUREBLOCKER,			RADIOACTIVEZOMBIE,		FREEZERZOMBIE,
	SEEKERZOMBIE,			ADVANCEDMUTATED,		UNDEADBOXER,			EARTHSHAKERZOMBIE,
	SPITTERZOMBIE,			PUNKZOMBIE,				SLOWZOMBIE,
	LEGBREAKER,				RISENDEAD,				ENFORCER,
	SPOREZOMBIE,			SPACEBREAKERZOMBIE,		GUNJAMMERZOMBIE,
	END_OF_ZOMBIE_CLASSES, // MAX ZOMBIE CLASSES ON THE SERVER
};

//////////////////////////////////////////////////////////////////////////////////////////////

enum { VIPHUMAN = 5000,			ASSASSIN, 				  };
enum { SCREAMERZOMBIE = 5000,	TANKZOMBIE, SLENDERZOMBIE };

enum
{
    DIALOG_REGISTER_STEP_0,
    DIALOG_REGISTER_STEP_1,
    DIALOG_REGISTER_STEP_2,
    DIALOG_REGISTER_STEP_3,
    DIALOG_LOGIN,

    DIALOG_RESTORE_ACCESS_0,
    DIALOG_RESTORE_ACCESS_1,
    
    DIALOG_ZOMBIE_CLASSES,
    DIALOG_HUMAN_CLASSES,
    DIALOG_CLASSES,
    
    DIALOG_SECURITY,
	DIALOG_CRAFT,
	DIALOG_CRAFT_ACCEPT,
	DIALOG_CRAFT_DO1,
	DIALOG_CRAFT_DO2,
	DIALOG_CRAFT_DO3,
	DIALOG_CRAFT_DO4,
	DIALOG_CRAFT_BERSERKER,
	DIALOG_GAME_HELP,
	DIALOG_GAME_HELP_GANGS,
	DIALOG_GAME_HELP_GPROCESS,
	DIALOG_UPGRADE_SKILLS,
	DIALOG_UPGRADE_SKILL,
    
    DIALOG_SHOP_ITEMS,
	DIALOG_INV_SELECT,
	DIALOG_INV_DROP,
	DIALOG_OPEN_ITEM,
	DIALOG_TROPHYS,
	DIALOG_TROPHYS_DO,
	DIALOG_TROPHYS_UPGRADE,
	DIALOG_TROPHYS_DROP,
    
    DIALOG_LANGUAGE,
	DIALOG_INFO,
	DIALOG_SHOP,
	DIALOG_SETTINGS,
	DIALOG_GANG_SETTINGS,
	DIALOG_GANG_TYPE,
	DIALOG_GANG_TROPHY,
	DIALOG_WARNED,
	DIALOG_INFO_ACH,

	DIALOG_CHAOS,
	DIALOG_CHAOS_BUY,
	DIALOG_CHAOS_BUY_OFCOURSE,

	DIALOG_GANG_FOREMAN,
	DIALOG_GANG_MEMBERS_LIST,
	DIALOG_GANG_MEMBERS_ACTION,
	DIALOG_GANG_MEMBERS_ACCEPTING,

	DIALOG_VALIENTINE_DAY,
	DIALOG_VALIENTINE_SHOP,
	DIALOG_VALIENTINE_QUEST,
	DIALOG_VALIENTINE_QUEST_2,

	DIALOG_COLLECTIONS,
	DIALOG_INFO_DIAL,
	DIALOG_AUCTION_START,
	DIALOG_AUCTION_SELL,
	DIALOG_AUCTION_BUY,

	DIALOG_AUCTION_SELL_COUNT,
	DIALOG_AUCTION_SELL_PRICE,
	DIALOG_AUCTION_CONFRIM,
	DIALOG_AUCTION_BUY_COMFIRM,
	DIALOG_AUCTION_BUY_COUNT,
	DIALOG_AUCTION_EDIT,
	DIALOG_AUCTION_DELETE,

	DIALOG_WEAPON_BUFFS,
	DIALOG_WEAPON_RESET_BUFFS,

	DIALOG_DONATE_ACTIONS,
	DIALOG_VIP_SHOP,

	DIALOG_COLLECTIONS_EXCHANGE,

	DIALOG_ATTACH_INDEX,
	DIALOG_ATTACH_INDEX_SELECTION,
	DIALOG_ATTACH_EDITREPLACE,
	DIALOG_ATTACH_MODEL_SELECTION,
	DIALOG_ATTACH_BONE_SELECTION,

	DIALOG_INV,
	DIALOG_PET_NAME,
	DIALOG_PETS,
	DIALOG_USE_VIP_STONE,
	DIALOG_PETS_ACTIONS,
	DIALOG_PETS_ACTIONS_SELL,
    
    DIALOG_REGISTER_LANGUAGE,
    DIALOG_BUY_CLASS,
    DIALOG_ZOMBIE_SHOP,
    DIALOG_SPECIALITES,
    DIALOG_SPECIALITES_CONFIRM,
    
    DIALOG_JOIN_GANG,
    DIALOG_CREATE_MAIL,
    
    DIALOG_TROPHY_SELL,
    DIALOG_TROPHY_SHOW,
    DIALOG_SHOW_OFFLINE_MEMBERS,
    DIALOG_CARDS,
    DIALOG_UNLOCK_CARD_EFFECT,
    DIALOG_SPECIALITES_LEVEL_UP,
    DIALOG_BUY_FROM_MERCHANT,
    DIALOG_UPGRADE_WEAPONS,
    DIALOG_UPGRADE_WEAPONS_SELECT,
    DIALOG_UPGRADE_WEAPONS_CONFIRM,
    DIALOG_SELL_WEAPON,
    DIALOG_SELL_WEAPON_CONFIRM,
    
    DIALOG_UPGRADE_CHAR,
    DIALOG_UPGRADE_CHAR_SELECT,
    DIALOG_UPGRADE_CHAR_CONFIRM,
    DIALOG_SELL_CHAR,
    DIALOG_SELL_CHAR_CONFIRM,
    
    DIALOG_VIP_MENU,
    DIALOG_ACCEPT_MATCH,
    DIALOG_MATCH_CLASS,
};

#define WEAPON_UNARMED 0
#define WEAPON_VEHICLE_M4 19
#define WEAPON_VEHICLE_MINIGUN 20
#define WEAPON_PISTOLWHIP 48
#define WEAPON_HELIBLADES 50
#define WEAPON_EXPLOSION 51
#define WEAPON_CARPARK 52
#define WEAPON_UNKNOWN 55

#define  COLT_DELAY_HIT     200
#define  SILENCE_HIT_DELAY  400
#define  DEAGLE_HIT_DELAY   400 // 400
#define  SHOTGUN_HIT_DELAY  0
#define  RIFLE_HIT_DELAY    0
#define  SNIPER_HIT_DELAY   0

#define GANG_WARS_DAY 5
#define GANG_CUPS_DAY 1
#define GANG_MAX_ALLIANCES 2
#define GANG_MAX_WARS 30
#define GANG_TAXPERCENT 45
#define GANG_ENABLE_MAPBUFF 1
#define GANG_MIN_RANK 10

new GlobalGsPolicy[2] = {1, 1};
new UserPrivateChannelUserIDs[MAX_PLAYERS][MAX_PLAYERS][DCC_ID_SIZE];
new UserPrivateChannelUserNames[MAX_PLAYERS][MAX_PLAYERS][DCC_ID_SIZE];
new UserPrivateChannelID[MAX_PLAYERS][MAX_PLAYERS][DCC_ID_SIZE];
new UserCreatedChannels[MAX_PLAYERS] = {0, ...};
new bool:InGangHouse[MAX_PLAYERS] = {false, ...};

new Merchants[5], Text3D: SpawnMerchants[5];

new bool:UseNewBalance = false;
new EventFilterScript[128] = "\0";
new FirstPerson[MAX_PLAYERS];
new TimesJumped[MAX_PLAYERS]= {0, ...};
new TormentTime[MAX_PLAYERS] = {0, ...};
new ARDestructionTime[MAX_PLAYERS] = {0, ...};
new VipTeamSelected[MAX_PLAYERS];
new HoursForAch[MAX_PLAYERS][2] = {{-1, -1},...};
static PR_VirtualWorldForPlayer[MAX_PLAYERS] = {0, ...};
new bool:GravityMode[MAX_PLAYERS] = {false, ...};
new bool:GravityReset[MAX_PLAYERS] = {false, ...};

/*******************************************************************************/

new GangsSettings[] = {GANG_WARS_DAY, GANG_CUPS_DAY, GANG_MAX_ALLIANCES, GANG_MAX_WARS, GANG_TAXPERCENT, GANG_ENABLE_MAPBUFF, GANG_MIN_RANK};
new GangTimer[] = {0, 0};
new JumpTimes[MAX_PLAYERS] = {0, 0};
new KSList[3] = {-1, -1, -1}, KSListKS[3] = {0, 0, 0}, alreadyNotificated[MAX_PLAYERS] = {-1, ...};

new CanJumpTwice[MAX_PLAYERS] = {0, ...};
new already_skipped = false;
new PlayerShowHisTrophyID[MAX_PLAYERS] = {-10, ...};
new AccountsToAccept[MAX_PLAYERS][30] = {-1, ...};
new CardEffectToUnlock[MAX_PLAYERS] = {-1, ...};
new drugs[MAX_PLAYERS] = {5, ...};
new TempSpeciality[MAX_PLAYERS] = {-1, };
new bool:NewbieChangedClass[MAX_PLAYERS] = {false, ...};

new IsPlayerControlledBy[MAX_PLAYERS] = {-1, ...};
new PlayerControllPlayer[MAX_PLAYERS] = {-1, ...};
//new SpiderObject[MAX_PLAYERS][25];

new Text:DisplayAlerts[3][MAX_PLAYERS];
new Text:DisplayInfo[2][MAX_PLAYERS];
new Text3D: GangHouseExitText[29], Text3D: GangHouseText[29];


new bool:SelectReward[MAX_PLAYERS] = {true, ...};

new pActionsSelected[MAX_PLAYERS][6] = {{-1,-1},...};
new byingClass[MAX_PLAYERS][2] = {{-1,-1}, ...};
new CanPay = true;
new PHS_SelID[MAX_PLAYERS] = {-1, ...};

//Damage System 2.5

new KilledBy[MAX_PLAYERS] = {INVALID_PLAYER_ID, ...},
	KilledByWeapon[MAX_PLAYERS] = {0, ...},
	DamageApplyType[MAX_PLAYERS][2] = {{0, 0}, ...};

/********************************************************************************************/
new HeadshotsInCount[MAX_PLAYERS][MAX_PLAYERS];
new bool:SuspectForAIM[MAX_PLAYERS] = {false, ...};

//////////////////////////////////////////////////
enum e_PicksInfo
{
	bool:epi_PickCanDestroy,
	epi_EventID,
	e_ID,
    e_Time,
    e_ForPlayer,
    e_ItemID,
    e_DropperID
};

new Pickups[MAX_PICKUPS][e_PicksInfo];
new SpawnZoneTimer[MAX_PLAYERS] = {5, ...};

fun Float:random_range(Float: v1, Float: v2)
{
    new rand = floor(v1) + random(floor((v2 - v1) + v1));
	return float(rand);
}
static bool:IsUsingProxy[MAX_PLAYERS char] = {false, ...};
stock IsPlayerUsingProxy(playerid) return IsUsingProxy{playerid};

new gIP[MAX_PLAYERS][16], gTime[MAX_PLAYERS], MusicPlayTime = 0;
new PlayerGuitarTime[MAX_PLAYERS] = {0, ...};
new IsPlayerDeadByWarMember[MAX_PLAYERS] = {INVALID_PLAYER_ID, ...};

static LastShotTime[MAX_PLAYERS];
static gLastShotTime[MAX_PLAYERS];
new bool:Registered[MAX_PLAYERS char];

static ZombieSpawnProtection[MAX_PLAYERS];
#define         FAKEKILL_DELAY            4000
#define         FAKEKILL_LIMIT            10

new GangPanelIDs[MAX_PLAYERS][50];
new GangPanelIDSelected[MAX_PLAYERS] = {-1, ...};
new GangPanelName[MAX_PLAYERS][MAX_PLAYER_NAME];
new LasDeadTime[MAX_PLAYERS];

new HeroFieldTime[MAX_PLAYERS][2];
new IsPlayerDead[MAX_PLAYERS];

new ZombieMoveTime[MAX_PLAYERS] = {0, ...};

enum CommandFloodTime
{
	ShowGangMembers,
};

static const Float:defenders_poses[][4] = {
    {1530.6864,2367.9478,78.2364,180.4583},
	{1522.8361,2365.3040,78.2364,192.0517},
	{1539.3805,2365.4712,78.2364,178.2649},
	{1551.3309,2369.4048,78.2364,178.2649},
	{1559.0870,2363.7458,78.2364,175.4449},
	{1567.3710,2369.1812,78.2364,174.8182},
	{1574.8981,2364.8323,78.2364,177.0116},
	{1583.1244,2369.9995,78.2364,167.9249},
	{1590.0763,2367.3926,78.2364,177.6383},
	{1596.5137,2369.8997,78.2364,171.3716},
	{1601.7255,2364.8926,78.2364,174.1916}
};

static const Float:atatckers_poses[][4] = {
    {1150.2351,2361.2271,78.2364,175.4449},
	{1144.8065,2366.9424,78.2364,180.1450},
	{1136.7563,2362.3855,78.2364,177.6383},
	{1130.9297,2368.3184,78.2364,180.1450},
	{1124.7109,2364.4871,78.2364,177.6383},
	{1117.1676,2367.3674,78.2364,189.8584},
	{1107.9650,2361.3049,78.2364,175.4449},
	{1102.0345,2368.1489,78.2364,180.1450},
	{1094.3934,2361.6338,78.2364,180.1449},
	{1085.1019,2366.2693,78.2364,177.9516},
	{1072.8917,2362.7617,78.2364,179.5182}
};

static const DonateInfo[] = {
	"Bronze VIP (4 ZAPs):\n\
	- Bronze Tag In-Game\n\
	- VIP Human (30 days)\n\
	- Screamer Zombie (30 days)\n\
	- x1.3 EXP multiplier (killstreaks included)\n\n\
	Silver VIP (7 ZAPs):\n\
	- Silver Tag In-Game\n\
	- Tank Zombie (30 days)\n\
	- Slender Zombie (30 days)\n\
	- x1.6 EXP multiplier (killstreaks included)\n\n\
	Gold VIP (10 ZAPs):\n\
	- Gold Tag In-Game\n\
	- Assassin (30 days)\n\
	- /music\n\
	- /vipmenu (Choosing between starting commands)\n\
	- x2 EXP multiplier (killstreaks included)\n\n\n\
	FOR ALL VIPs:\n\n\
	- 50% '/. Armour for all the human classes\n\
	- Can use /skin\n\
	- /kickback\n\
	- Free /changename\n"
};

static const questions[][][] =
{
	{
	    "Random Question: for %d EXP: What is the name of the planet closest to the sun?",
	    "Random Question: for %d EXP: Which country has a plain green flag?",
	    "Random Question: for %d EXP: What causes craters on the moon?",
	    "Random Question: for %d EXP: The sunniest figure in geometry?",
	    "Random Question: for %d EXP: This month is called summer sunset. Which one?",
	    "Random Question: for %d EXP: What chemical element caused the death of Napoleon?",
	    "Random Question: for %d EXP: The name of this flightless bird from Australia consists of two notes. What kind of bird is this?",
	    "Random Question: for %d EXP: Where did the accordion first appear?",
	    "Random Question: for %d EXP: The deepest freshwater lake in the world?",
	    "Random Question: for %d EXP: What is the name of the water shell of the earth?",
	    "Random Question: for %d EXP: Which bird is called the forest doctor?",
	    "Random Question: for %d EXP: The highest point, above sea level, in Africa?",
	    "Random Question: for %d EXP: Gas, which is formed during photosynthesis of plants?",
	    "Random Question: for %d EXP: What month does Australia start in autumn?",
	    "Random Question: for %d EXP: What besides flags often fans wave in the stands?",
	    "Random Question: for %d EXP: Which US president wrote his own story about Sherlock Holmes?",
		"Random Question: for %d EXP: Which of the famous artists in his life sold just one painting?",
		"Random Question: for %d EXP: How many eyes does an ordinary fly have?",
		"Random Question: for %d EXP: Every day, the Earth adds 400 tons in weight. Due to what?",
		"Random Question: for %d EXP: How to write the word \"mousetrap\" in three letters?",
		"Random Question: for %d EXP: What stones are not in the sea?",
		"Random Question: for %d EXP: Which wheel does not spin in a right turn?"
	},
	{
	    "Случайный Вопрос: на %d ОПЫТА: Как называется планета, ближайшая к Солнцу?",
	    "Случайный Вопрос: на %d ОПЫТА: Какая страна имеет зеленый флаг?",
	    "Случайный Вопрос: на %d ОПЫТА: Что вызывает кратеры на луне?",
	    "Случайный Вопрос: на %d ОПЫТА: Самая солнечная фигура в геометрии?",
	    "Случайный Вопрос: на %d ОПЫТА: Этот месяц называется летним закатом. Который из?",
	    "Случайный Вопрос: на %d ОПЫТА: Какой химический элемент вызвал смерть Наполеона?",
	    "Случайный Вопрос: на %d ОПЫТА: Название этой нелетающей птицы из Австралии состоит из двух звуков. Что это за птица?",
	    "Случайный Вопрос: на %d ОПЫТА: Где впервые появился аккордеон?",
	    "Случайный Вопрос: на %d ОПЫТА: Самое глубокое пресноводное озеро в мире?",
	    "Случайный Вопрос: на %d ОПЫТА: Как называется водная оболочка земли?",
	    "Случайный Вопрос: на %d ОПЫТА: Какую птицу называют лесным врачом?",
	    "Случайный Вопрос: на %d ОПЫТА: Самая высокая точка над уровнем моря в Африке?",
	    "Случайный Вопрос: на %d ОПЫТА: Газ, который образуется при фотосинтезе растений?",
	    "Случайный Вопрос: на %d ОПЫТА: Какой месяц в Австралии начинается осенью?",
	    "Случайный Вопрос: на %d ОПЫТА: Чем помимо флагов часто фанаты машут на трибунах?",
	    "Случайный Вопрос: на %d ОПЫТА: Какой президент США написал свой собственный рассказ о Шерлоке Холмсе?",
		"Случайный Вопрос: на %d ОПЫТА: Кто из известных художников в своей жизни продал только одну картину?",
		"Случайный Вопрос: на %d ОПЫТА: Сколько глаз у обычной мухи?",
		"Случайный Вопрос: на %d ОПЫТА: Каждый день Земля прибавляет в весе 400 тонн. Из-за чего?",
		"Случайный Вопрос: на %d ОПЫТА: Как написать слово \"мышеловка\" тремя буквами?",
		"Случайный Вопрос: на %d ОПЫТА: Какие камни не в море?",
		"Случайный Вопрос: на %d ОПЫТА: Какое колесо не вращается при правом развороте?"
	},
	{
	    "Pregunta Aleatoria: por %d EXP: їCuбl es el nombre del planeta mбs cercano al sol?",
	    "Pregunta Aleatoria: por %d EXP: їQuй paнs tiene una bandera verde lisa?",
	    "Pregunta Aleatoria: por %d EXP: їQuй causa los crбteres en la luna?",
	    "Pregunta Aleatoria: por %d EXP: їLa figura mбs soleada en geometrнa?",
	    "Pregunta Aleatoria: por %d EXP: Este mes se llama atardecer de verano. їCъal?",
	    "Pregunta Aleatoria: por %d EXP: їQuй elemento quнmico causу la muerte de Napoleуn?",
	    "Pregunta Aleatoria: por %d EXP: El nombre de esta ave no voladora de Australia consta de dos notas. їQuй clase de pбjaro es este?",
	    "Pregunta Aleatoria: por %d EXP: їDуnde apareciу por primera vez el acordeуn?",
	    "Pregunta Aleatoria: por %d EXP: їEl lago de agua dulce mбs profundo del mundo?",
	    "Pregunta Aleatoria: por %d EXP: їCuбl es el nombre de la capa de agua de la tierra?",
	    "Pregunta Aleatoria: por %d EXP: їQuй pбjaro se llama el doctor del bosque?",
	    "Pregunta Aleatoria: por %d EXP: їEl punto mбs alto, sobre el nivel del mar, en Бfrica?",
	    "Pregunta Aleatoria: por %d EXP: Gas, que se forma durante la fotosнntesis de las plantas?",
	    "Pregunta Aleatoria: por %d EXP: їEn quй mes comienza Australia en otoсo?",
	    "Pregunta Aleatoria: por %d EXP: їQuй, ademбs de las banderas, a menudo los fanбticos agitan en las gradas?",
	    "Pregunta Aleatoria: por %d EXP: їQuй presidente de los Estados Unidos escribiу su propia historia sobre Sherlock Holmes?",
		"Pregunta Aleatoria: por %d EXP: їCuбl de los artistas famosos de su vida vendiу solo una pintura?",
		"Pregunta Aleatoria: por %d EXP: їCuбntos ojos tiene una mosca comъn?",
		"Pregunta Aleatoria: por %d EXP: Todos los dнas, la Tierra agrega 400 toneladas de peso. їPor quй?",
		"Pregunta Aleatoria: por %d EXP: їCуmo escribir la palabra \"ratonera\" de una manera diferente?",
		"Pregunta Aleatoria: por %d EXP: їQuй piedras no estбn en el mar?",
		"Pregunta Aleatoria: por %d EXP: їQuй rueda no gira en un giro a la derecha?"
	}
};

static const questions_answers[][][] =
{
	{
		"Mercury", "Libya", "Meteorites", "Beam", "August", "Arsenic",
		"Dodo", "Australia", "Baikal", "Hydrosphere", "Woodpecker", "Kilimanjaro", "Oxygen", "March", "Scarves",
		"Franklin Roosevelt", "Vincent Van Gogh", "Five", "cosmic dust", "Cat", "Dry", "Spare wheel"
	},
	{
	    "Меркурий", "Ливия", "Метеориты", "Луч", "Август", "Мышьяк",
		"Додо", "Австралия", "Байкал", "гидросфера", "Дятел", "Килиманджаро", "кислород", "март", "шарфы",
		"Франклин Рузвельт", "Винсент Ван Гог", "Пять", "космическая пыль", "Кот", "Сухие", "Запасное"
	},
	{
	    "Mercurio", "Libia", "Meteoritos", "Haz", "agosto", "Arsйnico",
		"Dodo", "Australia", "Baikal", "Hidrosfera", "Pбjaro carpintero", "Kilimanjaro", "Oxнgeno", "marzo", "Bufandas",
		"Franklin Roosevelt", "Vincent Van Gogh", "Cinco", "polvo cуsmico", "Gato", "Seco", "Rueda de repuesto"
	}
};

static const rank_names[][] = {
	"Newbie", 					"Peon",					"Scout",					"Grunt",
	"First Sergeant",			"Sergeant",				"Senior Sergeant",			"Obsidian Slayer",
	"Dragon Slayer",			"Stone Guard",			"Blood Guard",				"Grand Crusader",
	"Centurion",				"Legionnaire",			"Scarab Lord",				"Warlord",
	"High Warlord",				"Argent Defender",		"Argent Warrior",			"Insatiable Warrior",
	"Conqueror of Naxxramas",	"Champion",				"Liberator",				"The Magic Seeker",
	"Twilight Vanquisher",		"The Light of Dawn",	"Luminous Angel",			"Sleepwalker",
	"Starcaller",				"Constellation",		"Inhuman Warlord",			"Bloody Legend",
	"Bearing Death"
};

static const rank_exp[] = {
	5, 							10,						20,					        30,
	45,							60,						75,							90,
	135,						180,					225,      					270,
	405,						540,					675,						810,
	1215,						1620,					2025,						2430,
	3645,						4860,					6075,						7290,
	10935,						14580,					18225,						21870,
	32805,						43740,					54675,						65610,
	98415
};

new CommandFloodTimer[MAX_PLAYERS][CommandFloodTime];

/*enum WeapEnc:(<<=1)
{
	we_MoreDamage = 0,
	we_CriticalDamage,
	we_MoreAmmo,
	we_Bleeding,
};

enum CharEnc:(<<=1)
{
	ce_LessDamage = 0,
	ce_AddArmour,
	ce_AddHealth,
	ce_Uklon,
};

new WeapEnc:WeapEnchantments[MAX_PLAYERS][42];
new CharEnc:CharEnchantments[MAX_PLAYERS];*/

new Iterator:Players<MAX_PLAYERS>;

enum srst
{
	cn_Ru,
	cn_Sp,
	cn_En
};

new ServerStats[srst];

enum
{
	PS_BLOCK_PMS = 0,
	PS_DING,
	PS_BLOCK_DUELS,
	PS_ABILITY_READY,
	PS_AUTO_LOGIN,
	PS_HIDDEN,
	PS_SHOW_EXP,
 	PS_SHOW_PET,
	PS_IAP,
	PS_VOICE,
	PS_MUSIC,
	PS_TICK,
	PS_FPS,
	PS_ALERTS,
};

enum FAKEKILLINFO
{
    DeathCount,
    LastDeathTime,
};
static FakekillData[MAX_PLAYERS][FAKEKILLINFO];

new Text:XP[MAX_PLAYERS], lmrf[MAX_PLAYERS] = {INVALID_PLAYER_ID, ...};
new reportsCount;
new Text:ServerIntro[MAX_PLAYERS][5];
new Time, mapid = 0, current_map, mapvar[3] = {-1,-1, -1}, playerOnline, Text:GreenScreen[MAX_PLAYERS], Text:Poision[MAX_PLAYERS], Text:Stun[MAX_PLAYERS], Text: Blidnes[MAX_PLAYERS];
new Text:Infected[MAX_PLAYERS], Text:SpawnProtection[MAX_PLAYERS], Text3D: SpawnPoints[5], Text: Blind[MAX_PLAYERS];
new Text:TimeLeft, Text:FPS_Info[MAX_PLAYERS], Text:AliveInfo[MAX_PLAYERS], CBugTimes[MAX_PLAYERS] = 0;
new Text:UntillEvac[2][MAX_PLAYERS], bool:MapStarted, humansEvacuated = 0, bool:reconnect[MAX_PLAYERS];
new Float: playerStats[MAX_PLAYERS][4], Float:LastHealth[MAX_PLAYERS][2];
new bool: PlayerShotPlayer[MAX_PLAYERS][MAX_PLAYERS], bool:FirstBlood, bool:LastHumanKilled, bool:Healer[MAX_PLAYERS];

static MySQL: Base;

new box[MAX_PLAYERS][18], Portals[MAX_PLAYERS] = {-1, ...}, Float:PortalsHealth[MAX_PLAYERS] = {400.0,...}, Text3D: PortalsText[MAX_PLAYERS], Text3D: boxText[MAX_PLAYERS][18];
new AFK[MAX_PLAYERS] = -1;//, MybeBH[MAX_PLAYERS];
new mapGate = -1, mapGate2 = -1, mapFlag = -1, attemptsToLog[MAX_PLAYERS] = -1, Suspecting[MAX_PLAYERS] = 0;
new bool: NeededforDefine, bool: IsEvacuated[MAX_PLAYERS];
new bool: lastHuman[MAX_PLAYERS], bool: LastAlive, bool:HumanZombieBoss[MAX_PLAYERS], bool:HumanHumanBoss[MAX_PLAYERS];
new NM[MAX_PLAYERS][MAX_PLAYER_NAME], meatDrops[MAX_PICKUPS] = -1, meatDropsID[MAX_PICKUPS] = {-1,...}, infectedMeat[MAX_PLAYERS] = {-1, ...};
new bool: CockroachAbility[MAX_PLAYERS], bool: IsOnRegister[MAX_PLAYERS];
new voites, bool:kick_player[MAX_PLAYERS], bool:already_vote[MAX_PLAYERS], bool:votekick, votekick_max_voices, VoteKickTimer;
new Float:TAXES = 0.35, AdminVeh[MAX_PLAYERS] = {-1,...}, RegisterTimer[MAX_PLAYERS];
new bool:IsSpecing[MAX_PLAYERS]={false,...}, bool:IsBeingSpeced[MAX_PLAYERS]={false,...},spectatorid[MAX_PLAYERS]= {-1, ...};
new bool:isReported[MAX_PLAYERS][MAX_PLAYERS];
new MapObjects[9], maps = 1, LastMessage[MAX_PLAYERS][144], LastMessageTime[MAX_PLAYERS], LastMessagesTryed[MAX_PLAYERS] = {0,...}, Text:AIR[MAX_PLAYERS];

new
	bool: IsPlayerOnDuel[MAX_PLAYERS], DuelerID[MAX_PLAYERS],
	bool: DuelReceived[MAX_PLAYERS], DuelerWeapon[MAX_PLAYERS],
	DuelEXP[MAX_PLAYERS], DuelRules[2][MAX_PLAYERS];

new bool:QuizStarted, QuizIndex = 0, QuizType, QuizXp, QuizTextAnswer[11], QuizRealAnswer, GangAction[MAX_PLAYERS], restartTimes = -1;
new S0beitSuspecting[MAX_PLAYERS] = 0;
new Float:OldPos[MAX_PLAYERS][4], AntiPlayerTP[MAX_PLAYERS], AntiPlayerSpeedHack[MAX_PLAYERS], AntiPlayerSlap[MAX_PLAYERS], p_FallingCheck[MAX_PLAYERS char], p_FallingTime[MAX_PLAYERS];
new TintaApasata[MAX_PLAYERS];
new BanRequest[MAX_PLAYERS] = -1, BanReason[MAX_PLAYERS][64];
new AntiSobeit[MAX_PLAYERS] = {0,...}, AimOff[MAX_PLAYERS] = { 0, ... };
new SobeitTime[MAX_PLAYERS], lotteryNumber[MAX_PLAYERS] = {-1,...};
new PlayerText[MAX_PLAYERS][128], PlayerTextType[MAX_PLAYERS], bool:AntiCheatAlertMode = true;
new Text3D:IsPlayerAcceleratedText[MAX_PLAYERS]={Text3D:-1,...}, Float:NewSpawnPoints[2][6] = { {0.0,...}, {0.0, ...} }, Text3D: NewSpawnPointsText[2], NewSpawnsCreators[2];
new Text3D:GangName[MAX_PLAYERS]={Text3D:-1,...};
new FakeData[MAX_PLAYERS][9];
new ProAimCount[MAX_PLAYERS];
new Text3D:DefenderText[MAX_PLAYERS] = {Text3D:-1,...};

new bool:AntiCheatVehicle[MAX_PLAYERS] = {false, ...};
new bool:IsBanned[MAX_PLAYERS char];
new WasZombieTimes[MAX_PLAYERS] = {0, ...};
new WasHumanTimes[MAX_PLAYERS] = {0, ...};

new CanUseCBugTime[MAX_PLAYERS] = {0, ...}, BadNetworkTime[MAX_PLAYERS] = {0, ...};

enum DamageChecker
{
	p_ID,
	Float:p_HP,
	Times,
	uAFK,
	Float:DamageGiven,
};

new PlayerDamageChecker[MAX_PLAYERS][DamageChecker];

#define AC_MAX_BULLET_PROOF_WARNINGS 2
#define AC_MAX_COLLISION_PROOF_WARNINGS 2
#define AC_MAX_EXPLOSION_PROOF_WARNINGS 2
#define AC_MAX_TELEPORTS 1
#define AC_MAX_SPACE_BREAKS 2
#define AX_MAX_JUMPS 1

enum e_ac
{
	ac_Tick,
	Float:ac_OldHP,
	Float:ex_OldHP,
	Float:weap_OldHP,
	
	ac_break_space,
	ac_cs_warns,
	ac_ex_warns,
	ac_bp_warns,
	
	ac_teleports,
	ac_jumps,
	
	ac_weapon_hack,
	ac_parkour,
	ac_health_hack,

	ac_teleport_hack,
	ac_jump_hack,
	ac_airbreak_hack,
	weap_bp_ticks,
};

new AntiCheat[MAX_PLAYERS][e_ac];

#if debug_mode == 0
new DCC_Channel:DiscordChannel;
#endif

AntiDeAMX()
{
    new a[][] =
    {
        "Unarmed (Fist)",
        "Brass K"
    };
    #pragma unused a
}

new randomMessages[][][] =
{
	{
	    "{B2F558}>> Use /maps to see map list.", // 2
	    "{B2F558}>> Want to talk about something personal? Use /pm!", // 3
	    "{B2F558}>> Change your class using /class", // 5
	    "{B2F558}>> As a Human, you must survive. As a Zombie, you must kill humans.", // 6
	  	"{B2F558}>> Earn experience by killing an enemy team or use your abilities!", // 7
	  	"{B2F558}>> Newbie? We advise you to look /cmds, /help, /rules!", // 8
	  	"{B2F558}>> Use /report to report rulebreakers.", // 9
	  	"{B2F558}>> Want to become a team player? Join the gang /gang join!", // 10
	  	"{B2F558}>> Try out new gang system. Check /gang help", // 11
	  	"{B2F558}>> Did you see the cheater? Use /votekick!", // 12
	  	"{B2F558}>> Zombies can infect humans using LEFT ALT. This will slowly kill them.", // 13
	  	"{B2F558}>> You can cure people use /cure!", // 14
	  	"{B2F558}>> Sign up to our forum at "FORUM" to chat us!", // 16
	  	"{B2F558}>> Are You Heavy Support? Share ammo with your team /giveammo!", // 17
	  	"{B2F558}>> You can save your stats with /ss!", // 19
	  	"{B2F558}>> Want to be a VIP? Check out /donate system!",
	  	"{B2F558}>> Do not forget to add our server to favorites! (46.174.50.20:7805)"
	},
	{
	    "{B2F558}>> Use /maps to see map list.", // 2
	    "{B2F558}>> Want to talk about something personal? Use /pm!", // 3
	    "{B2F558}>> Change your class using /class", // 5
	    "{B2F558}>> As a Human, you must survive. As a Zombie, you must kill humans.", // 6
	  	"{B2F558}>> Earn experience by killing an enemy team or use your abilities!", // 7
	  	"{B2F558}>> Newbie? We advise you to look /cmds, /help, /rules!", // 8
	  	"{B2F558}>> Use /report to report rulebreakers.", // 9
	  	"{B2F558}>> Want to become a team player? Join the gang /gang join!", // 10
	  	"{B2F558}>> Try out new gang system. Check /gang help", // 11
	  	"{B2F558}>> Did you see the cheater? Use /votekick!", // 12
	  	"{B2F558}>> Zombies can infect humans using LEFT ALT. This will slowly kill them.", // 13
	  	"{B2F558}>> You can cure people use /cure!", // 14
	  	"{B2F558}>> Sign up to our forum at "FORUM" to chat us!", // 16
	  	"{B2F558}>> Are You Heavy Support? Share ammo with your team /giveammo!", // 17
	  	"{B2F558}>> You can save your stats with /ss!", // 19
	  	"{B2F558}>> Want to be a VIP? Check out /donate system!",
	  	"{B2F558}>> Do not forget to add our server to favorites! (46.174.50.20:7805)"
  	},
  	{
        "{B2F558}>> Use /maps to see map list.", // 2
	    "{B2F558}>> Want to talk about something personal? Use /pm!", // 3
	    "{B2F558}>> Change your class using /class", // 5
	    "{B2F558}>> As a Human, you must survive. As a Zombie, you must kill humans.", // 6
	  	"{B2F558}>> Earn experience by killing an enemy team or use your abilities!", // 7
	  	"{B2F558}>> Newbie? We advise you to look /cmds, /help, /rules!", // 8
	  	"{B2F558}>> Use /report to report rulebreakers.", // 9
	  	"{B2F558}>> Want to become a team player? Join the gang /gang join!", // 10
	  	"{B2F558}>> Try out new gang system. Check /gang help", // 11
	  	"{B2F558}>> Did you see the cheater? Use /votekick!", // 12
	  	"{B2F558}>> Zombies can infect humans using LEFT ALT. This will slowly kill them.", // 13
	  	"{B2F558}>> You can cure people use /cure!", // 14
	  	"{B2F558}>> Sign up to our forum at "FORUM" to chat us!", // 16
	  	"{B2F558}>> Are You Heavy Support? Share ammo with your team /giveammo!", // 17
	  	"{B2F558}>> You can save your stats with /ss!", // 19
	  	"{B2F558}>> Want to be a VIP? Check out /donate system!",
	  	"{B2F558}>> Do not forget to add our server to favorites! (46.174.50.20:7805)"
	}
};

new AdminRanks[][][] =
{
	{
	    "Helper",
	    "Moderator",
	    "Administrator",
	    "Lead Administrator",
	    "Manager",
	    "Owner"
	},
	{
	    "Помощник",
		"Модератор",
		"Администратор",
	    "Ведущий администратор",
	    "Менеджер",
	    "Основатель"
	},
	{
	    "Helper",
	    "Moderator",
	    "Administrator",
	    "Lead Administrator",
	    "Manager",
	    "Owner"
	}
};

new humanClassesListNames[][][] =
{
	{
		"Civilian",          "Samurai",                "Boxer",                 "Policeman",
		"Gangster",          "Advanced Civilian",      "Medic",                 "Scout",
		"Heavy Support",     "Heavy Medic",            "Hero",                  "Engineer",
		"Warm Person",       "Zombiefan",              "Mi7",
	    "Scavenger",         "Firemaniac",             "Advanced Engineer",     "S.W.A.T",
		"Toughie",           "Advanced Medic",         "Sapper",                "Rollerskater",
		"Runner",            "Terrorist",              "Advanced Scout",        "Rogue Human",
		"Tourist",           "Copier",                 "Advanced Zombiefan",    "Advanced Samurai",
		"Advanced Boxer",    "Senior Medic",           "Rocketman",             "Advanced Policeman",
		"Sharpshooter",      "Spider-Man",             "Nurse",                 "Poisoner",
		"Iron Man",          "Expirienced Engineer",   "Human Queen",           "Advanced Hero"
	},
	{
		"Civilian",          "Samurai",                "Boxer",                 "Policeman",
		"Gangster",          "Advanced Civilian",      "Medic",                 "Scout",
		"Heavy Support",     "Heavy Medic",            "Hero",                  "Engineer",
		"Warm Person",       "Zombiefan",              "Mi7",
	    "Scavenger",         "Firemaniac",             "Advanced Engineer",     "S.W.A.T",
		"Toughie",           "Advanced Medic",         "Sapper",                "Rollerskater",
		"Runner",            "Terrorist",              "Advanced Scout",        "Rogue Human",
		"Tourist",           "Copier",                 "Advanced Zombiefan",    "Advanced Samurai",
		"Advanced Boxer",    "Senior Medic",           "Rocketman",             "Advanced Policeman",
		"Sharpshooter",      "Spider-Man",             "Nurse",                 "Poisoner",
		"Iron Man",          "Expirienced Engineer",   "Human Queen",           "Advanced Hero"
	},
	{
		"Civilian",          "Samurai",                "Boxer",                 "Policeman",
		"Gangster",          "Advanced Civilian",      "Medic",                 "Scout",
		"Heavy Support",     "Heavy Medic",            "Hero",                  "Engineer",
		"Warm Person",       "Zombiefan",              "Mi7",
	    "Scavenger",         "Firemaniac",             "Advanced Engineer",     "S.W.A.T",
		"Toughie",           "Advanced Medic",         "Sapper",                "Rollerskater",
		"Runner",            "Terrorist",              "Advanced Scout",        "Rogue Human",
		"Tourist",           "Copier",                 "Advanced Zombiefan",    "Advanced Samurai",
		"Advanced Boxer",    "Senior Medic",           "Rocketman",             "Advanced Policeman",
		"Sharpshooter",      "Spider-Man",             "Nurse",                 "Poisoner",
		"Iron Man",          "Expirienced Engineer",   "Human Queen",           "Advanced Hero"
	}
};

new svrCLHXP[] =
{
 	0,      200,    300,    500,
	700,    1000,   1500,   1500,
	3000,   3000,   6000,   7500,
	8000,   11000,  15000,
	17000,  20000,  25000,  35000,
	40000,  45000,  45000,  50000,
	60000,  70000,  90000,  90000,
	100000, 110000, 125000, 150000,
	150000, 150000, 180000, 200000,
	250000, 300000, 350000, 400000,
	600000, 850000, 1500000, 2000000
};

new PlayerClassUnlocked[MAX_PLAYERS][2][64];

new svrCLH[][][] =
{
	{
	    "Silenced Pistol, Shotgun",       				"Katana, Fighting style",           			"Deagle, Fighting style",   					"Deagle, Shotgun",
	    "Deagle, Spraycan",               				"Silenced Pistol, Ak47, Rifle",     			"Can cure",                 					"Invisibile On Radar",
        "Ammo Boxes",  									"Can cure",     								"Chainsaw-Resistance",   						"Can Build",
		"Anti-Freeze",    								"Chainsaw, Immunity",      						"M4, Deagle, Armour",
        "Increased Ammo From Meats, Anti-Flesher",  	"Shotgun, Flamethower, Fire Bullets",      		"Can Build",                					"Immunity",
        "Anti-Stomp, Anti-Frightening",             	"Can Cure",     								"Anti-Explosions",                              "Rollerskaters",
        "Fast Run",										"Deagle, Satchel Charges",                      "Invisible",     		    					"Skin Changing",
		"Evac Bounty",                  				"Can Copy Classes",           					"Chainsaw-Resistance",  						"One Kill From Katana",
        "One Kill From Fists",                  		"Can Cure In A Range",    						"Rocketboots",                              	"Can Taser Zombie",
		"Immunity, Headshots",              			"Long Jump",                          			"Nurse-Field while not moving",                	"Poisoned Bullets",
        "Fast Run, Long Jump, Chainsaw-Resistance",    	"Immunity, Can Build", 							"Immunity, Long Jump, Roller Skaters",   		"Hero-Field"
	},
	{
	    "Silenced Pistol, Shotgun",       				"Katana, Fighting style",           			"Deagle, Fighting style",   					"Deagle, Shotgun",
	    "Deagle, Spraycan",               				"Silenced Pistol, Ak47, Rifle",     			"Can cure",                 					"Invisibile On Radar",
        "Ammo Boxes",  									"Can cure",     								"Chainsaw-Resistance",   						"Can Build",
		"Anti-Freeze",    								"Chainsaw, Immunity",      						"M4, Deagle, Armour",
        "Increased Ammo From Meats, Anti-Flesher",  	"Shotgun, Flamethower, Fire Bullets",      		"Can Build",                					"Immunity",
        "Anti-Stomp, Anti-Frightening",             	"Can Cure",     								"Anti-Explosions",                              "Rollerskaters",
        "Fast Run",										"Deagle, Satchel Charges",                      "Invisible",     		    					"Skin Changing",
		"Evac Bounty",                  				"Can Copy Classes",           					"Chainsaw-Resistance",  						"One Kill From Katana",
        "One Kill From Fists",                  		"Can Cure In A Range",    						"Rocketboots",                              	"Can Taser Zombie",
		"Immunity, Headshots",              			"Long Jump",                          			"Nurse-Field while not moving",                	"Poisoned Bullets",
        "Fast Run, Long Jump, Chainsaw-Resistance",    	"Immunity, Can Build", 							"Immunity, Long Jump, Roller Skaters",   		"Hero-Field"
	},
	{
	    "Silenced Pistol, Shotgun",       				"Katana, Fighting style",           			"Deagle, Fighting style",   					"Deagle, Shotgun",
	    "Deagle, Spraycan",               				"Silenced Pistol, Ak47, Rifle",     			"Can cure",                 					"Invisibile On Radar",
        "Ammo Boxes",  									"Can cure",     								"Chainsaw-Resistance",   						"Can Build",
		"Anti-Freeze",    								"Chainsaw, Immunity",      						"M4, Deagle, Armour",
        "Increased Ammo From Meats, Anti-Flesher",  	"Shotgun, Flamethower, Fire Bullets",      		"Can Build",                					"Immunity",
        "Anti-Stomp, Anti-Frightening",             	"Can Cure",     								"Anti-Explosions",                              "Rollerskaters",
        "Fast Run",										"Deagle, Satchel Charges",                      "Invisible",     		    					"Skin Changing",
		"Evac Bounty",                  				"Can Copy Classes",           					"Chainsaw-Resistance",  						"One Kill From Katana",
        "One Kill From Fists",                  		"Can Cure In A Range",    						"Rocketboots",                              	"Can Taser Zombie",
		"Immunity, Headshots",              			"Long Jump",                          			"Nurse-Field while not moving",                					"Poisoned Bullets",
        "Fast Run, Long Jump, Chainsaw-Resistance",    	"Immunity, Can Build", 							"Immunity, Long Jump, Roller Skaters",   		"Hero-Field"
	}
};

new zombieVIPCl[][][] =
{
	{
	    "Screamer Zombie",
	    "Tank Zombie",
	    "Slender Zombie"
	    //faf06d
	},
	{
	    "Страшный Зомби",
	    "Танк Зомби",
	    "Slender Zombie"
	},
	{
	    "Zombi Chillуn",
	    "Tanque Zombi",
	    "Slender Zombie"
	    //faf06d
	}
};

new zombieVipClIDs[] = { SCREAMERZOMBIE, TANKZOMBIE, SLENDERZOMBIE }; // JUGGERNAUT

new zombieVIPClAb[][][] =
{
	{
	    "Drop Everyone Down",
	    "300 HP",
	    "Frightening"
	},
	{
	    "Drop Everyone Down",
	    "300 HP",
     	"Frightening"
	},
	{
	    "Drop Everyone Down",
	    "300 HP",
     	"Frightening"
	}
};

new zombieVIPClXP[] = {1, 2, 2};

new humanVIPCl[][][] =
{
	{
	    "VIP Human",
	    "Assassin"
	    //faf06d
	},
	{
	    "VIP Human",
	    "Assassin"
	},
	{
	    "VIP Human",
	    "Assassin"
	    //faf06d
	}
};

new humanVIPClAb[][][] =
{
	{
	    "Almost Everything",
	    "Headshots"
	},
	{
	    "Almost Everything",
	    "Headshots"
	},
	{
	    "Almost Everything",
	    "Headshots"
	}
};

new humanVIPClXP[] = {1, 3};

new humanVipClIDs[] = { VIPHUMAN, ASSASSIN}; // , PYROMANIAC, CRY

new svrCLZXP[END_OF_ZOMBIE_CLASSES] =
{
	0, 	     400,     1500,     2500,
	3000,    4000,    5000,     5000,
	5500,    7000,    11000,    15000,
	20000,   25000,   30000,    35000,
	40000,   45000,   45000,    45000,
	50000,   60000,   90000,    100000,
	100000,  125000,  150000,   150000,
	220000,  250000,
	250000,  300000,  500000
};

new zombieClassesListNames[][END_OF_ZOMBIE_CLASSES][] =
{
	{
		"Standard Zombie",		"Mutated Zombie",		"Blind Zombie",			"Reaper Zombie",
		"Flesher Zombie",		"Tornado Zombie",		"Fast Zombie",			"Boomer Zombie",
		"Demon Zombie",			"Pirate Zombie",		"Camouflage Zombie",	"Kamikaze Zombie",
		"Regenerator Zombie",	"Stomper Zombie",		"Rogue Zombie",			"Remover",
		"Mega Jumper",			"Cure Blocker",			"Radioactive Zombie",	"Freezer Zombie",
		"Seeker Zombie",		"Advanced Mutated",		"Undead Boxer",			"Earthshaker Zombie",
		"Spitter Zombie",		"Punk Zombie",			"Slow Zombie",			
		"Legbreaker Zombie",	"Risen Dead",			"Enforcer Zombie",
		"Spore Zombie",			"Space Breaker",		"Gun Jammer"
	},
	{
		"Standard Zombie",		"Mutated Zombie",		"Blind Zombie",			"Reaper Zombie",
		"Flesher Zombie",		"Tornado Zombie",		"Fast Zombie",			"Boomer Zombie",
		"Demon Zombie",			"Pirate Zombie",		"Camouflage Zombie",	"Kamikaze Zombie",
		"Regenerator Zombie",	"Stomper Zombie",		"Rogue Zombie",			"Remover",
		"Mega Jumper",			"Cure Blocker",			"Radioactive Zombie",	"Freezer Zombie",
		"Seeker Zombie",		"Advanced Mutated",		"Undead Boxer",			"Earthshaker Zombie",
		"Spitter Zombie",		"Punk Zombie",			"Slow Zombie",			
		"Legbreaker Zombie",	"Risen Dead",			"Enforcer Zombie",
		"Spore Zombie",			"Space Breaker",		"Gun Jammer"
	},
	{
	    "Standard Zombie",		"Mutated Zombie",		"Blind Zombie",			"Reaper Zombie",
		"Flesher Zombie",		"Tornado Zombie",		"Fast Zombie",			"Boomer Zombie",
		"Demon Zombie",			"Pirate Zombie",		"Camouflage Zombie",	"Kamikaze Zombie",
		"Regenerator Zombie",	"Stomper Zombie",		"Rogue Zombie",			"Remover",
		"Mega Jumper",			"Cure Blocker",			"Radioactive Zombie",	"Freezer Zombie",
		"Seeker Zombie",		"Advanced Mutated",		"Undead Boxer",			"Earthshaker Zombie",
		"Spitter Zombie",		"Punk Zombie",			"Slow Zombie",
		"Legbreaker Zombie",	"Risen Dead",			"Enforcer Zombie",
		"Spore Zombie",			"Space Breaker",		"Gun Jammer"
	}
};

new svrCLZ[][END_OF_ZOMBIE_CLASSES][] =
{
	{
	    "Can Infect",               	"Infection Drunk Vision",        		"Blinding By Infection",       "Takes Additional Health",
        "Can Drop Infected Meat",   	"Draws Meat To Himself",         		"High Jump",                   "Explodes And Infects",
        "Explodes And Sets Fire",       "Katana",                        		"Invisible",      				"Explodes On Request",
	    "Can Regenerate Health",    	"Throw Around",            	     		"Skin Changing",               "Can Remove Human's Armour",
		"Can Jump Many Times",      	"Disables Any Kind Of Curing",   		"Radioactive Field",           "Can Freeze",
		"Can Teleport To The Player",   "Infected Human Will Infect Others",	"Can Punch Humans",            "Can Shake The Earth",
		"Can Infect By Shot",       	"Infection Killing Faster",      		"Infection Slow Moving",       
	    "Can Break Legs",           	"Creates New Spawn Points",    			"Bullet-Resistance",
	    "Can Temporary Throws Spores",  "Can Breaks Space", 			 		"Can Temporary Take Weapons"
	},
	{
 		"Can Infect",               	"Infection Drunk Vision",        		"Blinding By Infection",       "Takes Additional Health",
        "Can Drop Infected Meat",   	"Draws Meat To Himself",         		"High Jump",                   "Explodes And Infects",
        "Explodes And Sets Fire",       "Katana",                        		"Invisible",      				"Explodes On Request",
	    "Can Regenerate Health",    	"Throw Around",            	     		"Skin Changing",               "Can Remove Human's Armour",
		"Can Jump Many Times",      	"Disables Any Kind Of Curing",   		"Radioactive Field",           "Can Freeze",
		"Can Teleport To The Player",   "Infected Human Will Infect Others",	"Can Punch Humans",            "Can Shake The Earth",
		"Can Infect By Shot",       	"Infection Killing Faster",      		"Infection Slow Moving",       
	    "Can Break Legs",           	"Creates New Spawn Points",    			"Bullet-Resistance",
	    "Can Temporary Throws Spores",  "Can Breaks Space", 			 		"Can Temporary Take Weapons"
	},
	{
 		"Can Infect",               	"Infection Drunk Vision",        		"Blinding By Infection",       "Takes Additional Health",
        "Can Drop Infected Meat",   	"Draws Meat To Himself",         		"High Jump",                   "Explodes And Infects",
        "Explodes And Sets Fire",       "Katana",                        		"Invisible",      				"Explodes On Request",
	    "Can Regenerate Health",    	"Throw Around",            	     		"Skin Changing",               "Can Remove Human's Armour",
		"Can Jump Many Times",      	"Disables Any Kind Of Curing",   		"Radioactive Field",           "Can Freeze",
		"Can Teleport To The Player",   "Infected Human Will Infect Others",	"Can Punch Humans",            "Can Shake The Earth",
		"Can Infect By Shot",       	"Infection Killing Faster",      		"Infection Slow Moving",       
	    "Can Break Legs",           	"Creates New Spawn Points",    			"Bullet-Resistance",
	    "Can Temporary Throws Spores",  "Can Breaks Space", 			 		"Can Temporary Take Weapons"
	}
};

static const CodeLetters[] =
{
	'A', 'E', 'I', 'O', 'U', 'Y',
	'B', 'C', 'D', 'F', 'G', 'H',
	'J', 'K', 'L', 'M', 'N', 'P',
	'Q', 'R', 'S', 'T', 'V', 'W',
	'X', 'Y', 'Z', 'a', 'e', 'i',
	'o', 'u', 'y', 'b', 'c', 'd',
	'f', 'g', 'h', 'j', 'k', 'l',
	'm', 'n', 'p', 'q', 'r', 's',
	't', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5',
	'6', '7', '8', '9'
};


enum colorInfo { ci_code, ci_name[24] };

enum AttachmentEnum
{
    attachmodel,
    attachname[36]
}

static const newAttachement[][AttachmentEnum] =
{
    { 902, "{00ace6}Sea Star" },
	{ 953 ,"{00ace6}Horsehoe" },
 	{ 954 ,"{00ace6}Shell" },
	{ 1598 ,"{00ace6}Beach Ball" },
	{ 2782 ,"{00ace6}Shell #2" },
	{ 1210 ,"{00ace6}Case" },
	{ 19591 ,"{00ace6}Fan" },
	{ 19590 ,"{00ace6}Machete" },
	{ 19624 ,"{00ace6}CJ Suitcase" },
	{ 11704 ,"{00ace6}Devil Mask" },
	{ 19307 ,"{00ace6}Blue Flag" }
};

new AttachmentObjects[][AttachmentEnum] = {

{1276, "Secret package"},
{1550, "Money bag"},
{2406, "Surfboard"},
{2976, "Green Gloop"},
{19528, "Witch hat"},
{19527, "Witch's cauldron"},
{19306, "Flag"},

//{19588, "Wing"},
//{11712, "Cross"},
//{19339, "Cofin"},

{19066, "Santa Hat"},
{18632, "FishingRod"},
{18633, "GTASAWrench1"},
{18638, "HardHat1"},
{18639, "BlackHat1"},
{18640, "Hair1"},
{18975, "Hair2"},
{19136, "Hair4"},
{19274, "Hair5"},
{18642, "Taser1"},
{18644, "Screwdriver1"},
{18645, "MotorcycleHelmet1"},
{18874, "MobilePhone10"},
{18875, "Pager1"},
{18890, "Rake1"},
{18911, "Mask1"},
{18912, "Mask2"},
{18913, "Mask3"},
{18914, "Mask4"},
{18915, "Mask5"},
{18916, "Mask6"},
{18917, "Mask7"},
{18918, "Mask8"},
{18919, "Mask9"},
{18920, "Mask10"},
{18921, "Beret1"},
{18922, "Beret2"},
{18923, "Beret3"},
{18924, "Beret4"},
{18925, "Beret5"},
{18926, "Hat1"},
{18927, "Hat2"},
{18928, "Hat3"},
{18929, "Hat4"},
{18930, "Hat5"},
{18931, "Hat6"},
{18932, "Hat7"},
{18933, "Hat8"},
{18934, "Hat9"},
{18935, "Hat10"},
{18936, "Helmet1"},
{18937, "Helmet2"},
{18938, "Helmet3"},
{18939, "CapBack1"},
{18940, "CapBack2"},
{18941, "CapBack3"},
{18942, "CapBack4"},
{18943, "CapBack5"},
{18944, "HatBoater1"},
{18945, "HatBoater2"},
{18946, "HatBoater3"},
{18947, "HatBowler1"},
{18948, "HatBowler2"},
{18949, "HatBowler3"},
{18950, "HatBowler4"},
{18951, "HatBowler5"},
{18952, "BoxingHelmet1"},
{18953, "CapKnit1"},
{18954, "CapKnit2"},
{18955, "CapOverEye1"},
{18956, "CapOverEye2"},
{18957, "CapOverEye3"},
{18958, "CapOverEye4"},
{18959, "CapOverEye5"},
{18960, "CapRimUp1"},
{18961, "CapTrucker1"},
{18962, "CowboyHat2"},
{18963, "CJElvisHead"},
{18964, "SkullyCap1"},
{18965, "SkullyCap2"},
{18966, "SkullyCap3"},
{18967, "HatMan1"},
{18968, "HatMan2"},
{18969, "HatMan3"},
{18970, "HatTiger1"},
{18971, "HatCool1"},
{18972, "HatCool2"},
{18973, "HatCool3"},
{18974, "MaskZorro1"},
{19039, "WatchType1"},
{19040, "WatchType2"},
{19041, "WatchType3"},
{19042, "WatchType4"},
{19043, "WatchType5"},
{19044, "WatchType6"},
{19045, "WatchType7"},
{19046, "WatchType8"},
{19047, "WatchType9"},
{19048, "WatchType10"},
{19049, "WatchType11"},
{19050, "WatchType12"},
{19051, "WatchType13"},
{19052, "WatchType14"},
{19053, "WatchType15"},
{19085, "EyePatch1"},
{19090, "PomPomBlue"},
{19091, "PomPomRed"},
{19092, "PomPomGreen"},
{19093, "HardHat2"},
{19095, "CowboyHat1"},
{19096, "CowboyHat3"},
{19097, "CowboyHat4"},
{19098, "CowboyHat5"},
{19099, "PoliceCap2"},
{19100, "PoliceCap3"},
{19113, "SillyHelmet1"},
{19114, "SillyHelmet2"},
{19115, "SillyHelmet3"},
{19116, "PlainHelmet1"},
{19117, "PlainHelmet2"},
{19118, "PlainHelmet3"},
{19119, "PlainHelmet4"},
{19120, "PlainHelmet5"},
{19138, "PoliceGlasses1"},
{19139, "PoliceGlasses2"},
{19140, "PoliceGlasses3"},
{19160, "HardHat3"},
{19161, "PoliceHat1"},
{19162, "PoliceHat2"},
{19163, "GimpMask1"},
{19317, "bassguitar01"},
{19318, "flyingv01"},
{19319, "warlock01"},
{19330, "fire_hat01"},
{19331, "fire_hat02"},
{19346, "hotdog01"},
{19347, "badge01"},
{19348, "cane01"},
{19349, "monocle01"},
{19350, "moustache01"},
{19351, "moustache02"},
{19352, "tophat01"},
{19487, "tophat02"},
{19488, "HatBowler6"},
{19513, "whitephone"},
{19578, "Banana"},
{19418, "HandCuff"}
};

new AttachmentBones[][24] = {
{"Spine"},
{"Head"},
{"Left upper arm"},
{"Right upper arm"},
{"Left hand"},
{"Right hand"},
{"Left thigh"},
{"Right thigh"},
{"Left foot"},
{"Right foot"},
{"Right calf"},
{"Left calf"},
{"Left forearm"},
{"Right forearm"},
{"Left clavicle"},
{"Right clavicle"},
{"Neck"},
{"Jaw"}
};

new ServerRegisters[][][] =
{
	{
	    "{FF0000}Zombie Apocalypse - Registration (%d/4)", // 0
	    "{D7D7D7}The system could not find your account.\nCreate a new one:\n\n\tMinimum length: 6 characters, do not make easy passwords.\n\tYou can use the Cyrillic alphabet.\n\tUse @#$!~*&-+^% etc characters to make it harder.\n\n", // 1
     	"If you {FF0000}lose your password{D7D7D7}, it will not be restored, it will only be possible\nto change it, since The server uses {FF0000}encryption methods for storing data{D7D7D7}.", // 2
     	"\n{FF0000}I hacked you, try harder.\n", // 3
		"{D7D7D7}Enter a valid Email address, it {FF0000}will be used to restore{D7D7D7} access to your account.\n\nSupported: .com .ru\n\n{FFF000}If you want to restore access to your account - enter the registered email.", // 4
        "{D7D7D7}Enter the secret word, it is necessary to {FF0000}restore the email address or password{D7D7D7}.\n\n\n{FF0000}Attention:\n{D7D7D7}Write this word down somewhere, as it {FF0000}cannot be restored or changed{D7D7D7}.", // 5
        "{FF0000}Zombie Apocalypse - Login", // 6
        "\n{D7D7D7}Welcome Back!\n\n{D7D7D7}Your account is already registered.\nEnter your password, you have %d attempts and the time limit is 1 minute.", // 7
       	"\n{D7D7D7}Welcome Back!\n\n{D7D7D7}Your account is already registered.\nEnter your password, you have %d attempts before you will be kicked", // 8
        "Repeat", // 9
		"Login", // 10
		"{D7D7D7}Promo code of the player who invited you to the server?", // 11
		"Skip", // 12
		"{D7D7D7}There is no such code. Try again" // 13
	},
	{
	    "{FF0000}Зомби Апокалипсис - Регистрация (%d/4)",
	    "\n{D7D7D7}Система не смогла найти ваш аккаунт.\nСоздайте новый:\n\n\tМинимальная длина: 6 символов, не делайте простых паролей.\n\tВы можете использовать кириллицу.\n\tИспользуйте символы @#$!~*&-+^% и т.п, чтобы сделать его сложнее.\n\n",
     	"Если вы {FF0000}потеряете свой пароль{D7D7D7}, он не будет восстановлен, его можно будет только\nизменить, поскольку сервер использует методы шифрования {FF0000}для хранения данных{D7D7D7}.",
     	"\n{FF0000}Я взломаю тебя, попробуй что-нибудь сложнее.\n\n",
		"\n{D7D7D7}Введите действительный адрес электронной почты, он {FF0000}будет использоваться для восстановления доступа к вашей учетной записи{D7D7D7}.\n\nДоступны: .com .ru\n\n{FFF000}Если вы хотите восстановить доступ к своей учетной записи - введите зарегистрированный адрес электронной почты.",
        "{D7D7D7}Введите секретное слово, оно необходимо, чтобы {FF0000}восстановить адрес электронной почты или пароль{D7D7D7}.\n\n{FF0000}Внимание:\n{D7D7D7}Запишите это слово где-нибудь, так как его {FF0000}нельзя восстановить или изменить{D7D7D7}.\n",
        "\n{D7D7D7}Добро пожаловать!\n\n{D7D7D7}Ваша учетная запись уже зарегистрирована.\nВведите пароль, у вас есть %d попытки, и ограничение по времени составляет 1 минуту.",
        "{FF0000}Зомби Апокалипсис - Войти",
        "\n{D7D7D7}Добро пожаловать!\n\n{D7D7D7}Ваша учетная запись уже зарегистрирована.\nВведите пароль, у вас осталось %d попытка(и)",
        "Повторить",
        "Войти",
        "{D7D7D7}Промокод игрока пригласившего вас на сервер?", // 11
		"Пропустить",
		"{D7D7D7}Такого кода не существует. Попробуйте еще раз"
	},
	{
	    "{FF0000}Zombie Apocalypse - Registro (%d/4)", // 0
	    "{D7D7D7}El sistema no pudo encontrar su cuenta.\nCrea uno nuevo:\n\n\tLongitud mнnima: 6 caracteres, no crea contraseсas fбciles.\n\tPuedes usar el alfabeto cirнlico.\n\tUse los caracteres @#$!~*&-+^%, etc. para hacerlo mбs difнcil.\n\n", // 1
     	"Si tu {FF0000}pierde tu contraseсa{D7D7D7}, no serб restaurado, solo serб posible\ncambiarlo, ya que el servidor usa {FF0000}mйtodos de encriptaciуn para almacenar datos{D7D7D7}.", // 2
     	"\n{FF0000}Te hackeй, intenta mбs.\n", // 3
		"{D7D7D7}Ingrese una direcciуn de correo electrуnico vбlida, se {FF0000}se usarб para restaurar{D7D7D7} acceso a su cuenta.\n\nSoportada: .com .ru\n\n{FFF000}Si desea restaurar el acceso a su cuenta, ingrese el correo electrуnico registrado.", // 4
        "{D7D7D7}Ingrese la palabra secreta, es necesario {FF0000}restaurar la direcciуn de correo electrуnico o contraseсa{D7D7D7}.\n\n\n{FF0000}Atenciуn:\n{D7D7D7}Escribe esta palabra en alguna parte, ya que {FF0000}no puede ser restaurado o cambiado{D7D7D7}.", // 5
        "{FF0000}Zombie Apocalypse - Iniciar sesiуn", // 6
        "\n{D7D7D7}Dar una buena acogida!\n\n{D7D7D7}Tu cuenta ya estб registrada.\nIngrese su contraseсa, usted tiene %d intentos y el lнmite de tiempo es de 1 minuto.", // 7
       	"\n{D7D7D7}Dar una buena acogida!\n\n{D7D7D7}Tu cuenta ya estб registrada.\nIngrese su contraseсa, usted tiene %d intentos antes de ser pateado", // 8
        "Repetir", // 9
		"Sesion", // 10
		"{D7D7D7}?Codigo promocional del jugador que te invito al servidor?", // 11
		"Omitir",
		"{D7D7D7}No hay tal cуdigo. Intenta nuevamente"
	}
};

new serverLang[][][] =
{
	{
		"{C0C0C0}*** %s (ID: %d) has just joined the server.", // 0
  		"{FFFFFF}SERVER: Unknown command, use /cmds to see all server commands.", // 1
  		"{FFFFFF}Languages", // 2
  		"English\nRussian\nSpanish", // 3
  		"Ok", // 4
  		"Cancel", // 5
  		"{FFFFFF}>> Language set", // 6
  		"Classes", // 7
  		"Humans' Classes\nZombies' Classes", // 8
  		"Lost connection", // 9
  		"Leaving", // 10
        "Kicked", // 11
	 	"{C0C0C0}*** %s has left the server. [%s]", //12
	 	"{FFF000}>> {00E61b}%s {FFF000}has made to the evacuation point!", //13
	 	"{FF0000}>> You must have %d exp to use this class!", // 14
	 	"{FF0000}>> The player isn't connected", // 15
	 	"{FF0000}>> The player is already on the list", // 16
	 	"{FFF000}>> Player %s can no longer write to you, use /unignore to unlock", // 17
	 	"{FFF000}>> You cannot send a message to this player", //18
	 	"{FFF000}>> [Message from %s(%d)]: %s", // 19
	 	"{FFF000}>> [Message to %s(%d)]: %s", //20
 	 	"{FFF000}>> Personal Messages are open, but the list of ignored players isn't cleared", // 21
 	    "{FFF000}>> Personal Messages are blocked for now", // 22
        "{FFF000}>> You have changed your class in-time and been respawn instantly", // 23
        "{FFF000}>> Class Set, will change next round!", // 24
        "{FFF000}>> You have been spawned as a(n) %s use /class to change this", // 25
        "{E8ACBB}>> [PAGER]: %s was infected go and cure him by using /cure (playerid), if possible", // 26
        "{009900}>> %s has been infected by %s!", //27
        "{33AA33}>> %s has achieved %d killstreak!{FFFFFF} (+%d EXP)", // 28
        "{66ffff}<A-CHAT> %s(%d): %s", // 29
        "{6A8EE2}>> %s appointed a new trial moderator %s", // 30
		"{6A8EE2}>> %s has given admin status (%s) to %s", // 31
        "{6A8EE2}>> %s dismissed %s %s for the reason: %s", // 32
        "{E48800}|: Entering The Map #%d (%s) %s", // 33
        "{FFF000}Creating objects...", // 34
        "{FFF000}>> You have been in AFK for too long and system automatically changed you team to zombie", // 35
        "{FF0000}>> 1 minute remaining... Next map is %s. if you want to change your class use /class!", // 36
        "{FF0000}>> An evacuation has arrived for humans!", // 37
        "{FFFFFF}Humans get to the checkpoint within a minute!", // 38
        "{FFF000}ALL SURVIVORS EVACUATED!", // 39
        "{FFFFFF}>> [First Blood] %s has drawn {FF0000}first blood{FFFFFF} and gains additional 10exp!", // 40
        "{FF0000}>> %s killed the last survivor and got an additional 10exp!", // 41
        "{59E4B5}>>> Kill the last human and receive extra exp!", // 42
        "{33CCFF}>> %s has attempted to join the server whilst serving a ban.", // 43
        "{33CCFF}>> %s has attempted to join the server whilst serving a temp ban.", // 44
        "{FFF000}>> Login in", // 45
        "{FF0000}>> %s has been kicked for 3 failed login attempts!", // 46
        "{6A8EE2}>> %s has been unbanned by %s", // 47
        "{FFFFFF}SERVER: This account does not exist in the Banlist, double-check the data.", // 48
        "{8C7139}>> %s has been banned by %s for %d hours [Reason: %s]", // 49
        "{6A8EE2}>> %s has been banned by %s [Reason: %s]", // 50
        "{009900}>> Wrong banned? Appeal at "FORUM" in Ban Appeal section", // 51
        "{FFF000}>> Create a screenshot of your ban by pressing F8 | (Documents/GTA San Andreas User Files/SAMP/screens)", // 52
        "{FF0000}Zombie Apocalypse - Recovery (%d/2)", // 53
        "{FF0000}\t\t\t\n{D7D7D7}This account belongs to player %s\n\n{D7D7D7}To restore access, enter the Secret Word:", // 54
        "Next", // 55
        "Back", // 56
        "{FFF000}\nData entered correctly, enter your new password.\n\nWrite down your password to always have access to your account.", // 57
        "{FFFFFF}Beginning new a round...", // 58
        "{009900}>> {FF500A}%s{009900} earned %d exp for killing %s on %d kills killstreak!", // 59
        "{A5CED9}>> %s has achieved a new personal highest killstreak (%d kills in a row - old: %d kills)", // 60
        "{B2F558}>> %s has been cured by medic %s", // 61
        "{B2F558}>> %s has been cured by medic %s (shot)", // 62
        "{009900}>> %s has been infected by %s{FFFFFF} (by air)", // 63
        "EXP", // 64
        "Settings", // 65
        "Block PMs\t\t[%s]\nDing\t\t[%s]\nAuto-Login\t\t[%s]", // 66
        "\nUnhiden\t \t \t", // 67
        "{E68687}>> %s gave you some ammo", // 68
        "{FF0000}Zombies win!", // 69
        "{009900}>> %s has been frighted by %s!", // 70
        "{009900}>> %s has swapped %s health!", // 71
        "{009900}>> %s the joker has stolen %d exp from %s!", // 72
        "{009900}>> %s the remover has remove %s armour!", // 73
        "{009900}>> %s has been infected by %s!{FFFFFF} (picking up*)", // 74
        "{B2F558}>> %s paid to %s %d EXP. Total sent with taxes: %d", // 75
        "{FFF000}>> Votekick has been aborted.", // 76
        "{FFF000}>> Votekick has already begun.", // 77
        "{FFF000}>> {A5CED9}%s started a votekick on %s with reason: {FFFFFF}%s", // 78
        "{FFF000}>> Vote with {00FF00}/yes{FFF000} or {FF0000}/no", // 79
        "{FFF000}>> %s voted {FF0000}against{FFF000} a kick (%d/%d)", // 80
        "{FFF000}>> %s voted {00FF00}for{FFF000} a kick (%d/%d)", // 81
        "{FFF000}>> The player was kicked.", // 82
        "{FFF000}>> You have already voted.", // 83
        "{faf06d}>> %s has been burnt by wizard zombie %s!", // 84
        "{009900}>> %s has been found by seeker %s!", // 85
        "{009900}>> %s the stealer has steal %s's ammo!", // 86
        "{009900}>> %s the boomer has blown up and infected{FFFFFF} %d people!", // 87
        "{009900}>> %s the boomer has blown up and infected{FFFFFF} WHOPPING{FF0000} %d people!", // 88
        "{009900}>> %s the demon has blown up and infected{FFFFFF} %d people!", // 89
        "{009900}>> %s the demon has blown up and infected{FFFFFF} WHOPPING{FF0000} %d people!", // 90
		"{009900}>> %s the kamikaze has blown up and infected{FFFFFF} %d people!", // 91
        "{009900}>> %s the kamikaze has blown up and infected{FFFFFF} WHOPPING{FF0000} %d people!", // 92
        "{3366ff}>> %s the freezer has frozen up{FFFFFF} %d people!", // 93
        "{3366ff}>> %s the freezer has frozen up{FFFFFF} WHOPPING{FF0000} %d people!", // 94
        "{B2F558}>> %s the senior medic has cured %d people", // 95
        "{ffcc99}>> %s the demolisher destroyed some boxes", // 96
        "{009900}>> %s has been infected by slow zombie %s!", // 97
        "{009900}>> %s the leg breaker broke %s’s legs!", // 98
        "{009900}>> {FF0000}%s{009900} has been infected by blindness zombie %s!", // 99
        "{33CCFF}>> %s has been banned by Anti-Cheat [Reason: %s]", // 100
        "{33CCFF}>> %s has been kicked [Reason: Ping too high]", // 101
        "{33CCFF}>> SYSTEM: Fix your ping or you will be kicked", // 102
        "{33CCFF}>> SYSTEM: %s possible speed hacker detected, use /spec %d", // 103
        "{33CCFF}>> You're hidden", // 104
        "{33CCFF}>> You're unhidden", // 105
        "{33CCFF}>> %s has been kicked by %s [Reason: %s]", // 106
        "{FFF000}>> Chat has been cleared by the administrator", // 107
        "{6A8EE2}>> %s has slapped %s [%.2f]", // 108
        "{6A8EE2}>> %s has been exploded by %s [%.2f]", // 109
        "{FFA500}>> Announcement{FFFFFF} %s", // 110
        "{33CCFF}>> %s has been muted by %s for %d minutes [Reason: %s]", // 111
        "{FF0000}>> You're muted", // 112
        "{FF0000}>> You're unmuted", // 113
        "{33CCFF}>> %s has been unmuted by %s", // 114
        "{33CCFF}>> Player isn't muted", // 115
        "{6A8EE2}>> Admin %s has started to spectating for %s(%d)", // 116
        "{6A8EE2}>> Admin %s has stopped spectating for %s(%d)", // 117
        "{6A8EE2}>> Admin %s is on {FFFFFF}ADMIN-DUTY{6A8EE2} now", // 118
        "{6A8EE2}>> Admin %s off {FFFFFF}ADMIN-DUTY{6A8EE2}", // 119
        "{F0E68C}>> You've unlocked %s class!", // 120
        "{E68687}>> %s has created a new gang with the name %s {FFFFFF}(ID: %d)!", // 121
        "{FFF000}>> You are already in the gang", // 122
        "{FFF000}>> The leader cannot leave the gang", // 123
        "{FFF000}>> You left the gang, tell them bye!", // 124
        "{C659B6}>> Use /gang accept %d to accept", // 125
        "{FFF000}>> Your request has been sent", // 126
        "{FFF000}>> The player did not send a request", // 127
        "{FFF000}>> The player is already in the gang", // 128
        "{C659B6}>> %s was accepted into the gang by the player %s", // 129
        "{FFF000}>> Sorry, but all the places were taken by other players", // 130
        "{C659B6}>> There isn’t so much experience in the gang", // 131
        "{C659B6}>> %s has paid %s %d EXP from gang exp pot. With taxes %d", // 132
        "{C659B6}>> %s has been promoted by %s to rank %d", // 133
        "{C659B6}>> The player is not in your gang", // 134
        "{C659B6}>> Not enough rights", // 135
        "{C659B6}>> %s has been demoted by %s to rank %d", // 136
        "{C659B6}>> %s has been kicked from the gang by %s", // 137
        "{C659B6}>> %s has renamed rank %s to %s", // 138
        "{C659B6}>> %s has deposited %d EXP to gang exp pot. With taxes %d", // 139
        "{C659B6}>> %s has set tag of gang to %s", // 140
        "{C659B6}>> %s has set full name of gang to %s", // 141
        "{6A8EE2}>> %s has banned IP %s", // 142
        "{6A8EE2}>> %s has unbanned IP %s", // 143
        "{6A8EE2}[REPORT] %s(%d) has reported %s(%d) [Reason: %s] (Total of %d reports)", // 144
        "{33CCFF}>> %s has been warned by %s (%d/3)[Reason: %s]", // 145
        "{33CCFF}>> %s has been kicked [Reason: Received 3 warnings]", // 146
        "{33CCFF}>> Your report has been sent", // 147
        "{8C7139}>> %s has been banned by %s [Reason: %s] (offilne)", // 148
        "{8C7139}>> %s has been banned by %s for %d hours [Reason: %s] (offline)", // 149
        "{8C7139}>> %s fired the administrator %s (offline)", // 150
        "{FF0000}>> You need VIP level of %d to use this class!", // 151
        "{C0C0C0}*** %s (ID: %d) has just joined the server. [IP %s] [Location: %s]", // 152
        "{FFF000}>> You disabled kickback", // 153
        "{FFF000}>> You enabled kickback", // 154
        "{FFF000}>> That name is already exists", // 155
        "{33CCFF}[ADMIN] %s is now known as %s", // 156
        "{FFF000}>> You have already changed your name, wait 24 hours to change it again", // 157
        "{33CCFF}>> %s sets the music, use /off to turn it off", // 158
        "{FFF000}>> You've got %s!", // 159
        "{33CCFF}>> You've saved your stats!", // 160
        "{FFFFFF}SERVER: This account does not exist, double-check the data.", // 161
        "{FFFFFF}SERVER: Not enough permissions.", // 162
        "{6A8EE2}>> %s has given admin status (%s) to %s (offline)", // 163
        "{33CCFF}>> SYSTEM: You are well done! Thank you for your help in catching cheaters. Hold your {FFFFFF}10 EXP!", // 164
        "{FF0000}>>> %s{FFFFFF} was chosen to be the {FF0000}Zombie Boss{FFFFFF}. Kill him and get additional{FFD700} 20 EXP!", // 165
        "{FFFFFF}>> You are {FF0000}BOSS zombie. {A5CED9}You have increased health, go and kill all humans", // 166
        "{009900}>> %s has killed the Zombie Boss %s and get 20 EXP!", // 167
        "{FFF000}>> Due with the new clan policy, you need to create a request on the forum: %s", // 168
        "{6A8EE2}>> Admin %s disbanded the gang #%d", // 169
        "{ccffff}>> %s has evacuated %d times in a row!{FFFFFF} (+%d EXP)", // 170
		"{62E300}>> %s has unlocked a New Achievement named{FFFFFF} (%s) (+%d EXP) (/achievements)", // 171
		"{C659B6}| RANDOM WRITING FOR %d EXP:{FFFFFF} %s", // 172
		"{C659B6}| RANDOM QUESTION FOR %d EXP:{FFFFFF} %s", // 173
		"{C659B6}>> %s was the first one answer the question (Answer : %s) and earns %d EXP!", // 174
		"{C659B6}| RANDOM QUESTION FOR %d EXP: What's the ID of{FFFFFF} %s?", // 175
		"{C659B6}RANDOM QUESTION: No one answered!", // 176
		"{E68687}>> Lottery: Number will be drawn in one minute. Use /lottery to get your own number", // 177
		"Hardened body - Less damage from chainsaw\nSurvivability - +50 HP\nIron Skin - +10 percent of armour\nSponsor - M4 for all classes\nMeteorite gun - Shoots by meteorites\nSpikes - Pushes zombies back", // 178
		"{B2F558}>> %s has been cursed by witch zombie %s!", // 179
		"{009900}>> %s has been accelerated by an accelerating zombie %s!", //180
		"{33CCFF}>> %s has been jailed by %s for %d minute(s) [Reason: %s]", // 181
		"{009900}>> %s has been infected by spitter zombie %s!", // 182
		"{009900}>> %s has been stung by bee zombie %s!", // 183
		"{FFFFFF}>> You are {ffff80}BOSS human. {A5CED9}You have M4, Deagle and Armour", // 184
		"{FF0000}>>> %s{FFFFFF} was chosen to be the {ffff80}Human Hero{FFFFFF}. Kill him and get additional{FFD700} 20 EXP!", // 185
		"{009900}>> %s has killed the Human Hero %s and get 20 EXP!", // 186
		"{009900}>> %s the advanced seeker zombie has teleported to somewhere!", // 187
		"{FF0000}OOPS!", // 188
		"{FFFFFF}You are not registered in the new payment system\nThis system is necessary to prevent accidental pays of EXP from your account in case of hacking\n{FFF000}To register, enter the secret word (if you forgot it: enter a new one and do not forget to save)\n{FFFFFF}* All necessary information about you will be collected by the server", // 189
        "{A5CED9}>> Lottery: Number was drawn! Nobody took part!{C659B6} Jackpot: %d", // 190
		"{A5CED9}>> Lottery: Nobody won!{FF0000} Number: %d Jackpot: %d", // 191
		"{A5CED9}>> Lottery: %s has won the lottery!{C659B6} Number: %d Jackpot: %d", // 192
		"{66ccff}|: Verification is completed, further suspicious payments will be deny (%s)", // 193
		"{FFF000}>> Data inconsistency was found, apply at "FORUM" in Server's Technical Support for clarification, /verify", // 194
		"{33CCFF}>> %s has been set to Zombie Team [Reason: AFK to avoid Death]", // 195
		"{E48800}|: Entering The Map #%d (%s) %s{E48800} (Controlled by %s)", // 196
		"{E68687}>> %s ranked up 1 levels. %s in now a %s", // 197
		"{E68687}>> You ranked up. Your new rank is %s!", // 198
		"{E74C3C}>>> %s has the Cure Kit and Can Cure People!", // 199
		"Rank" // 200
	},
	{
	    "{C0C0C0}*** Игрок %s (ID: %d) присоединился к серверу.",
	    "{FFFFFF}СЕРВЕР: Неизвестная команда, используйте /cmds, чтобы узнать все команды.",
	    "{FFFFFF}Языки",
		"Английский\nРусский\nИспанский",
		"Ок",
		"Выйти",
		"{FFFFFF}>> Язык установлен",
		"Классы",
		"Люди\nЗомби",
		"Потеря соединения",
		"Вышел",
		"Кикнут",
		"{C0C0C0}*** Игрок %s вышел с сервера [%s]",
		"{FFF000}>> Игрок {00e61b}%s {FFF000}эвакуировался!",
		"{FF0000}>> Вам нужно %d опыта, чтобы использовать этот класс!",
		"{FF0000}>> Игрок не найден",
	 	"{FF0000}>> Игрок уже в списке",
	 	"{FFF000}>> Игрок %s больше не может вам написать, используйте /unignore для разблокировки",
	 	"{FFF000}>> Вы не можете написать сообщение этому игроку",
	 	"{FFF000}>> [Сообщение от %s(%d)]: %s",
	 	"{FFF000}>> [Сообщение для %s(%d)]: %s",
	 	"{FFF000}>> Сообщения открыты, но список игнорируемых игроков не очищен",
	 	"{FFF000}>> Доступ к отправке сообщений закрыт",
	 	"{FFF000}>> Вы вовремя изменили свой класс и мгновенно возродились",
        "{FFF000}>> Класс будет установлен в следующем раунде!",
        "{FFF000}>> Вы возродились как %s, используйте /class чтобы изменить это",
        "{E8ACBB}>> [Пейджер]: Игрок %s был заражен идите и вылечите его с помощью /cure (playerid), если это возможно!",
        "{009900}>> Игрок %s был заражен игроком %s!",
        "{33AA33}>> %s достиг серии из %d убийств!{FFFFFF} (+%d ОПЫТА)",
        "{6A8EE2}[АДМИН-ЧАТ] %s(%d): %s",
        "{6A8EE2}>> Администратор %s назначил нового пробного модератора %s",
        "{6A8EE2}>> Администратор %s выдал админ статус (%s) игроку %s",
        "{6A8EE2}>> Администратор %s уволил %s %s по причине: %s",
        "{E48800}|: Создание карты #%d (%s) %s",
        "{FFF000}Создание объектов...",
        "{FFF000}>> Вы пробыли в АФК слишком долго, система автоматически изменила вашу команду на зомби",
        "{FF0000}>> Осталась 1 минута... Следующая карта %s. Если вы хотите изменить свой класс, используйте /class!",
        "{FF0000}>> Эвакуация прибыла для людей!",
        "{FFFFFF}Выжившие доберитесь до чекпоинта в течении минуты!",
        "{FFF000}ВСЕ ВЫЖИВШИЕ ЭВАКУИРОВАЛИСЬ!",
        "{FFFFFF}>> [Первая Кровь]: Игрок %s пустил {FF0000}Первую Кровь{FFFFFF} и получил дополнительные 10 Опыта!",
        "{FFFFFF}>> Игрок %s убил {FF0000}последнего{FFFFFF} выжившего и получил дополнительные 10 Опыта!",
        "{59E4B5}>>> Убейте последнего выжившего и получите дополнительный опыт!",
        "{33CCFF}>> Игрок %s попытался подключится к серверу, но был найден в списке заблокированных игроков",
        "{33CCFF}>> Игрок %s попытался подключится к серверу, но был найден в списке временно заблокированных игроков",
        "{FFF000}>> Вход успешно выполнен!",
        "{FF0000}>> Игрок %s был кикнут за 3 провальные попытки авторизации",
        "{6A8EE2}>> Администратор %s разблокировал аккаунт игрока %s",
        "{FFFFFF}СЕРВЕР: Эта учетная запись не существует в Бан Листе, перепроверьте данные.",
        "{8C7139}>> Игрок %s был заблокирован администратором %s [%d час(ов/а)] [Причина: %s]",
        "{6A8EE2}>> Игрок %s был заблокировал администратором %s [Причина: %s]",
        "{009900}>> Несправедливый бан? Оставьте заявку на "FORUM" в разделе Ban Appeal",
        "{FFF000}>> Создайте скриншот вашего бана нажав F8 (Документы/GTA San Andreas User Files/SAMP/screens)",
        "{FF0000}Зомби Апокалипсис - Восстановление (%d/2)",
        "{FF0000}\n{D7D7D7}Данная учётная запись принадлежит игроку %s\n\n{D7D7D7}Для восстановления доступа введите Секретное Слово:",
        "Далее",
        "Назад",
        "{FFF000}\nДанные введены корректно, введите ваш новый пароль.\n\nЗапишите ваш пароль, чтобы всегда иметь доступ к аккаунту.",
        "{FFFFFF}Начинается новый раунд...",
        "{009900}>>{FF500A}%s{009900} заработал %d опыта за убийство %s на %d серии убийств!",
        "{A5CED9}>> Игрок %s добился нового самого высокого уровня убийств (%d убийств подряд - предыдущие: %d убийств)",
        "{B2F558}>> Игрок %s был вылечен медиком %s",
        "{B2F558}>> Игрок %s был вылечен медиком %s (выстрелом)",
        "{009900}>> Игрок %s был заражен игроком %s{FFFFFF} (от %s)!",
        "ОПЫТА",
        "Настройки",
        "Block PMs\t\t[%s]\nDing\t\t[%s]\nAuto-Login\t\t[%s]",
        "\nUnhiden\t\t[%s]",
        "{E68687}>> %s дал вам немного патронов",
        "{FF0000}Зомби победили!",
        "{009900}>> %s был напуган игроком %s!",
        "{009900}>> %s поменялся здоровьем с %s!",
        "{009900}>> Джокер %s украл %d опыта у %s!",
        "{009900}>> Вор %s украл броню игрока %s!",
        "{009900}>> Игрок %s был заражен игроком %s! {FFFFFF} (зараженное мясо*)",
        "{B2F558}>> Игрок %s передал игроку %s %d ОПЫТА",
        "{FFF000}>> Голосование было отменено.",
        "{FFF000}>> Голосование уже началось.", 
        "{FFF000}>> {A5CED9}%s начал голосование против %s с причиной: {A5CED9}%s",
        "{FFF000}>> Голосуйте {00FF00}/yes{FFF000} или {FF0000}/no",
        "{FFF000}>> Игрок %s проголосовал {FF0000}против{FFF000} (%d/%d)",
        "{FFF000}>> Игрок %s проголосовал {00FF00}за{FFF000} (%d/%d)",
        "{FFF000}>> Игрок был выгнан.",
        "{FFF000}>> Вы уже проголосовали.",
        "{faf06d}>> Игрок %s был поджогнут игроком %s!",
        "{009900}>> Игрок %s был найден игроком %s!",
        "{009900}>> Игрок %s украл патроны у игрока %s!",
        "{009900}>> Игрок %s взорвался и заразил{FFFFFF} %d человек!",
        "{009900}>> Игрок %s взорвался и заразил{FFFFFF} НЕВЕРОЯТНО{FF0000} %d человек!",
        "{009900}>> Игрок %s взорвался и заразил{FFFFFF} %d человек!",
        "{009900}>> Игрок %s взорвался и заразил{FFFFFF} НЕВЕРОЯТНО{FF0000} %d человек!",
		"{009900}>> Игрок %s взорвался и заразил{FFFFFF} %d человек!",
        "{009900}>> Игрок %s взорвался и заразил{FFFFFF} НЕВЕРОЯТНО{FF0000} %d человек!",
        "{009900}>> Игрок %s заморозил{FFFFFF} %d человек!",
        "{009900}>> Игрок %s заморозил{FFFFFF} НЕВЕРОЯТНО{FF0000} %d человек!",
        "{B2F558}>> Сеьор медик %s вылечил %d человек",
        "{ffcc99}>> Разрушитель %s разрушил несколько коробок",
        "{009900}>> Игрок %s был заражен медленным зомби %s",
        "{009900}>> Игрок %s сломал ноги игрока %s!",
        "{009900}>> Игрок {FF0000}%s{009900} был заражен слепотой от игрока %s!",
        "{33CCFF}>> %s был забанен Анти-Читом [Причина: %s]",
        "{33CCFF}>> %s был кикнут [Причина: Высокий пинг]",
        "{33CCFF}>> Система: Уменьшите свой пинг или будете кикнуты",
        "{33CCFF}>> Система: %s возможно, обнаружен читер, проверьте /spectate %d",
        "{33CCFF}>> Статус администратора скрыт",
        "{33CCFF}>> Статус администратора раскрыт",
        "{33CCFF}>> %s был кикнут администратором %s [Причина: %s]",
        "{FFF000}>> Чат был очищен администратором",
        "{6A8EE2}>> %s дал шлепка %s [%.2f]",
        "{6A8EE2}>> %s взорвал %s [%.2f]",
       	"{FFA500}>> Объявление{FFFFFF} %s",
        "{33CCFF}>> %s получил мут от %s на %d минут [Причина: %s]",
        "{FF0000}>> У вас затычка", // 112
        "{FF0000}>> Затычка снята", // 113
        "{33CCFF}>> Затычка у игрока %s была снята администратором %s", // 114
        "{33CCFF}>> У игрока нет затычки",
        "{6A8EE2}>> %s начал слежку за %s(%d)",
        "{6A8EE2}>> %s прекратил слежку за %s(%d)",
        "{6A8EE2}>> %s заступил на дежурство за %s",
        "{6A8EE2}>> %s вышел из дежурства",
        "{F0E68C}>> Вы открыли новый класс '%s'!",
        "{E68687}>> %s создал клан с названием %s {FFFFFF}(ID: %d)!",
        "{FFF000}>> Вы уже находитесь в клане",
        "{FFF000}>> Лидер не может покинуть клан",
        "{FFF000}>> Вы покинули банду, скажите им пока!",
        "{C659B6}>> %s хочет присоединится в ваш клан, используйте /gang accept %d",
        "{FFF000}>> Ваша запрос был отправлен",
        "{FFF000}>> Игрок не отправлял заявку",
        "{FFF000}>> Игрок уже в банде",
        "{C659B6}>> %s был принят в клан игроком %s",
        "{FFF000}>> Сожалеем, но все места были заняты другими игроками",
        "{C659B6}>> В казне клана нехватает опыта",
        "{C659B6}>> Игрок %s выдал игроку %s %d ОПЫТА из казны клана",
        "{C659B6}>> Игрок %s повысил игрока %s до ранга %d!",
        "{C659B6}>> Игрок не в вашей банде",
        "{C659B6}>> Не достаточно прав",
        "{C659B6}>> Игрок %s понизил игрока %s до ранга %d!",
        "{C659B6}>> %s покинул клан",
        "{C659B6}>> Игрок %s переименовал ранг %s на %s",
        "{C659B6}>> Игрок %s положил %d ОПЫТА в казну клана",
        "{C659B6}>> %s установил тег клана на %s",
        "{C659B6}>> %s установил полное имя клана %s",
        "{6A8EE2}>> Администратор %s заблокировал IP %s",
        "{6A8EE2}>> Администратор %s разблокировал IP %s",
        "{6A8EE2}[ЖАЛОБА] %s(%d) на игрока %s(%d) [Причина: %s] (Уже %d жалоб)",
        "{33CCFF}>> %s получил предупреждение от %s (%d/3)[Причина: %s]",
        "{33CCFF}>> %s был кикнут [Причина: Получено максимальное количество предупреждений]",
        "{33CCFF}>> Ваша жалоба отправлена",
        "{8C7139}>> Администратор %s заблокировал %s (оффлайн)",
        "{8C7139}>> Администратор %s заблокировал %s [%d час(ов/а)] (оффлайн)",
        "{8C7139}>> %s уволил администратора %s (оффлайн)",
        "{FF0000}>> Вам нужен VIP %d уровня, чтобы использовать этот класс!",
        "{C0C0C0}*** Игрок %s (ID: %d) присоединился к серверу. [IP %s] [Страна: %s]",
        "{FFF000}>> Вы выключили отталкивание",
        "{FFF000}>> Вы включили отталкивание",
        "{FFF000}>> Такое имя уже существует", // 155
        "{33CCFF}[АДМИН] Игрок %s теперь известен как %s", // 156
        "{FFF000}>> Вы уже меняли ник, подождите 24 часа, чтобы сменить его снова",
        "{33CCFF}>> %s поставил музыку, используйте /off чтобы выключить её",
        "{FFF000}>> Вы купили %s!",
        "{33CCFF}>> Вы сохранили свою статистику!",
        "{FFFFFF}СЕРВЕР: Эта учетная запись не существует, перепроверьте данные.",
        "{FFFFFF}СЕРВЕР: Недостаточно прав.",
        "{6A8EE2}>> Администратор %s выдал админ статус (%s) игроку %s (оффлайн)",
        "{33CCFF}>> СИСТЕМА: Вы молодец! Спасибо за помощь в отлове читера держите вашу награду в размере{FFFFFF} 10 ОПЫТА!", // 164
        "{FF0000}>>> %s{FFFFFF} был выбран, как Зомби Босс. Убейте его и получите{FFD700} 20 ОПЫТА!",
        "{FFFFFF}>> Вы {FFA500}БОСС{3366ff} зомби. {A5CED9}У вас увеличен запас здоровья и урон, идите и убейте всех людей!",
        "{009900}>> Игрок %s убил зомби босса %s и получил 20 ОПЫТА!",
        "{FFF000}>> В связи с новой политикой кланов, вам необходимо создать заявку на форуме: %s",
        "{6A8EE2}>> Администратор %s расформировал клан #%d",
        "{ccffff}>> Игрок %s эвакуировался %d раз подряд!{FFFFFF} (+%d ОПЫТА)",
        "{62E300}>> Игрок %s открыл новое достижение{FFFFFF} (%s) (+%d ОПЫТА) (/achievements)",
        "{C659B6}| Напишите этот текст первым и получите %d ОПЫТА:{FFFFFF} %s", // 172
        "{C659B6}| Случайный вопрос на %d ОПЫТА:{FFFFFF} %s",
        "{C659B6}>> Игрок %s был первым, кто ответил на вопрос (Ответ: %s) и заработал %d ОПЫТА!", // 174
        "{C659B6}| Случайный вопрос на %d ОПЫТА: Какой ID у{FFFFFF} %s?",
        "{C659B6}Случайный вопрос: Никто не ответил!",
        "{E68687}>> Лотерея: Номер будет разыгран через одну минуту. Используйте /lottery, чтобы указать свой номер",
        "Hardened body - Less damage from chainsaw\nSurvivability - +50 HP\nIron Skin - +10 percent of armour\nSponsor - M4 for all classes\nMeteorite gun - Shoots by meteorites",
        "{B2F558}>> Игрок %s был проклят ведьмой %s!", // 179
        "{009900}>> Игрок %s ускорен ускоряющим зомби %s!", //180
        "{33CCFF}>> Игрок %s был посажен в тюрьму игроком %s на %d минут(ы) [Причина: %s]", // 181
        "{009900}>> Игрок %s был заражен плюющимся зомби %s!", //182
		"{009900}>> Игрок %s был ужален зомби пчелой %s!", //183
		"{FFFFFF}>> Вы {ffff80}Герой. {A5CED9}У вас есть M4, Deagle и Броня", // 184
		"{FF0000}>>> %s{FFFFFF} был выбран, как {ffff80}Герой{FFFFFF}. Убейте его и получите дополнительные{FFD700} 20 ОПЫТА!", // 185
		"{009900}>> %s убил героя %s и получил 20 ОПЫТА!", // 186
		"{009900}>> %s улучшенный зомби охотник телепортировался куда-то!", // 187
		"{FF0000}УПС!",
		"{FFFFFF}Вы не зарегистрированы в новой платежной системе\nЭта система необходима для предотвращения случайных передач опыта с вашего аккаунта в случае взлома\n{FFF000}Для регистрации введите секретное слово (если вы его забыли: введите новое и не забудьте сохранить)\n{FFFFFF}* Вся необходимая информация о вас будет собрана сервером",
		"{A5CED9}>> Лотерея: номер был нарисован! Никто не принимал участие!{C659B6} Джекпот: %d", // 190
		"{A5CED9}>> Лотерея: никто не выиграл!{FF0000} Номер: %d Джекпот: %d", // 191
		"{A5CED9}>> Лотерея: %s выиграл(а) в лотереи!{C659B6} Номер: %d Джекпот: %d", // 192
		"{66ccff}|: Верификация завершена, дальнейшие подозрительные платежи будут отклонятся (%s)",
		"{FFF000}>> Обнаружена несогласованность данных, обратитесь за разъяснениями на "FORUM" в Службу Технической Поддержки Сервера (/verify)",
		"{33CCFF}>> Команда игрока %s была установлена на 'Зомби' [Причина: АФК во избежание смерти]", // 195
		"{E48800}|: Создание карты #%d (%s) %s{E48800} (Под контролем %s)",
		"{E68687}>> Игрок %s повысил ранг. Теперь ранг игрока %s это %s", // 197
		"{E68687}>> Вы повысили свой ранг. Новый ранг %s!", // 198
		"{E74C3C}>>> %s имеет набор для лечения и может вылечить людей!",
		"Ранг"
	},
	{
	    "{C0C0C0}*** %s (ID: %d) se ha unido al servidor.", // 0
		"{FFFFFF}SERVER: Comando desconocido, use /cmds para descubrir todos los comandos en el servidor.", // 1
		"{FFFFFF}Lenguajes", // 2
		"English\nRussian\nSpanish", // 3
		"Ok", // 4
		"Cancelar", // 5
		"{FFFFFF}>> Lenguaje establecido", // 6
		"Clases", // 7
		"Humanos' Clases\nZombis' Clases", // 8
		"Conexion Perdida", // 9
		"Leaving", // 10
		"Expulsado", // 11
		"{C0C0C0}*** %s ha dejado el servidor. [%s]", //12
		"{FFF000}>> {00E61b}%s {FFF000}ha logrado el punto de evacuaci?n!", //13
		"{FF0000}>> Necesita %d de exp para usar esta clase!", // 14
		"{FF0000}>> El jugador no esta conectado", // 15
		"{FF0000}>> El jugador ya esta en la lista", // 16
		"{FFF000}>> El jugador %s no puede escribirte mas, usa /unignore para desbloquearlo", // 17
		"{FFF000}>> No puede enviar mensajes a este Jugador", //18
		"{FFF000}>> [Mensaje de %s(%d)]: %s", // 19
		"{FFF000}>> [Mensaje para %s(%d)]: %s", //20
		"{FFF000}>> Mensajes personales estan abierto, pero la lista de jugadores ignoradores no esta limpia", // 21
		"{FFF000}>> Mensajes personales estan bloqueados por ahora", // 22
		"{FFF000}>> Has cambiado tu clase a tiempo y ha aparecido al instante", // 23
		"{FFF000}>> Clase establecida, Se cambiara en la proxima ronda!", // 24
		"{FFF000}>> Usted ha aparecido como un %s usa /class para cambiar esta", // 25
		"{E8ACBB}>> [PAGER]: %s Ha sido infectado ve y c?ralo usando /cure (playerid), si es posible", // 26
		"{009900}>> %s Ha sido infectado por %s!", //27
		"{499a63}>> %s Ha logrado %d killstreak!{FFFFFF} (+%d EXP)", // 28
		"{66ffff}<A-CHAT> %s(%d): %s", // 29
		"{6A8EE2}>> %s appointed a new trial moderator %s", // 30
		"{6A8EE2}>> %s has given admin status (%s) to %s", // 31
		"{6A8EE2}>> %s dismissed %s %s for the reason: %s", // 32
		"{E48800}|: Cargando el pr?ximo mapa #%d (%s)", // 33
		"{FFF000}Creando objetos...", // 34
		"{FFF000}>> Has estado afk por mucho tiempo y el sistema te ha cambiado automaticamente a un zombi", // 35
		"{FF0000}>> 1 minuto restante... El proximo mapa es %s. Si quieres cambiar tu clase usa /class!", // 36
		"{FF0000}>> Una evacuaci?n ha llegado para los humanos.!", // 37
		"{FFFFFF}>> Humanos llegen al puesto de control en un minuto!", // 38
		"{FFF000}TODOS LOS SOBREVIVIENTES HAN EVACUADO!", // 39
		"{FFFFFF}>> [First Blood] %s ha realizado la{FF0000}primera muerte{FFFFFF} y gana 10xp adicionales!", // 40
		"{FF0000}>> %s Mato al ultimo sobreviviente y obtuvo 10xp adicional!", // 41
		"{59E4B5}>>> Mata al ultimo humano y recibe xp extra!", // 42
		"{33CCFF}>> %s Ha intentado entrar al servidor mientras cumple una prohibici?n.", // 43
		"{33CCFF}>> %s Ha intentado entrar al servidor mientras cumple una prohibici?n temporal.", // 44
		"{FFF000}>> Has iniciado sesi?n", // 45
		"{FF0000}>> %s ha sido expulsado por 3 intentos fallidos de inicio de sesi?n!", // 46
		"{6A8EE2}>> %s ha sido desbaneado por %s", // 47
		"{FFFFFF}SERVER: Esta cuenta no existe en la lista de prohibici?nes, verifique dos veces los datos.", // 48
		"{8C7139}>> %s ha sido baneado por %s por %d horas [Raz?n: %s]", // 49
		"{6A8EE2}>> %s ha sido baneado por %s [Raz?n: %s]", // 50
		"{009900}>> Baneado por equivocaci?n? Apelar en el "FORUM" en Ban Appeal secci?n", // 51
		"{FFF000}>> Toma una captura de tu prohibici?n presionando F8 | (Documents/GTA San Andreas User Files/SAMP/screens)", // 52
		"{FF0000}Zombie Apocalypse - Recovery (%d/2)", // 53
		"{FF0000}\t\t\t\n{D7D7D7}Esta cuenta pertenece al jugador. %s\n\n{D7D7D7}Para restaurar el acceso, ingrese la Palabra secreta:", // 54
		"Siguiente", // 55
		"Back", // 56
		"{FFF000}\nDatos ingresados ??correctamente, ingrese su nueva contrase?a.\n\nEscriba su contrase?a para tener siempre acceso a su cuenta.", // 57
		"{FFFFFF}Comenzando una nueva ronda...", // 58
		"{009900}>> {FF500A}%s{009900} Gano %d exp por matar %s en %d killstreak!", // 59
		"{A5CED9}>> %s ha logrado un nuevo killstreak m?s alto (%d kills in a row - old: %d kills)", // 60
		"{B2F558}>> %s ha sido curado por el medico %s", // 61
		"{B2F558}>> %s ha sido curado por el medico %s (Disparo)", // 62
		"{009900}>> %s ha sido infectado por %s{FFFFFF} (by air)", // 63
		"EXP", // 64
		"Ajustes", // 65
		"Bloquear PMs\t\t[%s]\nDing\t\t[%s]\nInicio de sesi?n-Automatico\t\t[%s]", // 66
		"\nUnhiden\t \t \t", // 67
		"{E68687}>> %s Te dio algo de munici?n", // 68
		"{FF0000}Ganaron los Zombis!", // 69
		"{009900}>> %s ha sido asustado por %s!", // 70
		"{009900}>> %s ha intercambiado con %s salud!", // 71
		"{009900}>> %s el joker ha robado %d exp de %s!", // 72
		"{009900}>> %s el remover ha removido %s armadura!", // 73
		"{009900}>> %s ha sido infectado por %s!{FFFFFF} (recogiendo carne infectada*)", // 74
		"{B2F558}>> %s pago a %s %d EXP. Total enviado con impuestos: %d", // 75
		"{FFF000}>> Votekick ha sido abortado.", // 76
		"{FFF000}>> Votekick ya ha comenzado.", // 77
		"{FFF000}>> {A5CED9}%s Comenzo un votekick en %s con la raz?n: {FFFFFF}%s", // 78
		"{FFF000}>> Vota con {00FF00}/yes{FFF000} o {FF0000}/no", // 79
		"{FFF000}>> %s ha votado{FF0000}en contra{FFF000} de una expulsi?n (%d/%d)", // 80
		"{FFF000}>> %s ha votado {00FF00}para{FFF000} una expulsi?n (%d/%d)", // 81
		"{FFF000}>> El jugador fue expulsado.", // 82
		"{FFF000}>> Ya has votado.", // 83
		"{faf06d}>> %s ha sido quemado por el zombie Wizard %s!", // 84
		"{009900}>> %s ha sido encontrado por el Seeker %s!", // 85
		"{009900}>> %s el stealer le ha robado a %s su munici?n!", // 86
		"{009900}>> %s el boomer ha explotado e infect? {FFFFFF} %d personas!", // 87
		"{009900}>> %s el boomer ha explotado e infect?{FFFFFF} LA GRAN CANTIDAD DE{FF0000} %d personas!", // 88
		"{009900}>> %s el demon ha explotado e infect?{FFFFFF} %d personas!", // 89
		"{009900}>> %s el demon ha explotado e infect?{FFFFFF} LA GRAN CANTIDAD DE{FF0000} %d personas!", // 90
		"{009900}>> %s el kamikaze ha explotado e infect?{FFFFFF} %d personas!", // 91
		"{009900}>> %s el kamikaze ha explotado e infect?{FFFFFF} LA GRAN CANTIDAD DE{FF0000} %d personas!", // 92
		"{3366ff}>> %s el freezer ha congelado{FFFFFF} %d personas!", // 93
		"{3366ff}>> %s el freezer ha congelado{FFFFFF} LA GRAND CANTIDAD DE{FF0000} %d personas!", // 94
		"{B2F558}>> %s el senior medic ha curado %d personas", // 95
		"{ffcc99}>> %s el demolisher destruy? algunas cajas", // 96
		"{009900}>> %s ha sido infectado por el slow zombie %s!", // 97
		"{009900}>> %s el leg breaker le ha roto a %s sus piernas!", // 98
		"{009900}>> {FF0000}%s{009900} ha sido infectado por el blindness zombie %s!", // 99
		"{33CCFF}>> %s ha sido baneado por el Anti-Cheat [Raz?n: %s]", // 100
		"{33CCFF}>> %s ha sido expulsado [Raz?n: Muy alta latencia]", // 101
		"{33CCFF}>> SISTEMA: Arregla tu latencia o ser?s expulsado", // 102
		"{33CCFF}>> SISTEMA: %s posible hacker de velocidad detectado, usa /spec %d", // 103
		"{33CCFF}>> Est?s oculto", // 104
		"{33CCFF}>> Est?s descubierto", // 105
		"{33CCFF}>> %s ha sido expulsado por %s [Raz?n: %s]", // 106
		"{FFF000}>> El chat ha sido limpiado por el administrador", // 107
		"{6A8EE2}>> %s ha abofeteado %s [%.2f]", // 108
		"{6A8EE2}>> %s ha sido explotado por %s [%.2f]", // 109
		"{FFA500}>> Anuncio{FFFFFF} %s", // 110
		"{33CCFF}>> %s ha sido muteado por %s por %d minutos [Raz?n: %s]", // 111
		"{FF0000}>> Est?s silenciado", // 112
		"{FF0000}>> Est?s sin silenciar", // 113
		"{33CCFF}>> %s ha sido desmuteado por %s", // 114
		"{33CCFF}>> El Jugador no est? silenciado", // 115
		"{6A8EE2}>> Administrador %s ha comenzado a observar en %s(%d)", // 116
		"{6A8EE2}>> Administrador %s ha parado de observar en %s(%d)", // 117
		"{6A8EE2}>> Administrador %s es?t? en {FFFFFF}SERVICIO-ADMINISTRATIVO{6A8EE2} now", // 118
		"{6A8EE2}>> Administrador %s fuera de {FFFFFF}SERVICIO-ADMINISTRATIVO{6A8EE2}", // 119
		"{F0E68C}>> Has desbloqueado %s clase!", // 120
		"{E68687}>> %s ha creado un nuevo clan con el nombre %s {FFFFFF}(ID: %d)!", // 121
		"{FFF000}>> Ya te encuentras en el clan", // 122
		"{FFF000}>> El lider no puede dejar el clan", // 123
		"{FFF000}>> Dejaste tu clan, diles adi?s!", // 124
		"{C659B6}>> %s quiere entrar en tu clan, usa /gang accept %d", // 125
		"{FFF000}>> Tu solicitud ha sido enviada", // 126
		"{FFF000}>> El jugador no envi? una solicitud", // 127
		"{FFF000}>> El jugador ya est? en el clan", // 128
		"{C659B6}>> %s ha sido aceptado dentro del clan por el jugador %s", // 129
		"{FFF000}>> Lo sentimos, pero todos los lugares fueron ocupados por otros jugadores", // 130
		"{C659B6}>> No hay tanta experiencia en el clan", // 131
		"{C659B6}>> %s ha pagado %s %d EXP de la experiencia almacenada del clan. Con impuestos %d", // 132
		"{C659B6}>> %s ha sido promovido por %s", // 133
		"{C659B6}>> El jugador no est? en tu clan", // 134
		"{C659B6}>> No hay permisos suficientes", // 135
		"{C659B6}>> %s Ha sido degradado por %s", // 136
		"{C659B6}>> %s ha sido expulsado del clan por %s", // 137
		"{C659B6}>> %s ha renombrado el rango %s a %s", // 138
		"{C659B6}>> %s ha depositado %d EXP a la experiencia almacenada del clan. Con impuestos %d", // 139
		"{C659B6}>> %s ha establecido la etiqueta del clan a %s", // 140
		"{C659B6}>> %s ha establecido el nombre completo del clan a %s", // 141
		"{6A8EE2}>> %s ha prohibido la IP %s", // 142
		"{6A8EE2}>> %s ha desbaneado la IP %s", // 143
		"{6A8EE2}[REPORTE] %s(%d) ha reportado a %s(%d) [Raz?n: %s] (Total of %d reports)", // 144
		"{33CCFF}>> %s ha sido advertido por %s (%d/3)[Raz?n: %s]", // 145
		"{33CCFF}>> %s ha sido expulsado [Raz?n: Recibi? 3 advertencias]", // 146
		"{33CCFF}>> Tu reporte ha sido enviado", // 147
		"{8C7139}>> %s ha sido prohibido por %s [Raz?n: %s] (fuera de l?nea)", // 148
		"{8C7139}>> %s ha sido prohibido por %s por %d horas [Raz?n: %s] (fuera de l?nea)", // 149
		"{8C7139}>> %s despidi? al administrador %s (fuera de l?nea)", // 150
		"{FF0000}>> Necesitas un nivel VIP de %d para usar ?sta clase!", // 151
		"{C0C0C0}*** %s (ID: %d) ha ingresado al servidor. [IP %s] [Ubicaci?n: %s]", // 152
		"{FFF000}>> Desactivaste el kickback", // 153
		"{FFF000}>> Activaste el kickback", // 154
		"{FFF000}>> Ese nombre ya existe", // 155
		"{33CCFF}[ADMIN] %s es conocido ahora como %s", // 156
		"{FFF000}>> ya has cambiado tu nombre, espera 24 horas para cambiarlo nuevamente", // 157
		"{33CCFF}>> %s pone la m?sica, usa /off para apagarla", // 158
		"{FFF000}>> Has obtenido %s!", // 159
		"{33CCFF}>> Has guardado tus estad?sticas", // 160
		"{FFFFFF}SERVIDOR: Esta cuenta no existe, Verifique dos veces los datos.", // 161
		"{FFFFFF}SERVIDOR: No hay suficientes permisos.", // 162
		"{6A8EE2}>> %s ha dado posici?n de administrador (%s) a %s (fuera de l?nea)", // 163
		"{33CCFF}>> SISTEMA: Has hecho bien! Gracias por tu ayuda en la captura de tramposos. Toma tus {FFFFFF}10 EXP!", // 164
		"{FF0000}>>> %s{FFFFFF} Ha sido elegido para ser el {FF0000}JEFE Zombie{FFFFFF}. M?talo y obten de adici?n{FFD700} 20 EXP!", // 165
		"{FFFFFF}>> Eres el {FF0000}JEFE Zombie. {A5CED9}Tienes salud incrementanda, ve y mata a todos los humanos", // 166
		"{009900}>> %s ha matado al Jefe Zombie %s y obtiene 20 EXP!", // 167
		"{FFF000}>> Debido a la nueva pol?tica de clan, Necesitas crear una solicitud en el foro: %s", // 168
		"{6A8EE2}>> Administrador %s disolvi? la pandilla #%d", // 169
		"{ccffff}>> %s ha evacuado %d veces seguidas!{FFFFFF} (+%d EXP)", // 170
		"{62E300}>> %s ha desbloqueado un Nuevo Logro llamado {FFFFFF}%s (+%d EXP) (/achievements)", // 171
		"{C659B6}| ESCRITURA ALEATORIA POR %d EXP:{FFFFFF} %s", // 172
		"{C659B6}| PREGUNTA ALEATORIA POR %d EXP:{FFFFFF} %s", // 173
		"{C659B6}>> %s fue el primero en responder la pregunta (Answer : %s) y gana %d EXP!", // 174
		"{C659B6}| PREGUNTA ALEATORIA POR %d EXP: Cu?l es el ID de{FFFFFF} %s?", // 175
		"{C659B6}PREGUNTA ALEATORIA: Nadie respondi?!", // 176
		"{E68687}>> Loter?a: El n?mero ser? revelado en un minuto. Usa /lottery para obtener tu propio n?mero", // 177
		"Hardened body - Menos da?o de la motosierra\nSurvivability - +50 HP\nIron Skin - +10 porcentaje de armadura\nSponsor - M4 para todas las clases\nMeteorite gun - Disparos por meteoritos\nSpikes - Empuja a los zombies hacia atr?s", // 178
		"{B2F558}>> %s ha sido maldecido por la witch zombie %s!", // 179
		"{009900}>> %s ha sido acelerado por un zombie acelerador %s!", //180
		"{33CCFF}>> %s ha sido enjaulado por %s por %d minuto(s) [Raz?n: %s]", // 181
		"{009900}>> %s ha sido infectado por el spitter zombie %s!", // 182
		"{009900}>> %s ha sido picado por el bee zombie %s!", // 183
		"{FFFFFF}>> T? eres el {ffff80}JEFE HUMANO. {A5CED9}T? tienes M4, Deagle y blindaje", // 184
		"{FF0000}>>> %s{FFFFFF} ha sido elegido para ser el {ffff80}H?roe Humano{FFFFFF}. M?talo y obt?n de adici?n{FFD700} 20 EXP!", // 185
		"{009900}>> %s ha matado al H?roe Humano %s y obtiene 20 EXP!", // 186
		"{009900}>> %s el zombie advanced seeker se ha teletransportado a alg?n lugar!", // 187
		"{FF0000}Uy!", // 188
		"{FFFFFF}No est?s registrado en el nuevo sistema de pago \nEste sistema es necesario para prevenir pagos accidentales de EXP desde su cuenta en caso de hackeo\n{FFF000}Para registrarte, ingresa la palabra secreta (si la olvidaste: ingresa una nueva y no te olvides de guardarla)\n{FFFFFF}* Toda la informaci?n necesaria a cerca de usted ser? recopilada por el servidor.", // 189
		"{A5CED9}>> Loter?a: El n?mero ha sido revelado! Nadie particip?!{C659B6} Premio gordo: %d", // 190
		"{A5CED9}>> Loter?a: Nadie gan?!{FF0000} N?mero: %d Premio gordo: %d", // 191
		"{A5CED9}>> Loter?a: %s ha ganado la loter?a!{C659B6} N?mero: %d Premio gordo: %d", // 192
		"{66ccff}|: La verificaci?n est? completa, nuevos pagos sospechosos ser?n denegados (%s)", // 193
		"{FFF000}>> Se encontr? inconsistencia de datos, solicita en el "FORUM" en el Soporte T?cnico del servidor para aclaraciones (/verify)", // 194
        "{33CCFF}>> %s se ha configurado para Zombie Team [Reason: AFK para evitar la muerte]", // 195
        "{E48800}|: Cargando el pr?ximo mapa #%d (%s){E48800} (Bajo control %s)",
       	"{E68687}>> %s ranked up 1 levels. %s in now a %s", // 197
		"{E68687}>> You ranked up. Your new rank is %s!", // 198
		"{E74C3C}>>> %s tiene el Kit de Curado y puede curar a los Humanos!",
		"Rango"
	}
};

enum
{
	TROPHY_VITALITY = 0,
	TROPHY_ACCURACY,
	TROPHY_EVASION,
	TROPHY_WARRIOR,
	TROPHY_TITAN,
	TROPHY_MIRROR
};

enum aname
{
	BeeCooldown,
	SpiderJump,
	InfectionNormal,
	InfectionBlidness,
    InfectionSlow,
	LegBreaks,
	InfectionMutated,
	InfectionBlind,
	Float:Fuel,
	QueenJumps[2],
	ZombieJumps[2],
	HighJumpZombie,
	StomperPushing,
	AdvancedMutated,
	CanGiveAmmo,
	CanGiveArmour[MAX_PLAYERS],
	FlyCooldown,
	SlenderBlind,
	SwapperAbility,
	CockroachUseMode,
	SpitterWeapon,
	RemoverRemove,
	RogueSkinChangeZ,
	RogueSkinChangeH,
	EarthPushing,
	WitchAttack,
	GunJammer,
	CopierCooldown,
	GunJammer_CoolDown,
	SporeZombie,
	SporeZombie_CoolDown,
	CurseHuman,
	SeekerFound,
	StealerGotAmmo,
	Freeze,
	Accel,
	newBox,
	ScreamerZombieAb,
	BreakSpace,
	CureAbility,
	KamikazeAbiility,
	CryAttack
};

new Abilitys[MAX_PLAYERS][aname];

enum mapinfo
{
	m_MapName[128],
	m_FSMapName[128],
	m_FSMapLastName[128],
	Float:HumanSpawnX[5],
	Float:HumanSpawnY[5],
	Float:HumanSpawnZ[5],
	
	Float:FlagCoords[6],
	Float:FlagTextCoords[3],
	Text3D:flagText,
	
	Float:ZombieSpawnX[5],
	Float:ZombieSpawnY[5],
	Float:ZombieSpawnZ[5],
	
	m_Author[48],
	Float:m_GatePos[6],
	Float:m_GatePosTo[6],
	Float:m_Check[3],
	m_GateID,
	m_Gate2ID,
	Float:m_Gate2Pos[6],
	Float:m_Gate2PosTo[6],
	m_MoveGate,
	m_AllowWater,
	m_Interior,
	m_LastCapturedTime,
	m_World,
	m_Weather,
	m_CheckPointSize,
	m_Time,
	bool: m_IsStarted,
	Float:m_CamPos[6],
	m_XPType,
	Float:m_GateSpeed,
	m_GangControll,
	bool:m_AreaBattleStart,
	m_GangKillsPerRound[30],
};

new Map[mapinfo];

enum cInfo
{
	__ID,
	__RealID,
	bool:__isActive,
	Short[5],
	Full[128],
	Rank_0[32],
	Rank_1[32],
	Rank_2[32],
	Rank_3[32],
	Rank_4[32],
	Rank_5[32],
	EXP,
	Wins,
	Loses,
	Owner[24],
	
	g_Motd[128],
	g_Rules[128],
	g_isClosed,
	g_MinExp,
	g_MaxPayAmt,
	g_MaxWarns,
	g_RankToPromote,
	g_RankToAccept,
 	g_RankToWarn,
 	g_RankToBan,
 	g_RankToMotd,
 	g_RankGivePayDay,
 	g_RankToEdit,
 	g_RankToEditReq,
 	g_RankToChangeRules,
 	
 	g_MaxMembers,
 	g_InWar[4], // Yes | No, with ID, cup id, end time
 	g_TempWins,
 	g_TempLoses,
 	
 	//To Save
 	g_AllianceWith[30],
 	g_EnemysWith[30],
 	g_LastWarWas, //Time
	g_Cups[30],
 	g_CupsAlliance[30],
 	g_WasInWarTimes,
 	g_TimesPlayed,
 	g_House,
 	g_Buff,
 	g_Level,
 	Float:g_ObjectHealth,
	Text3D:g_ObjectStatus,
	g_GWTimer,
 	g_WeeksToKick,
 	g_Emblem,
 	g_LastKill,
 	g_TimeToJoin,
 	g_WarForCup,
 	g_WarType,
 	bool:g_IsRulles,
 	g_IsNeutral,
 	g_MapBuff,
 	g_CanPanelUse,
 	g_OwnerID,
 	g_ForMapID,
 	g_OwnedMaps,
 	g_FoundedDate,
};

new Clan[30][cInfo];

public OnQueryError(errorid, const error[], const callback[], const query[], MySQL:handle)
{
	printf("Error: %i\nError: %s\nCallback: %s", errorid, error, callback);
	printf("Query: %s", query);
	return 1;
}

fun Float:DistanceBeetwenPlayers(p1, p2)
{
	new Float:pos[6];
	GetPlayerPos(p1, pos[0], pos[1], pos[2]);
	GetPlayerPos(p2, pos[3], pos[4], pos[5]);
	return VectorSize(pos[0]-pos[3], pos[1]-pos[4], pos[2]-pos[5]);
}

fun bool:IsValidTimer(timerid) return timerid > -1;

fun SkipMapDueToOverflow(ObjectID)
{
    if(!already_skipped)
    {
		KillTimerEx(mapvar[0]);
		KillTimerEx(mapvar[1]);
		KillTimerEx(mapvar[2]);
		mapvar[2] = SetTimer("EndMap", MAX_RESTART_TIME, false);
		already_skipped = true;
		SendClientMessageToAll(-1, "{FFF000}[SERVER]: Internal map error detected, skiping to avoid memory leak");
		printf("-- LAST CREATED ID: %d", ObjectID);
	}
	return 1;
}

fun GetGangMembers(gangid)
{
    if(cache_num_rows() > 0) {
        cache_get_value_name_int(0, "members", Clan[gangid][g_MaxMembers]);
        cache_get_value_name_int(0, "maps", Clan[gangid][g_OwnedMaps]);
        printf("Gang #%d is %d of members! (Owned maps: %d)", gangid, Clan[gangid][g_MaxMembers], Clan[gangid][g_OwnedMaps]);
    }
	
	return 1;
}

fun LoadGang()
{
	if(cache_num_rows() > 0)
	{
	    for( new i; i < 29; i++)
		{
		    GangHouseText[i] = Create3DTextLabel("{d633ff}Gang's Info\n\n{FFFFFF}Press {FFF000}LEFT ALT{FFFFFF}", 0xFF0000FF, 313.1213,-166.1391,999.6010, 5.0, 10 + (i+1), 0);
	    	GangHouseExitText[i] = Create3DTextLabel("{FF0000}Exit\n{FFFFFF}Press {FFF000}LEFT ALT", 0xFF0000FF, 316.3654,-170.2976,999.5938, 10.0, 10 + (i+1), 0);
	    }
	    
		new Ranks[192], sets[256], t = GetTickCount(), query[256], alliance[256], war[256], cups_alliance[256], cups[256], igID;
 		for( new i = 0; i < cache_num_rows(); i++ )
		{
		    cache_get_value_name_int(i, "igID", igID);
		    
		    cache_get_value_name_int(i, "maps", Clan[igID][g_OwnedMaps]);
		    
		    cache_get_value_name(i, "Owner", Clan[igID][Owner], 25);
		    cache_get_value_name_int(i, "ID", Clan[igID][__RealID]);
		    cache_get_value_name(i, "Short", Clan[igID][Short], 6);
		    cache_get_value_name(i, "Full", Clan[igID][Full], 129);
            cache_get_value_name_int(i, "EXP", Clan[igID][EXP]);
	        cache_get_value_name(i, "Ranks", Ranks, 193);
	        cache_get_value_name_int(i, "Wins", Clan[igID][Wins]);
	        cache_get_value_name_int(i, "Loses", Clan[igID][Loses]);
	        cache_get_value_name(i, "Rs", Clan[igID][g_Rules], 129);
	        cache_get_value_name(i, "Mt", Clan[igID][g_Motd], 129);
	        cache_get_value_name(i, "sets", sets);
	        
	        cache_get_value_name(i, "alliance", alliance, 256);
	        cache_get_value_name(i, "war", war, 256);
	        cache_get_value_name(i, "al_cups", cups_alliance, 256);
	        cache_get_value_name(i, "cups", cups, 256);
	        
	        sscanf(alliance, "p<,>dddddddddddddddddddddddddddddd", Clan[igID][g_AllianceWith][0],Clan[igID][g_AllianceWith][1], Clan[igID][g_AllianceWith][2],
	        Clan[igID][g_AllianceWith][3],Clan[igID][g_AllianceWith][4], Clan[igID][g_AllianceWith][5],
	        Clan[igID][g_AllianceWith][6],Clan[igID][g_AllianceWith][7], Clan[igID][g_AllianceWith][8],
	        Clan[igID][g_AllianceWith][9],Clan[igID][g_AllianceWith][10], Clan[igID][g_AllianceWith][11],
	        Clan[igID][g_AllianceWith][12],Clan[igID][g_AllianceWith][13], Clan[igID][g_AllianceWith][14],
	        Clan[igID][g_AllianceWith][15],Clan[igID][g_AllianceWith][16], Clan[igID][g_AllianceWith][17],
	        Clan[igID][g_AllianceWith][18],Clan[igID][g_AllianceWith][19], Clan[igID][g_AllianceWith][20],
	        Clan[igID][g_AllianceWith][21],Clan[igID][g_AllianceWith][22], Clan[igID][g_AllianceWith][23],
	        Clan[igID][g_AllianceWith][24],Clan[igID][g_AllianceWith][25], Clan[igID][g_AllianceWith][26],
	        Clan[igID][g_AllianceWith][27],Clan[igID][g_AllianceWith][28], Clan[igID][g_AllianceWith][29]);
	        
	        sscanf(war, "p<,>dddddddddddddddddddddddddddddd", Clan[igID][g_EnemysWith][0],Clan[igID][g_EnemysWith][1], Clan[igID][g_EnemysWith][2],
	        Clan[igID][g_EnemysWith][3],Clan[igID][g_EnemysWith][4], Clan[igID][g_EnemysWith][5],
	        Clan[igID][g_EnemysWith][6],Clan[igID][g_EnemysWith][7], Clan[igID][g_EnemysWith][8],
	        Clan[igID][g_EnemysWith][9],Clan[igID][g_EnemysWith][10], Clan[igID][g_EnemysWith][11],
	        Clan[igID][g_EnemysWith][12],Clan[igID][g_EnemysWith][13], Clan[igID][g_EnemysWith][14],
	        Clan[igID][g_EnemysWith][15],Clan[igID][g_EnemysWith][16], Clan[igID][g_EnemysWith][17],
	        Clan[igID][g_EnemysWith][18],Clan[igID][g_EnemysWith][19], Clan[igID][g_EnemysWith][20],
	        Clan[igID][g_EnemysWith][21],Clan[igID][g_EnemysWith][22], Clan[igID][g_EnemysWith][23],
	        Clan[igID][g_EnemysWith][24],Clan[igID][g_EnemysWith][25], Clan[igID][g_EnemysWith][26],
	        Clan[igID][g_EnemysWith][27],Clan[igID][g_EnemysWith][28], Clan[igID][g_EnemysWith][29]);
	        
	        sscanf(cups_alliance, "p<,>dddddddddddddddddddddddddddddd", Clan[igID][g_CupsAlliance][0],Clan[igID][g_CupsAlliance][1], Clan[igID][g_CupsAlliance][2],
	        Clan[igID][g_CupsAlliance][3],Clan[igID][g_CupsAlliance][4], Clan[igID][g_CupsAlliance][5],
	        Clan[igID][g_CupsAlliance][6],Clan[igID][g_CupsAlliance][7], Clan[igID][g_CupsAlliance][8],
	        Clan[igID][g_CupsAlliance][9],Clan[igID][g_CupsAlliance][10], Clan[igID][g_CupsAlliance][11],
	        Clan[igID][g_CupsAlliance][12],Clan[igID][g_CupsAlliance][13], Clan[igID][g_CupsAlliance][14],
	        Clan[igID][g_CupsAlliance][15],Clan[igID][g_CupsAlliance][16], Clan[igID][g_CupsAlliance][17],
	        Clan[igID][g_CupsAlliance][18],Clan[igID][g_CupsAlliance][19], Clan[igID][g_CupsAlliance][20],
	        Clan[igID][g_CupsAlliance][21],Clan[igID][g_CupsAlliance][22], Clan[igID][g_CupsAlliance][23],
	        Clan[igID][g_CupsAlliance][24],Clan[igID][g_CupsAlliance][25], Clan[igID][g_CupsAlliance][26],
	        Clan[igID][g_CupsAlliance][27],Clan[igID][g_CupsAlliance][28], Clan[igID][g_CupsAlliance][29]);
	        
	        sscanf(cups, "p<,>dddddddddddddddddddddddddddddd", Clan[igID][g_Cups][0],Clan[igID][g_Cups][1], Clan[igID][g_Cups][2],
	        Clan[igID][g_Cups][3],Clan[igID][g_Cups][4], Clan[igID][g_Cups][5],
	        Clan[igID][g_Cups][6],Clan[igID][g_Cups][7], Clan[igID][g_Cups][8],
	        Clan[igID][g_Cups][9],Clan[igID][g_Cups][10], Clan[igID][g_Cups][11],
	        Clan[igID][g_Cups][12],Clan[igID][g_Cups][13], Clan[igID][g_Cups][14],
	        Clan[igID][g_Cups][15],Clan[igID][g_Cups][16], Clan[igID][g_Cups][17],
	        Clan[igID][g_Cups][18],Clan[igID][g_Cups][19], Clan[igID][g_Cups][20],
	        Clan[igID][g_Cups][21],Clan[igID][g_Cups][22], Clan[igID][g_Cups][23],
	        Clan[igID][g_Cups][24],Clan[igID][g_Cups][25], Clan[igID][g_Cups][26],
	        Clan[igID][g_Cups][27],Clan[igID][g_Cups][28], Clan[igID][g_Cups][29]);
	        
	        Clan[igID][g_WarType] = -1;
	        
		    if(strlen(Clan[igID][Owner]) >= 1)
			{
			    Clan[igID][__isActive] = true;
			    Clan[igID][__ID]++;
		        sscanf(sets, "p<,>iiiiiiiiiiiiiiiiiiiiiiiiii",
				Clan[igID][g_isClosed],
		        Clan[igID][g_MinExp],
		        Clan[igID][g_MaxPayAmt],
		        Clan[igID][g_MaxWarns],
		        Clan[igID][g_RankToPromote],
		        Clan[igID][g_RankToAccept],
		        Clan[igID][g_RankToWarn],
		        Clan[igID][g_RankToMotd],
		        Clan[igID][g_RankGivePayDay],
		        Clan[igID][g_RankToEdit],
		        Clan[igID][g_RankToEditReq],
		        Clan[igID][g_RankToChangeRules],
				Clan[igID][g_RankToBan],
                Clan[igID][g_LastWarWas], // 14
				Clan[igID][g_WasInWarTimes], // 15
				Clan[igID][g_House], // 16
				Clan[igID][g_Buff], // 17
				Clan[igID][g_Level], // 18
				Clan[igID][g_WeeksToKick],
				Clan[igID][g_Emblem],
				Clan[igID][g_LastKill],
				Clan[igID][g_IsNeutral],
				Clan[igID][g_MapBuff],
				Clan[igID][g_CanPanelUse],
				Clan[igID][g_OwnerID],
				Clan[igID][g_FoundedDate]);
				if(Clan[igID][g_CanPanelUse] <= 4) Clan[igID][g_CanPanelUse] = 6;

				Clan[igID][g_TimesPlayed] = 0;
				
		        sscanf(Ranks, "p<,>s[32]s[32]s[32]s[32]s[32]s[32]", Clan[igID][Rank_0], Clan[igID][Rank_1], Clan[igID][Rank_2], Clan[igID][Rank_3], Clan[igID][Rank_4], Clan[igID][Rank_5]);
	            //if(Clan[igID][g_RankToBan] <= 0) Clan[igID][g_RankToBan] = 5;
	            mysql_format(Base, query, sizeof(query), "SELECT count(`Clan`) members, (SELECT count(`controlled`) FROM `maps` WHERE `controlled` = '%d' GROUP BY `controlled`) AS maps FROM `users` WHERE `Clan` = '%d' GROUP BY `Clan`", igID, igID);
				mysql_tquery(Base, query, "GetGangMembers", "i", igID);
			}
		}
		printf("Gangs loaded in %f seconds", (GetTickCount() -  t)/1000);
	}
	return 1;
}

fun setGangRuller()
{
	if(cache_num_rows())
	{
	    for( new i = 0, mp = 0; i < cache_num_rows(); i++)
	    {
	        cache_get_value_name_int(i, "controlled", mp);
	        if(strlen(Clan[mp][Full]) >= 1)
	        {
	            Clan[mp][g_IsRulles] = true;
	            printf("%s(%d) is rullers!", Clan[mp][Full], mp);
	            SendMessageFormatToAll(-1, "{FFF000}>> %s is ruler!", Clan[mp][Full]);
                break;
			}
		}
	}
	return 1;
}

stock LoadDataFromBD()
{
    printf("---------------------");
	printf("+++ Build v"SERVER_BUILD" is started +++");
	printf("---------------------");
	
	new query[144];
    mysql_format(Base, query, sizeof(query), "SELECT * FROM `gangs` WHERE `ID` != 0 AND `build` = '"SERVER_BUILD"'");
	mysql_tquery(Base, query, "LoadGang");
	
	//mysql_format(Base, query, sizeof(query), "SELECT * FROM `cups` WHERE `ID` != 0 AND `build`='"SERVER_BUILD"'");
	//mysql_tquery(Base, query, "LoadCups");
	
	mysql_format(Base, query, sizeof(query), "SELECT count(`controlled`), `controlled` FROM `maps` GROUP BY `controlled` ORDER BY count(`controlled`) DESC");
	mysql_tquery(Base, query, "setGangRuller");
	
	mysql_format(Base, query, sizeof(query),"SELECT * FROM `gangrulespolicy` WHERE `ID` = '1'");
	mysql_tquery(Base, query, "LoadRulesPolicy");
	
	//mysql_format(Base, query, sizeof(query),"SELECT * FROM `night` WHERE `tm` > '1'");
	//mysql_tquery(Base, query, "LoadNight");
	
	return 1;
}

enum ep_shop
{
	eps_id[10],
	eps_inx[10],
	eps_count[10],
	eps_price[10],
	eps_time[10],
	eps_vip[10],
	eps_acc[10],
	eps_type[10],
	
	eps_info_0[128], eps_info_1[128], eps_info_2[128],
	eps_info_3[128], eps_info_4[128], eps_info_5[128],
	eps_info_6[128], eps_info_7[128], eps_info_8[128],
	eps_info_9[128]
};

new OnlineShop[MAX_PLAYERS][ep_shop];

/*enum e_shop
{
	bool:Bought,
	esp_buys[10],
};

new Shop[MAX_PLAYERS][esp_buys];*/

stock SaveRulesPolicy()
{
    new query[128], str[64];
    format(str, sizeof(str), "%d,%d,%d,%d,%d,%d,%d,%d,%d", GangsSettings[0], GangsSettings[1], GangsSettings[2], GangsSettings[3], GangsSettings[4], GangsSettings[5], GangTimer[0], GangTimer[1], GangsSettings[6]);
	mysql_format(Base, query, sizeof(query), "UPDATE `gangrulespolicy` SET `settings`='%e' WHERE `ID` = '1'", str);
	mysql_tquery(Base, query, "", "", "");
}

fun LoadRulesPolicy()
{
    if(cache_num_rows() > 0)
	{
	    new GangRulesPolicy[128];
	    cache_get_value_name(0, "settings", GangRulesPolicy, 128);
        sscanf(GangRulesPolicy, "p<,>ddddddddd", GangsSettings[0], GangsSettings[1], GangsSettings[2], GangsSettings[3], GangsSettings[4], GangsSettings[5], GangTimer[0], GangTimer[1], GangsSettings[6]);
	}
	return 1;
}

stock SaveGangs(bool:ss = false)
{
	new query[4096], Ranks[192], sets[300], alliance[256], war[256], cups_alliance[256], cups[256];
	for( new i = 1; i < sizeof(Clan); i++ )
	{
	    if(Clan[i][__isActive])
	    {
	        format(sets, sizeof sets, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
	        Clan[i][g_isClosed], // 1
	        Clan[i][g_MinExp], // 2
	        Clan[i][g_MaxPayAmt], // 3
	        Clan[i][g_MaxWarns], // 4
	        Clan[i][g_RankToPromote], // 5
	        Clan[i][g_RankToAccept], // 6
	        Clan[i][g_RankToWarn], // 7
	        Clan[i][g_RankToMotd], // 8
	        Clan[i][g_RankGivePayDay], // *
	        Clan[i][g_RankToEdit], // 10
	        Clan[i][g_RankToEditReq], // 11
	        Clan[i][g_RankToChangeRules], // 12
			Clan[i][g_RankToBan], // 13
			Clan[i][g_LastWarWas], // 14
			Clan[i][g_WasInWarTimes], // 15
			Clan[i][g_House], // 16
			Clan[i][g_Buff], // 17
			Clan[i][g_Level], // 18
			Clan[i][g_WeeksToKick], // 19
			Clan[i][g_Emblem],
			Clan[i][g_LastKill],
			Clan[i][g_IsNeutral],
			Clan[i][g_MapBuff],
			Clan[i][g_CanPanelUse],
			Clan[i][g_OwnerID],
			Clan[i][g_FoundedDate]);
			
	        format(alliance, 256, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d", Clan[i][g_AllianceWith][0],Clan[i][g_AllianceWith][1], Clan[i][g_AllianceWith][2],
	        Clan[i][g_AllianceWith][3],Clan[i][g_AllianceWith][4], Clan[i][g_AllianceWith][5],
	        Clan[i][g_AllianceWith][6],Clan[i][g_AllianceWith][7], Clan[i][g_AllianceWith][8],
	        Clan[i][g_AllianceWith][9],Clan[i][g_AllianceWith][10], Clan[i][g_AllianceWith][11],
	        Clan[i][g_AllianceWith][12],Clan[i][g_AllianceWith][13], Clan[i][g_AllianceWith][14],
	        Clan[i][g_AllianceWith][15],Clan[i][g_AllianceWith][16], Clan[i][g_AllianceWith][17],
	        Clan[i][g_AllianceWith][18],Clan[i][g_AllianceWith][19], Clan[i][g_AllianceWith][20],
	        Clan[i][g_AllianceWith][21],Clan[i][g_AllianceWith][22], Clan[i][g_AllianceWith][23],
	        Clan[i][g_AllianceWith][24],Clan[i][g_AllianceWith][25], Clan[i][g_AllianceWith][26],
	        Clan[i][g_AllianceWith][27],Clan[i][g_AllianceWith][28], Clan[i][g_AllianceWith][29]);
	        
	        format(war, 256, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
	        Clan[i][g_EnemysWith][0],Clan[i][g_EnemysWith][1], Clan[i][g_EnemysWith][2],
	        Clan[i][g_EnemysWith][3],Clan[i][g_EnemysWith][4], Clan[i][g_EnemysWith][5],
	        Clan[i][g_EnemysWith][6],Clan[i][g_EnemysWith][7], Clan[i][g_EnemysWith][8],
	        Clan[i][g_EnemysWith][9],Clan[i][g_EnemysWith][10], Clan[i][g_EnemysWith][11],
	        Clan[i][g_EnemysWith][12],Clan[i][g_EnemysWith][13], Clan[i][g_EnemysWith][14],
	        Clan[i][g_EnemysWith][15],Clan[i][g_EnemysWith][16], Clan[i][g_EnemysWith][17],
	        Clan[i][g_EnemysWith][18],Clan[i][g_EnemysWith][19], Clan[i][g_EnemysWith][20],
	        Clan[i][g_EnemysWith][21],Clan[i][g_EnemysWith][22], Clan[i][g_EnemysWith][23],
	        Clan[i][g_EnemysWith][24],Clan[i][g_EnemysWith][25], Clan[i][g_EnemysWith][26],
	        Clan[i][g_EnemysWith][27],Clan[i][g_EnemysWith][28], Clan[i][g_EnemysWith][29]);
	        
         	format(cups_alliance, 256, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
	        Clan[i][g_CupsAlliance][0],Clan[i][g_CupsAlliance][1], Clan[i][g_CupsAlliance][2],
	        Clan[i][g_CupsAlliance][3],Clan[i][g_CupsAlliance][4], Clan[i][g_CupsAlliance][5],
	        Clan[i][g_CupsAlliance][6],Clan[i][g_CupsAlliance][7], Clan[i][g_CupsAlliance][8],
	        Clan[i][g_CupsAlliance][9],Clan[i][g_CupsAlliance][10], Clan[i][g_CupsAlliance][11],
	        Clan[i][g_CupsAlliance][12],Clan[i][g_CupsAlliance][13], Clan[i][g_CupsAlliance][14],
	        Clan[i][g_CupsAlliance][15],Clan[i][g_CupsAlliance][16], Clan[i][g_CupsAlliance][17],
	        Clan[i][g_CupsAlliance][18],Clan[i][g_CupsAlliance][19], Clan[i][g_CupsAlliance][20],
	        Clan[i][g_CupsAlliance][21],Clan[i][g_CupsAlliance][22], Clan[i][g_CupsAlliance][23],
	        Clan[i][g_CupsAlliance][24],Clan[i][g_CupsAlliance][25], Clan[i][g_CupsAlliance][26],
	        Clan[i][g_CupsAlliance][27],Clan[i][g_CupsAlliance][28], Clan[i][g_CupsAlliance][29]);
	        
	        format(cups, 256, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
	        Clan[i][g_Cups][0],Clan[i][g_Cups][1], Clan[i][g_Cups][2],
	        Clan[i][g_Cups][3],Clan[i][g_Cups][4], Clan[i][g_Cups][5],
	        Clan[i][g_Cups][6],Clan[i][g_Cups][7], Clan[i][g_Cups][8],
	        Clan[i][g_Cups][9],Clan[i][g_Cups][10], Clan[i][g_Cups][11],
	        Clan[i][g_Cups][12],Clan[i][g_Cups][13], Clan[i][g_Cups][14],
	        Clan[i][g_Cups][15],Clan[i][g_Cups][16], Clan[i][g_Cups][17],
	        Clan[i][g_Cups][18],Clan[i][g_Cups][19], Clan[i][g_Cups][20],
	        Clan[i][g_Cups][21],Clan[i][g_Cups][22], Clan[i][g_Cups][23],
	        Clan[i][g_Cups][24],Clan[i][g_Cups][25], Clan[i][g_Cups][26],
	        Clan[i][g_Cups][27],Clan[i][g_Cups][28], Clan[i][g_Cups][29]);
	        
			format(Ranks, 192, "%s,%s,%s,%s,%s,%s", Clan[i][Rank_0], Clan[i][Rank_1], Clan[i][Rank_2], Clan[i][Rank_3], Clan[i][Rank_4], Clan[i][Rank_5]);

			mysql_format(Base, query, sizeof(query), "UPDATE `gangs` SET `Short`='%e',`Full`='%e',`EXP`='%d',`Ranks`='%e',`Wins`='%d',`Loses`='%d',`Rs`='%e',`Mt`='%e',`sets`='%e',`cup`='%e',`alliance`='%e',`war`='%e',`al_cups`='%e',`igID`='%d' WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'",
			Clan[i][Short],
			Clan[i][Full],
			Clan[i][EXP],
			Ranks,
			Clan[i][Wins],
			Clan[i][Loses],
			Clan[i][g_Rules],
			Clan[i][g_Motd],
			sets,
			cups,
			alliance,
			war,
			cups_alliance,
			i,
			Clan[i][__RealID]);
			mysql_tquery(Base, query, "", "", "");
			if(ss) SendMessageFormatToAll(-1, "{C0C0C0}>> Gang %s (ID %d) has been saved!", Clan[i][Full], i);
		}
	}
}

enum e_Info
{
	e_Name[32],
	bool:e_IsStarted,
	bool:e_IsJoinsClosed,
	bool:e_IsEnded, // Set everything as 1
	bool:e_IsGangNeed,
	bool:e_IsTeamActive[6],
	bool:e_RequestToDelete,
	Float:e_defaultPoses[3],
	Float:e_CarsPos[72], // 18 * 4 (Vec3 Pos, Angle)
	e_CarProps[36], // 18 * 2 (carid) (team)
	Float:e_HumanPos[24],
	e_Rulers[10],
	e_RulersPermisions[8], //dev mode, close joins, set spawns, set car spawns, set skin, set teams, kick players, start event
    e_Skin[6],
    e_VirtualWorld,
	e_minPlayers,
	e_maxPlayers,
	e_curPlayers,
	e_minRank,
	e_minExp,
	e_TimerCount,
	e_OwnerID,
	e_Objects[100],
	e_TimeToEnd,
	Float:e_Gravity,
	e_Pickups[MAX_PLAYERS],
	e_Time,
	e_Weather,
};

new EventInfo[10][e_Info]; // 6.5+ MB

fun OnGameModeInit()
{
    restartTimes = 0;
    AntiCheatAlertMode = true;
    CanPay = true;
    
    ClearEventsFromMemory();
	
    AntiDeAMX();
	SetGameModeText("Zombie Server");
	SendRconCommand("weburl "SITE"");

    Iter_Clear(Players);

    ShowPlayerMarkers(PLAYER_MARKERS_MODE_GLOBAL);
    ShowNameTags(1);
    //ManualVehicleEngineAndLights();
    SetTeamCount(2);
	DisableInteriorEnterExits();
	EnableStuntBonusForAll(0);
	AllowInteriorWeapons(1);
	
    Base = mysql_connect(SQL_HOST, SQL_USER, SQL_PASS, SQL_DB);
    
   	printf("MySQL status: %d", mysql_errno(Base));
	mysql_tquery(Base, "SET NAMES utf8", "", "", "");
	
    //mysql_log(NONE);
    mysql_log(ERROR | WARNING); //TODO
    //mysql_log(ALL); //TODO
    
	AddPlayerClass(181, 2415.4060,-51.9490,28.1535, 350.1417, 0, 0, 0, 0, 0, 0);
	
	for( new i; i < 10; i++ ) EventInfo[i][e_IsEnded] = true;
	
	ServerStats[cn_Ru] = 0;
	ServerStats[cn_Sp] = 0;
	ServerStats[cn_En] = 0;
	
	//LoadConnections();
	
	TimeLeft = TextDrawCreate(22.000000, 251.000000, "300");
	TextDrawBackgroundColor(TimeLeft, 255);
	TextDrawFont(TimeLeft, 3);
	TextDrawLetterSize(TimeLeft, 1.770000, 3.499999);
	TextDrawColor(TimeLeft, 16777215);
	TextDrawSetOutline(TimeLeft, 0);
	TextDrawSetProportional(TimeLeft, 1);
	TextDrawSetShadow(TimeLeft, 1);

	for(new i; i < MAX_PLAYERS; i++)
	{
	    /////////////////////////// INFO /////////////////////////////////////

		DisplayInfo[0][i] = TextDrawCreate(3.5000, 425.8125, "Next_Map:"); // ?????
		TextDrawLetterSize(DisplayInfo[0][i], 0.1870, 1.1537);
		TextDrawAlignment(DisplayInfo[0][i], 1);
		TextDrawColor(DisplayInfo[0][i], -1);
		TextDrawBackgroundColor(DisplayInfo[0][i], 255);
		TextDrawFont(DisplayInfo[0][i], 2);
		TextDrawSetProportional(DisplayInfo[0][i], 1);
		TextDrawSetShadow(DisplayInfo[0][i], 1);

		DisplayInfo[1][i] = TextDrawCreate(3.5000, 435.4375, "~w~Killstreaks:_1._~r~Player_(0)_~w~2._~r~Player_(0)_~w~3._~r~Player_(0)"); // ?????
		TextDrawLetterSize(DisplayInfo[1][i], 0.1870, 1.1537);
		TextDrawTextSize(DisplayInfo[1][i], 383.0000, 0.0000);
		TextDrawAlignment(DisplayInfo[1][i], 1);
		TextDrawColor(DisplayInfo[1][i], -1);
		TextDrawBackgroundColor(DisplayInfo[1][i], 255);
		TextDrawFont(DisplayInfo[1][i], 2);
		TextDrawSetProportional(DisplayInfo[1][i], 1);
		TextDrawSetShadow(DisplayInfo[1][i], 1);
	    
	    /////////////////////////// ALERTS /////////////////////////////////////
	    DisplayAlerts[0][i] = TextDrawCreate(485.0000, 354.9375, "Box"); // ?????
		TextDrawLetterSize(DisplayAlerts[0][i], 0.0000, 1.4000);
		TextDrawTextSize(DisplayAlerts[0][i], 632.0000, 0.0000);
		TextDrawAlignment(DisplayAlerts[0][i], 1);
		TextDrawColor(DisplayAlerts[0][i], 187);
		TextDrawUseBox(DisplayAlerts[0][i], 1);
		TextDrawBoxColor(DisplayAlerts[0][i], 85);
		TextDrawBackgroundColor(DisplayAlerts[0][i], 187);
		TextDrawFont(DisplayAlerts[0][i], 1);
		TextDrawSetProportional(DisplayAlerts[0][i], 1);
		TextDrawSetShadow(DisplayAlerts[0][i], 0);

		DisplayAlerts[1][i] = TextDrawCreate(558.0000, 355.3750, "~w~LOADING..."); // ?????
		TextDrawLetterSize(DisplayAlerts[1][i], 0.2589, 1.2849);
		TextDrawTextSize(DisplayAlerts[1][i], 0.0000, 77.0000);
		TextDrawAlignment(DisplayAlerts[1][i], 2);
		TextDrawColor(DisplayAlerts[1][i], -1);
		TextDrawBackgroundColor(DisplayAlerts[1][i], 255);
		TextDrawFont(DisplayAlerts[1][i], 2);
		TextDrawSetProportional(DisplayAlerts[1][i], 1);
		TextDrawSetShadow(DisplayAlerts[1][i], 1);

		DisplayAlerts[2][i] = TextDrawCreate(462.0000, 349.2500, "ld_shtr:kami"); // ?????
		TextDrawTextSize(DisplayAlerts[2][i], 31.0000, 21.0000);
		TextDrawAlignment(DisplayAlerts[2][i], 1);
		TextDrawColor(DisplayAlerts[2][i], -2139062017);
		TextDrawBackgroundColor(DisplayAlerts[2][i], 255);
		TextDrawFont(DisplayAlerts[2][i], 4);
		TextDrawSetProportional(DisplayAlerts[2][i], 0);
		TextDrawSetShadow(DisplayAlerts[2][i], 0);
	    
	    ///////////////////////// ALERTS END ///////////////////////////////////
	    UntillEvac[0][i] = TextDrawCreate(14.000000, 283.937500, "LD_SPAC:white");
		TextDrawLetterSize(UntillEvac[0][i], 0.000000, 0.000000);
		TextDrawTextSize(UntillEvac[0][i], 119.500000, 21.437500);
		TextDrawAlignment(UntillEvac[0][i], 1);
		TextDrawColor(UntillEvac[0][i], 255);
		TextDrawSetShadow(UntillEvac[0][i], 0);
		TextDrawSetOutline(UntillEvac[0][i], 0);
		TextDrawBackgroundColor(UntillEvac[0][i], 255);
		TextDrawFont(UntillEvac[0][i], 4);

		UntillEvac[1][i] = TextDrawCreate(18.500000, 285.250000, "~r~UNTIL EVAC");
		TextDrawLetterSize(UntillEvac[1][i], 0.562500, 1.984999);
		TextDrawAlignment(UntillEvac[1][i], 1);
		TextDrawColor(UntillEvac[1][i], 0xFF0000FF);
		TextDrawSetShadow(UntillEvac[1][i], 0);
		TextDrawSetOutline(UntillEvac[1][i], 1);
		TextDrawBackgroundColor(UntillEvac[1][i], 51);
		TextDrawFont(UntillEvac[1][i], 1);
		TextDrawSetProportional(UntillEvac[1][i], 1);
	
	    AliveInfo[i] = TextDrawCreate(21.500000, 152.250000, "Zombies: 0~n~~w~Humans: 0");
		TextDrawLetterSize(AliveInfo[i], 0.511498, 1.477498);
		TextDrawAlignment(AliveInfo[i], 1);
		TextDrawColor(AliveInfo[i], -16776961);
		TextDrawSetShadow(AliveInfo[i], 1);
		TextDrawSetOutline(AliveInfo[i], 0);
		TextDrawBackgroundColor(AliveInfo[i], 255);
		TextDrawFont(AliveInfo[i], 2);
		TextDrawSetProportional(AliveInfo[i], 1);
	
	    FPS_Info[i] = TextDrawCreate(17.5000, 315.5625, "~y~FPS:_~w~0"); // ?????
		TextDrawLetterSize(FPS_Info[i], 0.3065, 1.1537);
		TextDrawTextSize(FPS_Info[i], 152.0000, 0.0000);
		TextDrawAlignment(FPS_Info[i], 1);
		TextDrawColor(FPS_Info[i], -1);
		TextDrawBackgroundColor(FPS_Info[i], 255);
		TextDrawFont(FPS_Info[i], 2);
		TextDrawSetProportional(FPS_Info[i], 1);
		TextDrawSetShadow(FPS_Info[i], 1);
	
	    XP[i] = TextDrawCreate(546.000000, 35.000000, "~n~");
	    TextDrawBackgroundColor(XP[i], 255);
	    TextDrawFont(XP[i], 2);
	    TextDrawLetterSize(XP[i], 0.270000, 1.000000);
	    TextDrawColor(XP[i], 16777215);
	    TextDrawSetOutline(XP[i], 0);
	    TextDrawSetProportional(XP[i], 1);
	    TextDrawSetShadow(XP[i], 1);
	   
		SpawnProtection[i] = TextDrawCreate(500.000000, 100.625000, "~y~spawn ~w~protection");
		TextDrawLetterSize(SpawnProtection[i], 0.304999, 1.446873);
		TextDrawAlignment(SpawnProtection[i], 1);
		TextDrawColor(SpawnProtection[i], -1);
		TextDrawSetShadow(SpawnProtection[i], 0);
		TextDrawSetOutline(SpawnProtection[i], 1);
		TextDrawBackgroundColor(SpawnProtection[i], 255);
		TextDrawFont(SpawnProtection[i], 2);
		TextDrawSetProportional(SpawnProtection[i], 1);
		
        Infected[i] = TextDrawCreate(655.500000, 1.500000, "usebox");
        TextDrawBackgroundColor(Infected[i], 255);
        TextDrawFont(Infected[i], 0);
		TextDrawLetterSize(Infected[i], 0.000000, 50.262496);
		TextDrawColor(Infected[i], 0);
		TextDrawSetOutline(Infected[i], 0);
		TextDrawSetProportional(Infected[i], 1);
		TextDrawSetShadow(Infected[i], 1);
		TextDrawUseBox(Infected[i], true);
		TextDrawBoxColor(Infected[i], 1174405190);
		TextDrawTextSize(Infected[i], -2.000000, 0.000000);

        ServerIntro[i][0] = TextDrawCreate(204.500000, 49.437500, "welcome to the");
		TextDrawLetterSize(ServerIntro[i][0], 0.400499, 1.665625);
		TextDrawAlignment(ServerIntro[i][0], 1);
		TextDrawColor(ServerIntro[i][0], -1);
		TextDrawSetShadow(ServerIntro[i][0], 2);
		TextDrawSetOutline(ServerIntro[i][0], 0);
		TextDrawBackgroundColor(ServerIntro[i][0], 255);
		TextDrawFont(ServerIntro[i][0], 2);
		TextDrawSetProportional(ServerIntro[i][0], 1);

		ServerIntro[i][1] = TextDrawCreate(204.000000, 61.250000, "Zombie Apocalypse");
		TextDrawLetterSize(ServerIntro[i][1], 1.053498, 2.960623);
		TextDrawAlignment(ServerIntro[i][1], 1);
		TextDrawColor(ServerIntro[i][1], -16776961);
		TextDrawSetShadow(ServerIntro[i][1], 2);
		TextDrawSetOutline(ServerIntro[i][1], 0);
		TextDrawBackgroundColor(ServerIntro[i][1], 255);
		TextDrawFont(ServerIntro[i][1], 1);
		TextDrawSetProportional(ServerIntro[i][1], 1);

		ServerIntro[i][2] = TextDrawCreate(461.500000, 88.812500, "server");
		TextDrawLetterSize(ServerIntro[i][2], 0.449999, 1.600000);
		TextDrawAlignment(ServerIntro[i][2], 1);
		TextDrawColor(ServerIntro[i][2], -1);
		TextDrawSetShadow(ServerIntro[i][2], 2);
		TextDrawSetOutline(ServerIntro[i][2], 0);
		TextDrawBackgroundColor(ServerIntro[i][2], 255);
		TextDrawFont(ServerIntro[i][2], 2);
		TextDrawSetProportional(ServerIntro[i][2], 1);

		ServerIntro[i][3] = TextDrawCreate(426.000000, 117.250000, "Add to favorites <3");
		TextDrawLetterSize(ServerIntro[i][3], 0.282000, 1.018125);
		TextDrawAlignment(ServerIntro[i][3], 1);
		TextDrawColor(ServerIntro[i][3], -16711681);
		TextDrawSetShadow(ServerIntro[i][3], 1);
		TextDrawSetOutline(ServerIntro[i][3], 0);
		TextDrawBackgroundColor(ServerIntro[i][3], 255);
		TextDrawFont(ServerIntro[i][3], 2);
		TextDrawSetProportional(ServerIntro[i][3], 1);

		ServerIntro[i][4] = TextDrawCreate(225.500000, 109.812500, "Type /help for more information~n~Type /rules for the server rules");
		TextDrawLetterSize(ServerIntro[i][4], 0.326999, 1.057500);
		TextDrawAlignment(ServerIntro[i][4], 1);
		TextDrawColor(ServerIntro[i][4], 16711935);
		TextDrawSetShadow(ServerIntro[i][4], 2);
		TextDrawSetOutline(ServerIntro[i][4], 0);
		TextDrawBackgroundColor(ServerIntro[i][4], 255);
		TextDrawFont(ServerIntro[i][4], 1);
		TextDrawSetProportional(ServerIntro[i][4], 1);

        Poision[i] = TextDrawCreate(655.500000, 1.500000, "usebox");
		TextDrawLetterSize(Poision[i], 0.000000, 50.262496);
		TextDrawTextSize(Poision[i], -2.000000, 0.000000);
		TextDrawAlignment(Poision[i], 1);
		TextDrawColor(Poision[i], 0);
		TextDrawUseBox(Poision[i], true);
		TextDrawBoxColor(Poision[i], 0xFF4DFF33);
		TextDrawSetShadow(Poision[i], 0);
		TextDrawSetOutline(Poision[i], 0);
		TextDrawFont(Poision[i], 0);
		
		GreenScreen[i] = TextDrawCreate(655.500000, 1.500000, "usebox");
		TextDrawLetterSize(GreenScreen[i], 0.000000, 50.262496);
		TextDrawTextSize(GreenScreen[i], -2.000000, 0.000000);
		TextDrawAlignment(GreenScreen[i], 1);
		TextDrawColor(GreenScreen[i], 0);
		TextDrawUseBox(GreenScreen[i], true);
		TextDrawBoxColor(GreenScreen[i], 0x00cc4433);
		TextDrawSetShadow(GreenScreen[i], 0);
		TextDrawSetOutline(GreenScreen[i], 0);
		TextDrawFont(GreenScreen[i], 0);
		
		AIR[i] = TextDrawCreate(300.000000, 426.875000, "~y~ABILITY~w~ IS~g~ READY!"); // 401
		TextDrawLetterSize(AIR[i], 0.637500, 2.107499);
		TextDrawAlignment(AIR[i], 1);
		TextDrawColor(AIR[i], -1);
		TextDrawSetShadow(AIR[i], 1);
		TextDrawSetOutline(AIR[i], 0);
		TextDrawBackgroundColor(AIR[i], 255);
		TextDrawFont(AIR[i], 2);
		TextDrawSetProportional(AIR[i], 1);
		
		Blidnes[i] = TextDrawCreate(644.000000, 1.500000, "usebox");
		TextDrawLetterSize(Blidnes[i], 0.000000, 49.612495);
		TextDrawTextSize(Blidnes[i], -2.000000, 0.000000);
		TextDrawAlignment(Blidnes[i], 1);
		TextDrawColor(Blidnes[i], 0);
		TextDrawUseBox(Blidnes[i], true);
		TextDrawBoxColor(Blidnes[i], 0x00000000);
		TextDrawSetShadow(Blidnes[i], 0);
		TextDrawSetOutline(Blidnes[i], 0);
		TextDrawFont(Blidnes[i], 0);
		
		Stun[i] = TextDrawCreate(655.500000, 1.500000, "usebox");
		TextDrawLetterSize(Stun[i], 0.000000, 50.262496);
		TextDrawTextSize(Stun[i], -2.000000, 0.000000);
		TextDrawAlignment(Stun[i], 1);
		TextDrawColor(Stun[i], 0);
		TextDrawUseBox(Stun[i], true);
		TextDrawBoxColor(Stun[i], 0xFFF00033);
		TextDrawSetShadow(Stun[i], 0);
		TextDrawSetOutline(Stun[i], 0);
		TextDrawFont(Stun[i], 0);

		Blind[i] = TextDrawCreate(0.000000, 0.000000, "LD_SPAC:white");
		TextDrawLetterSize(Blind[i], 0.000000, 0.000000);
		TextDrawTextSize(Blind[i], 640.000000, 448.000000);
		TextDrawAlignment(Blind[i], 1);
		TextDrawColor(Blind[i], 255);
		TextDrawSetShadow(Blind[i], 0);
		TextDrawSetOutline(Blind[i], 0);
		TextDrawFont(Blind[i], 4);
		
	}
	
	for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) SpawnPoints[j] = Create3DTextLabel("{FFFFFF}Zombie Spawn\ndo{FF0000} not{FFFFFF} shoot zombies here", 0xFF0000FF, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j], 50.0, 0, 1);

	SetTimer("Update", 1000, true);
	
	//SetTimer("EventUpdate", 1000, 1); // Event
	
	SetTimer("RandomMessages",59000,true);
	SetTimer("RandomQuiz",240000, true);
	//SetTimer("Text",2000, false);
	
	//SetTimer("CockroachMove", 300, 1);
	Map[m_IsStarted] = false;
	mapid = 0;
	current_map = 0;
	
	playerOnline = 0;
	LoadDataFromBD();
	
	MapObjects[0] = CreateObject(1685, 965.69617, -53.67023, 1000.79242, 0.00000, 0.00000, 0.00000);
	MapObjects[1] = CreateObject(1685, 965.69623, -51.91020, 1000.79242, 0.00000, 0.00000, 0.00000);
	MapObjects[2] = CreateObject(1685, 965.69623, -53.67020, 1002.26691, 0.00000, 0.00000, 0.00000);
	MapObjects[3] = CreateObject(1685, 965.70428, -51.91020, 1002.26691, 0.00000, 0.00000, 0.00000);
	MapObjects[4] = CreateObject(1685, 965.69623, -53.67020, 1003.46661, 0.00000, 0.00000, 0.00000);
	MapObjects[5] = CreateObject(1685, 965.70428, -51.91020, 1003.46661, 0.00000, 0.00000, 0.00000);

    MapObjects[6] = CreateObject(3571, 1388.19189, -17.77230, 1001.15417,   0.00000, 0.00000, 88.00790);
	MapObjects[7] = CreateObject(3571, 1390.74951, -17.84370, 1001.15417,   0.00000, 0.00000, 88.00790);
	MapObjects[8] = CreateObject(3571, 1389.53467, -17.78670, 1003.82703,   0.00000, 0.00000, 88.00790);

	new roof[10], water[3], wall[65], bridge[4], i, j, Float:distance = 300.0;
   	roof[4] = CreateObject(3753, 1187.80933, 2377.06592, 104.72122,   45.00000, 0.00000, 270.00000, distance);
	roof[5] = CreateObject(3753, 1187.76843, 2323.02637, 104.72122,   45.00000, 0.00000, 270.00000, distance);
	roof[6] = CreateObject(3753, 1187.43030, 2270.86914, 104.72122,   45.00000, 0.00000, 270.00000, distance);
    roof[7] = CreateObject(3753, 1483.89490, 2291.94482, 104.72120,   45.00000, 0.00000, 90.00000, distance);
	roof[8] = CreateObject(3753, 1483.95837, 2346.27197, 104.72120,   45.00000, 0.00000, 90.00000, distance);
	roof[9] = CreateObject(3753, 1483.99792, 2400.69092, 104.72120,   45.00000, 0.00000, 90.00000, distance);
	for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(roof); j++ )  SetObjectMaterial(roof[j], i, 4821, "union_las", "lasjmroof", 0xFFFFFFFF);

    water[0] = CreateObject(19529, 1205.54248, 2327.24536, 70.23402,   0.00000, 0.00000, 0.00000, distance);
    water[1] = CreateObject(19529, 1455.52246, 2326.83569, 70.23400,   0.00000, 0.00000, 0.00000, distance);
    water[2] = CreateObject(19529, 1330.53894, 2338.24414, 70.23400,   0.00000, 0.00000, 0.00000, distance);
    for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(water); j++ )  SetObjectMaterial(water[j], i, 18844, "mattextures", "waterclear256", 0);

    bridge[0] = CreateObject(7494, 1240.40674, 2317.29761, 69.88101,   0.00000, 0.00000, 0.00000, distance);
    bridge[1] = CreateObject(7494, 1296.52466, 2317.28320, 69.88100,   0.00000, 0.00000, 0.00000, distance);
	bridge[2] = CreateObject(7494, 1352.64917, 2317.28076, 69.88100,   0.00000, 0.00000, 0.00000, distance);
	bridge[3] = CreateObject(7494, 1408.77356, 2317.36523, 69.88100,   0.00000, 0.00000, 0.00000, distance);
	for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(bridge); j++ )  SetObjectMaterial(bridge[j], i, 8538, "vgsrailroad", "ws_traingravel", 0xFFFFFFFF);

	wall[0] = CreateObject(3753, 1214.03210, 2291.56152, 96.02540,   0.00000, 0.00000, 269.87311, distance);
	wall[1] = CreateObject(3753, 1214.03210, 2377.87671, 96.02540,   0.00000, 0.00000, 270.00000, distance);
	wall[2] = CreateObject(3753, 1456.28088, 2291.27881, 96.02540,   0.00000, 0.00000, 90.00000, distance);
	wall[3] = CreateObject(3753, 1456.16089, 2377.72314, 96.02540,   0.00000, 0.00000, 90.00000, distance);
	wall[4] = CreateObject(3753, 1186.80505, 2347.76050, 71.63940,   0.00000, 0.00000, 180.00000, distance);
	wall[5] = CreateObject(3753, 1182.57617, 2360.05200, 97.33440,   0.00000, 0.00000, 180.00000, distance);
	wall[6] = CreateObject(3753, 1183.68945, 2320.97559, 71.63940,   0.00000, 0.00000, 360.00000, distance);
	wall[7] = CreateObject(3753, 1181.56348, 2308.68652, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[8] = CreateObject(3753, 1163.89221, 2272.84595, 97.33440,   0.00000, 0.00000, 90.00000, distance);
	wall[9] = CreateObject(3753, 1164.86011, 2396.50806, 97.33440,   0.00000, 0.00000, 90.00000, distance);
	wall[10] = CreateObject(3753, 1126.93591, 2255.70581, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[11] = CreateObject(3753, 1127.86047, 2381.40015, 97.33440,   0.00000, 0.00000, 180.00000, distance);
	wall[12] = CreateObject(3753, 1073.52368, 2381.36353, 97.33440,   0.00000, 0.00000, 180.00000, distance);
	wall[13] = CreateObject(3753, 1072.52295, 2255.67017, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[14] = CreateObject(3753, 1054.52966, 2291.75903, 97.33440,   0.00000, 0.00000, 270.00000, distance);
	wall[15] = CreateObject(3753, 1054.48596, 2345.44751, 97.33440,   0.00000, 0.00000, 270.00000, distance);
	wall[16] = CreateObject(3753, 1482.56152, 2320.98682, 71.63940,   0.00000, 0.00000, 0.00000, distance);
	wall[17] = CreateObject(3753, 1491.33215, 2308.91016, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[18] = CreateObject(3753, 1487.03992, 2347.87988, 71.63940,   0.00000, 0.00000, 180.00000, distance);
	wall[19] = CreateObject(3753, 1491.31421, 2360.17676, 97.45928,   0.00000, 0.00000, 180.00000, distance);
	wall[20] = CreateObject(3753, 1509.04089, 2272.43677, 97.33440,   0.00000, 0.00000, 270.00000, distance);
	wall[21] = CreateObject(3753, 1508.99805, 2396.48145, 97.33440,   0.00000, 0.00000, 270.00000, distance);
	wall[22] = CreateObject(3753, 1545.08704, 2255.03784, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[23] = CreateObject(3753, 1599.03101, 2255.09302, 97.33440,   0.00000, 0.00000, 0.00000, distance);
	wall[24] = CreateObject(3753, 1545.12317, 2383.21143, 97.45928,   0.00000, 0.00000, 180.00000, distance);
	wall[25] = CreateObject(3753, 1598.80334, 2383.19556, 97.45928,   0.00000, 0.00000, 180.00000, distance);
	wall[26] = CreateObject(3753, 1617.35913, 2291.79932, 97.33440,   0.00000, 0.00000, 90.00000, distance);
	wall[27] = CreateObject(3753, 1617.28064, 2346.21240, 97.33440,   0.00000, 0.00000, 90.00000, distance);
	wall[28] = CreateObject(6232, 1223.19458, 2334.41479, 90.00000,   0.00000, 0.00000, 90.00000, distance);
	wall[29] = CreateObject(6232, 1466.74915, 2334.41479, 90.00000,   0.00000, 0.00000, 90.00000, distance);
	wall[30] = CreateObject(11353, 1222.13635, 2318.41284, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[31] = CreateObject(11353, 1222.13635, 2369.52930, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[32] = CreateObject(11353, 1211.16211, 2318.41284, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[33] = CreateObject(11353, 1211.16211, 2369.47144, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[34] = CreateObject(11353, 1448.86780, 2367.54907, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[35] = CreateObject(11353, 1448.86780, 2316.36401, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[36] = CreateObject(11353, 1459.54919, 2367.19897, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[37] = CreateObject(11353, 1459.54919, 2316.01343, 95.39310,   0.00000, 0.00000, 0.00000, distance);
	wall[38] = CreateObject(7236, 1218.97583, 2387.65356, 92.56382,   0.00000, 0.00000, 0.00000, distance);
	wall[39] = CreateObject(7236, 1219.06421, 2284.36060, 92.56380,   0.00000, 0.00000, 0.00000, distance);
	wall[40] = CreateObject(7236, 1183.71790, 2365.73340, 117.58068,   0.00000, 0.00000, 0.00000, distance);
	wall[41] = CreateObject(7236, 1181.20776, 2303.47974, 102.60510,   0.00000, 0.00000, 0.00000, distance);
	wall[42] = CreateObject(7236, 1444.96545, 2284.36060, 92.56380,   0.00000, 0.00000, 0.00000, distance);
	wall[43] = CreateObject(7236, 1446.27026, 2384.59937, 92.56380,   0.00000, 0.00000, 0.00000, distance);
	wall[44] = CreateObject(7236, 1493.69934, 2302.59277, 117.58068,   0.00000, 0.00000, 0.00000, distance);
	wall[45] = CreateObject(7236, 1500.56970, 2363.90698, 102.60510,   0.00000, 0.00000, 0.00000, distance);
	wall[46] = CreateObject(19552, 1125.14270, 2340.15967, 33.10840,   0.00000, 45.00000, 90.00000, distance);
    wall[47] = CreateObject(19552, 1097.45850, 2311.46069, 33.10840,   0.00000, -45.00000, 90.00000, distance);
    wall[48] = CreateObject(19552, 1555.13635, 2343.89478, 33.10840,   0.00000, 45.00000, 90.00000, distance);
    wall[49] = CreateObject(19552, 1550.76648, 2314.84302, 33.10840,   0.00000, -45.00000, 90.00000, distance);
	wall[50] = CreateObject(19552, 1161.21106, 2327.90820, 72.83790,   0.00000, 0.00000, 0.00000, distance);
	wall[51] = CreateObject(19552, 1508.93896, 2327.24536, 72.83790,   0.00000, 0.00000, 0.00000, distance);
	wall[52] = CreateObject(19552, 1446.63977, 2327.24536, 10.08276,   0.00000, 90.00000, 0.00000, distance);
	wall[53] = CreateObject(19552, 1223.78296, 2327.24536, 8.85101,   0.00000, 90.00000, 0.00000, distance);
	wall[54] = CreateObject(19552, 1036.21216, 2327.94141, 72.83790,   0.00000, 0.00000, 0.00000, distance);
	wall[55] = CreateObject(19552, 1097.42834, 2233.50024, 77.23640,   0.00000, 0.00000, 0.00000, distance);
	wall[56] = CreateObject(19552, 1092.05518, 2295.98706, 14.77276,   0.00000, 90.00000, 90.00000, distance);
	wall[57] = CreateObject(19552, 1124.73743, 2418.10303, 77.23640,   0.00000, 0.00000, 0.00000, distance);
	wall[58] = CreateObject(19552, 1633.92627, 2327.24536, 72.83790,   0.00000, 0.00000, 0.00000, distance);
	wall[59] = CreateObject(19552, 1561.41309, 2237.33838, 77.23640,   0.00000, 0.00000, 0.00000, distance);
	wall[60] = CreateObject(19552, 1565.21570, 2421.48242, 77.23640,   0.00000, 0.00000, 0.00000, distance);
	wall[61] = CreateObject(19545, 1216.22607, 2326.42334, 95.21021,   0.00000, 0.00000, 0.00000, distance);
	wall[62] = CreateObject(19545, 1454.56360, 2336.38257, 95.21021,   0.00000, 0.00000, 0.00000, distance);
	wall[63] = CreateObject(18754, 1081.10046, 2336.32788, 95.34212,   0.00000, 0.00000, 0.00000, distance);
	wall[64] = CreateObject(18754, 1590.07556, 2339.96143, 95.34212,   0.00000, 0.00000, 0.00000, distance);

    for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(wall); j++ )  SetObjectMaterial(wall[j], i, 8532, "tikigrass", "swimpoolbtm1_128", 0xFFFFFFFF);

    new corners[2];
    corners[0] = CreateObject(18754, 1331.01257, 2388.53809, -18.24360,   0.00000, 90.00000, 90.00000, distance);
	corners[1] = CreateObject(18754, 1331.58765, 2282.10425, -18.24357,   0.00000, 90.00000, 90.00000, distance);
    for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(corners); j++ )  SetObjectMaterial(corners[j], i, 8532, "tikigrass", "swimpoolbtm1_128", 0xFFFFFFFF);

    new headers_0[4], headers_1[4];
    
    /// ATTACKERS
   	headers_0[0] = CreateObject(16302, 1217.73242, 2388.47412, 123.08780,   0.00000, 0.00000, 0.00000, distance); // YELLOW
    headers_0[1] = CreateObject(16302, 1217.81360, 2283.91919, 122.15585,   0.00000, 0.00000, 0.00000, distance); // YELLOW
    headers_0[2] = CreateObject(16302, 1178.29248, 2304.09375, 133.00850,   0.00000, 0.00000, 359.38477, distance); // YELLOW
	headers_0[3] = CreateObject(16302, 1183.61914, 2366.16333, 146.74991,   0.00000, 0.00000, 0.00000, distance); // YELLOW
    for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(headers_0); j++ )  SetObjectMaterial(headers_1[j], i, 8839, "vgsecarshow", "lightpurple2_32", 0xFFFFFFFF);

	/// DEFENDERS
	headers_1[0] = CreateObject(16302, 1444.50098, 2384.38159, 123.08780,   0.00000, 0.00000, 0.00000, distance); // BLUE
	headers_1[1] = CreateObject(16302, 1443.36206, 2283.91919, 123.08780,   0.00000, 0.00000, 0.00000, distance); // BLUE
	headers_1[2] = CreateObject(16302, 1503.25256, 2364.17334, 133.37338,   0.00000, 0.00000, 0.00000, distance); // BLUE
	headers_1[3] = CreateObject(16302, 1494.81567, 2302.57397, 147.04213,   0.00000, 0.00000, 0.00000, distance); // BLUE
    for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(headers_0); j++ )  SetObjectMaterial(headers_0[j], i, 8538, "vgsrailroad", "concreteyellow256 copy", 0xFFFFFFFF);
    
	castle_object[0] = CreateObject(18876, 1107.77197, 2278.66699, 77.04044,   0.00000, 0.00000, 0.00000, distance); // OBJECT
	castle_object[1] = CreateObject(18876, 1563.02966, 2280.79297, 77.04040,   0.00000, 0.00000, 0.00000, distance); // OBJECT
	castle_object[2] = CreateObject(7586, 1563.11792, 2280.69727, 74.49250,   0.00000, 0.00000, 0.00000, distance);
	castle_object[3] = CreateObject(7586, 1107.65369, 2278.77344, 74.49250,   0.00000, 0.00000, 0.00000, distance);

	for( i = 0; i < 15; i++ ) for( j = 0; j < sizeof(castle_object); j++ )  SetObjectMaterial(castle_object[j], i, 3977, "lanriver", "ws_hextile", 0xFFFFFF00);

	//new Float:up = 6.0;
	// Create3DTextLabel("{FFF000}MW's{FFFFFF} TOWER\nHealth: 1000\n{FFF000}Destroy it to capture the castle!", -1, 1107.77197, 2278.66699, 77.04044+up, 500.0, 0, 0);
	// Create3DTextLabel("{FFF000}DF's{FFFFFF} TOWER\nHealth: 1000\n{FFF000}Destroy it to capture the castle!", -1, 1563.02966, 2280.79297, 77.04040+up, 500.0, 0, 0);

	///////////////////////////////////////////////////////////////////////////////////
	CreateObject(1608, 1237.84741, 2296.09912, 69.99123,   0.00000, 0.00000, 53.01648);
	CreateObject(1608, 1256.15747, 2297.20605, 69.99120,   0.00000, 0.00000, 191.37164);
	CreateObject(1608, 1257.15454, 2360.59033, 69.99123,   0.00000, 0.00000, 53.01648);
	CreateObject(1608, 1241.01843, 2371.95435, 69.99120,   0.00000, 0.00000, 191.37164);
	CreateObject(1608, 1438.46094, 2360.21191, 69.99123,   0.00000, 0.00000, 53.01648);
	CreateObject(1608, 1416.98120, 2375.86035, 69.99120,   0.00000, 0.00000, -75.00000);
	CreateObject(1608, 1401.72363, 2301.12524, 69.99120,   0.00000, 0.00000, -75.00000);
	CreateObject(1608, 1424.58081, 2305.37305, 69.99123,   0.00000, 0.00000, 53.01648);
	CreateObject(1608, 1364.45374, 2308.10083, 70.26817,   0.00000, 0.00000, 137.47807);
	CreateObject(1608, 1330.12939, 2293.97681, 70.26817,   0.00000, 0.00000, 70.58596);
	CreateObject(1608, 1291.66187, 2305.27832, 69.99120,   0.00000, 0.00000, -75.00000);
	CreateObject(1608, 1384.55261, 2371.39111, 69.99120,   0.00000, 0.00000, 43.74715);
	CreateObject(1608, 1352.26270, 2365.82813, 69.99120,   0.00000, 0.00000, 89.39005);
	CreateObject(1608, 1320.34009, 2373.32935, 69.99123,   0.00000, 0.00000, 53.01648);
	CreateObject(1608, 1287.64551, 2367.67651, 70.26817,   0.00000, 0.00000, 137.47807);
	////////////////////////////////////////////////////////////////////////////////////////////////////

	new query[200];
    mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `maps` ORDER BY `ID` DESC LIMIT 1");
 	mysql_tquery(Base, query, "LoadMapsCount");
 	
 	mysql_format(Base, query, sizeof(query), "UPDATE `maps` SET `controlled`='0',`tnx`='0' WHERE `tnx` < '%d'", gettime());
	mysql_tquery(Base, query, "", "");
 	
 	#if debug_mode == 0
	if (_:DiscordChannel == 0)
	{
		DiscordChannel = DCC_FindChannelById("612998988609880076");
		
		new __action[256], y, m, d, h, s, o;
		TimestampToDate(gettime(), y, m, d, h, o, s, 3);
		format(__action, sizeof __action, "%d-%02d-%02d %02d:%02d Started... (Last Update: "SERVER_UPDATE")", y, m, d, h, o);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		DCC_SetBotPresenceStatus(DO_NOT_DISTURB);
		DCC_SetBotActivity("Grand Theft Auto San Andreas");
	}
	#endif
	
	return 1;
}

fun LoadMapsCount()
{
    if(cache_num_rows())
    {
        cache_get_value_name_int(0, "ID", maps);
        printf("+++++++++++++++++++++++++++++");
        printf("%d maps are loaded!", maps);
        printf("+++++++++++++++++++++++++++++");
    }
    else
	{
	    printf("-----------------------------");
		printf("WARNING: No maps are loaded!");
		printf("-----------------------------");
	}
    return 1;
}

enum pInfo
{
	pAccountID,
	pIP[16],
	pCurIP[16],
	pHumanClassesUnlocked_0,
	pHumanClassesUnlocked_1,
	pZombieClassesUnlocked_0,
	pZombieClassesUnlocked_1,
	pSettings, // 4
	pKills,
	pPlayerKills,
	pPlayerKillsBack,
	KickBack,
	pKillstreakMax,
	RoundsWin,
	DuelsWin,
	DuelsLose,
    pClass[4],
    Float:ReinPos[3],
    Float:FlesherPos[3],
    pKey[65],
	IsBurned[2],
	bool: IsCursed,
	pAttID[8],
	Float:pAttIDPos[36],
    pPass[65],
    pRefID,
    pEmail[96],
    pSalt[65],
    pSecret[64],
    pGPCI[64],
    pRegion[64],
    bool: pIgnore[MAX_PLAYERS],
    bool: pPm,
    bool: IsPlayerInfected,
    bool: IsPlayerAdvancedInfected,
    bool: RadioctiveField,
    InfectedTimer,
    BleedingTimer,
    hasInfinitiveAmmo,
    bool:hasBleedEffect,
    PoisionTimer,
    bool: pLogged,
    bool: ShowNick,
    pXP,
    AbilityUsed,
    pAdmin,
    pRank,
	pClan,
	pClanName[6],
	ZombieCount,
	pClanRank,
	pClanWarns,
	pSign[17],
    pVip,
    Float:pBalance,
    pVipSkin,
    pVipTime,
    pLang,
    Killstreak,
	Evacuated,
	bool: aDuty,
	Boxes,
	AdvancedBoxes,
	UnlimitedBoxes,
	PortalsUsed,
	bool: Stung,
	SlowWalk,
	bool: LegBreak,
	bool: TaserReady,
	bool: Tasered,
	Blidness,
	BlidnessTimer,
	bool: Poisioned,
	pAdminHiden,
	Muted,
	Warnings,
	GangRequest,
	bool:AntiSeeker,
	bool:AntiFreeze,
	bool:AntiRadioctive,
	bool:AntiBuring,
	bool:AntiLegBreaks,
	bool:AntiScreamer,
	bool:AntiSpider,
	bool:AntiBlind,
	bool:Helmet,
	bool:Fearlessness,
	bool:Cursed,
	TimesDamage,
	CanSpyPM,
	CanCheckCMD,
	ConnectedMap,
	p_Country[45],
	p_ISP[45],
	p_Port[6],
	bool:GunJammerAttack,
    bool:HeroField,
    GangBanned,
    Jailed,
    RealName[MAX_PLAYER_NAME+1],
    UserName[MAX_PLAYER_NAME+1],
    Accelerated,
 	pRegDate,
 	pLastIP[16],
 	bool:pIndentety,
 	pPort,
 	IsDefender,
 	DefenderSorryTime,
 	AdminActivity[5],
 	PlayerActivity[4],
 	FireBullet[2],
 	//LeatherFace[2],
	eventMember,
	doubleDamage,
	SessionOnline[3],
	pChannel,
	pQuickSet,
	e_Days,
	e_PrevLogin,
	e_Avoid[46],
	e_CryOfDamage,
	pUpgPoints,
	pLastGangJoin,
	checkForUnsleep,
	AbilityAffectedID,
	CheckForProtect,
	Float:PacketsLoss,
	AIM_CHECK,
	isInSelling[MAX_SELLING_INFO],
	isInBying[2],
	itemsInShop,
	pShopPage,
	pShopFilter[128],
	pNewAttachments[32],
	bool:pWasGangAffected,
	pShowWeapon[2],
	resetEasyMissions,
	resetMediumMissions,
	resetHardMissions,
	pTeam,
	pSkin,
	pYouTuber,
	totalPlayersKilledInGW,
	pCardSet,
	pAntisonRound,
	bool:pInGangMatch,
	Float:pRestTime,
	Float:pAdditionalDamage,
};

new Player[MAX_PLAYERS][pInfo];

static const ShopPrices[] = {50, 90, 100, 60, 60, 10, 60, 10, 100, 70};

/// ACHIEVEMENTS
static const achTrnsl[][][] =
{
	{
	    "{ffe6b3}Title\t{ffe6b3}Description\n{FFFFFF}", 					// 0
	    "Unlock all achievements", 											// 1
	    "Use your class ability %d time(s)", 								// 2
	    "Run %.3f kilometers",                                            // 3
	    "Evacuate with 1 HP",                                              // 4
		"Kill %d human(s)",                                               // 5
		"Kill %d zombie(s)",                                              // 6
     	"Kill %d player(s)",                                              // 7
     	"Collect %d meats(s)",											// 8
     	"Achieve %d killstreak(s)",                                       // 9
     	"Cure %d human(s)",                                               // 10
     	"Win %d duel(s)",                                                 // 11
     	"Die from a zombie on a %d killstreaks",                          // 12
     	"Die %d time(s)",                                                    // 13
     	"Report %d cheater(s)",                                          	// 14
     	"Make %d purchases in shop",                                      // 15
     	"Become the last survivor and evacuate",                          // 16
		"Win %d round(s) as human",                              			// 17
        "Play %d hour(s) in total",                                         // 18
        "Do not stop the whole round playing as a human",                 // 19
        "Get %d consecutive kill(s) in 5 second(s)",                          // 20
        "Play %d hour(s) in 1 session"                                      // 21
	},
	{
	   "{ffe6b3}Title\t{ffe6b3}Description\n{FFFFFF}", 					// 0
	    "Unlock all achievements", 									// 1
	    "Use your class ability %d time(s)", 								// 2
	    "Run %.3f kilometers",                                            // 3
	    "Evacuate with 1 HP",                                              // 4
		"Kill %d human(s)",                                               // 5
		"Kill %d zombie(s)",                                              // 6
     	"Kill %d player(s)",                                              // 7
     	"Collect %d meats(s)",											// 8
     	"Achieve %d killstreak(s)",                                       // 9
     	"Cure %d human(s)",                                               // 10
     	"Win %d duel(s)",                                                 // 11
     	"Die from a zombie on a %d killstreaks",                          // 12
     	"Die %d time",                                                    // 13
     	"Report %d cheater(s)",                                          	// 14
     	"Make %d purchases in shop",                                      // 15
     	"Become the last survivor and evacuate",                          // 16
		"Win %d rounds as human",                              			// 17
        "Play %d hours in total",                                         // 18
        "Do not stop the whole round playing as a human",                 // 19
        "Get %d consecutive kills in 5 seconds",                          // 20
        "Play %d hours in 1 session"                                      // 21
	},
	{
	    "{ffe6b3}Title\t{ffe6b3}Description\n{FFFFFF}", 					// 0
	    "Unlock all achievements", 									// 1
	    "Use your class ability %d time(s)", 								// 2
	    "Run %.3f kilometers",                                            // 3
	    "Evacuate with 1 HP",                                              // 4
		"Kill %d human(s)",                                               // 5
		"Kill %d zombie(s)",                                              // 6
     	"Kill %d player(s)",                                              // 7
     	"Collect %d meats(s)",											// 8
     	"Achieve %d killstreak(s)",                                       // 9
     	"Cure %d human(s)",                                               // 10
     	"Win %d duel(s)",                                                 // 11
     	"Die from a zombie on a %d killstreaks",                          // 12
     	"Die %d time",                                                    // 13
     	"Report %d cheater(s)",                                          	// 14
     	"Make %d purchases in shop",                                      // 15
     	"Become the last survivor and evacuate",                          // 16
		"Win %d rounds as human",                              			// 17
        "Play %d hours in total",                                         // 18
        "Do not stop the whole round playing as a human",                 // 19
        "Get %d consecutive kills in 5 seconds",                          // 20
        "Play %d hours in 1 session"                                      // 21
	}
};

static const achNames[][][] =
{
	{
	    "{66ccff}Achievements",
	    "The Conqueror",
		"Trainee", 					"Semi Experienced", 	"Experienced",
	    "Jogging", 					"Runner",				"Olympic Champion",
	    "Lucky",					"Inviolable",			"Cheat Death",
	    "Maniac",					"Serial Maniac",		"Jack The Ripper",
	    "Conductor",				"Undead Slayer",		"Saint",
		"Death's Child",
		"Collector", 				"Butcher", 				"Madman",
		"Blood Lover",				"Meat Lover",			"The Killer Machine",
		"Nurse",					"Medic",				"Doctor",
		"Impudent",					"Fight lover",			"Criminal Authority",
		"Shock",
		"Risen From The Grave",     "I'm IMMORTAL",			"Do Not Even Try",
		"Trust But Check",			"Exemplary",			"Law-Abiding",
		"Amateur",					"Shopaholic",			"Money In Nowhere",
		"Eternal Void",				"Winner",
		"Fan",						"Gamer",				"Exanimate",
		"Adrenaline",				"Meat Grinder",
		"No Time To Rest",			"Before Turning Blue"
	},
	{
	    "{66ccff}Achievements",
	    "The Conqueror",
		"Trainee", 					"Semi Experienced", 	"Experienced",
	    "Jogging", 					"Runner",				"Olympic Champion",
	    "Lucky",					"Inviolable",			"Cheat Death",
	    "Maniac",					"Serial Maniac",		"Jack The Ripper",
	    "Conductor",				"Undead Slayer",		"Saint",
		"Death's Child",
		"Collector", 				"Butcher", 				"Madman",
		"Blood Lover",				"Meat Lover",			"The Killer Machine",
		"Nurse",					"Medic",				"Doctor",
		"Impudent",					"Fight lover",			"Criminal Authority",
		"Shock",
		"Risen From The Grave",     "I'm IMMORTAL",			"Do Not Even Try",
		"Trust But Check",			"Exemplary",			"Law-Abiding",
		"Amateur",					"Shopaholic",			"Money In Nowhere",
		"Eternal Void",				"Winner",
		"Fan",						"Gamer",				"Exanimate",
		"Adrenaline",				"Meat Grinder",
		"No Time To Rest",			"Before Turning Blue"
	},
	{
	    "{66ccff}Achievements",
	    "The Conqueror",
		"Trainee", 					"Semi Experienced", 	"Experienced",
	    "Jogging", 					"Runner",				"Olympic Champion",
	    "Lucky",					"Inviolable",			"Cheat Death",
	    "Maniac",					"Serial Maniac",		"Jack The Ripper",
	    "Conductor",				"Undead Slayer",		"Saint",
		"Death's Child",
		"Collector", 				"Butcher", 				"Madman",
		"Blood Lover",				"Meat Lover",			"The Killer Machine",
		"Nurse",					"Medic",				"Doctor",
		"Impudent",					"Fight lover",			"Criminal Authority",
		"Shock",
		"Risen From The Grave",     "I'm IMMORTAL",			"Do Not Even Try",
		"Trust But Check",			"Exemplary",			"Law-Abiding",
		"Amateur",					"Shopaholic",			"Money In Nowhere",
		"Eternal Void",				"Winner",
		"Fan",						"Gamer",				"Exanimate",
		"Adrenaline",				"Meat Grinder",
		"No Time To Rest",			"Before Turning Blue"
	}
};

enum achInfo
{
	ach_CONQUEROR = 0,
	ach_USED_ABILITY,    		// READY
	ach_SURVIVED,        		// READY
	ach_KILLED_HUMANS,   		// READY
	ach_KILLED_ZOMBIE,   		// READY
	ach_KILLED_PLAYERS,  		// READY
	ach_COLLECTED_MEATS, 		// READY
	ach_ACHIEVED_KILLSTREAK,    // READY
	ach_CURED_HUMANS,    		// READY
	ach_DUELS_WIN,       		// READY
	ach_SHOCK,                  // READY
	ach_DIED_TIMES,      		// READY
	ach_REPORTED_TIMES,  		// READY
	ach_SHOP_TIMES,      		// READY
	ach_VOID,                   // READY
	ach_WINNER,         		// READY
	ach_HOURS_PLAYED,           // READY
	ach_PULSATION,              // READY
	ach_KILL_IN_5_SEC,          // READY
	ach_SESSION_TIME,           //
    Float:ach_RUNNED,           // READY
    
	ach_BMask[2],                  // SAVES ONLY
	ach_Counter,                // FOR TEMP RESULTS
	ctg_time[2],                // FOR TEMP RESULTS

	Seconds,                    // FOR TEMP RESULTS
	Minutes,                    // FOR TEMP RESULTS
	Hours,                      // FOR TEMP RESULTS
};
new Achievements[MAX_PLAYERS][achInfo];

static const achEndProgress[] =
{
	1,
	1, 500, 1000, 				// Use ability
	2, 2, 2,  					// Run
	3, 10, 20,  				// Survive
	10, 100, 1000, 				// Kill humans
	10, 100, 1000,  			// Kill zombies
	10000, 						// Death's child
	100, 1000, 5000, 			// Collect meats
	5, 50, 100,     			// Killstreaks
	1, 50, 100,    				// Cure
	10, 100, 250,   			// Win duels
	99,              			// Die from a zombie on a 99 killstreaks
	10, 100, 1000,  			// Die
	10, 50, 100,    			// Report a hacker
	25, 50, 100,    			// Make purchases
	1,              			// Become the last survivor and evacuate
 	300,            			// Win 300 rounds as human
 	24, 300, 650,   			// Play hours
 	1, 5,           			// Pulsation, Killer
 	1, 8           				// Session time
};

static const achXPReward[] =
{
	10000,
	5, 		500, 	1000, 		// Use ability
	1000, 	5000, 	10000, 		// Run
	300,  	2000, 	4500, 		// Survive
	20, 	300, 	2000,   	// Kill humans
	20,     300,    2000,   	// Kill zombies
	5000,                       // Death's child
	15,     2000,   5000,   	// Collect meats
	10, 	500, 	1000,   	// Killstreaks
	10,     100,    1000, 		// Cure
	50,     800,    2000,   	// Win duels
	5000,                   	// Die from a zombie on a 99 killstreaks
	100,    1000,    1000,  	// Die
	100, 	1000,    2000,  	// Report a hacker
	200,    1000,    2000,  	// Make purchases
	200,    					// Become the last survivor and evacuate
	3000, 						// Win 300 rounds as human
	2000,   5000,   30000, 		// Play hours
	5000, 	800,    			// Pulsation, Killer
	1000,   5000    			// Session time
};

static const achIndexes[] =
{
	1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7,
	8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12,
	13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 17,
	18, 18, 18, 19, 20, 21, 21
};
/*
	ach_SURVIVED,        		// READY
*/

stock AchievementAddProgress(playerid, type)
{
	++Achievements[playerid][achInfo:type];
	switch(type)
	{
	    case ach_CONQUEROR: { UnlockAchievement(playerid, 0); return 1; }
	    case ach_USED_ABILITY:
	    {
			switch(Achievements[playerid][ach_USED_ABILITY])
			{
			    case 5:    { UnlockAchievement(playerid, 1); return 1; }
			    case 500:  { UnlockAchievement(playerid, 2); return 1; }
			    case 1000: { UnlockAchievement(playerid, 3); return 1; }
	        }
			return 1;
	    }
	    case ach_RUNNED:
	    {
	        if(Achievements[playerid][ach_RUNNED] >= 10.000 && GetBitSlot(Achievements[playerid][ach_BMask][0], 4) <= 0) { UnlockAchievement(playerid, 4); return 1; }
	        if(Achievements[playerid][ach_RUNNED] >= 50.000 && GetBitSlot(Achievements[playerid][ach_BMask][0], 5) <= 0) { UnlockAchievement(playerid, 5); return 1; }
	        if(Achievements[playerid][ach_RUNNED] >= 200.000 && GetBitSlot(Achievements[playerid][ach_BMask][0], 6) <= 0) { UnlockAchievement(playerid, 6); return 1; }
			return 1;
	    }
	    case ach_SURVIVED:
	    {
	        switch(Achievements[playerid][ach_SURVIVED])
			{
			    case 3:    { UnlockAchievement(playerid, 7); return 1; }
			    case 10:   { UnlockAchievement(playerid, 8); return 1; }
			    case 20:   { UnlockAchievement(playerid, 9); return 1; }
	        }
			return 1;
	    }
	    case ach_KILLED_HUMANS:
	    {
	        switch(Achievements[playerid][ach_KILLED_HUMANS])
			{
			    case 10:    { UnlockAchievement(playerid, 10); return 1; }
			    case 100:   { UnlockAchievement(playerid, 11); return 1; }
			    case 1000:  { UnlockAchievement(playerid, 12); return 1; }
	        }
			return 1;
	    }
	    case ach_KILLED_ZOMBIE:
	    {
	        switch(Achievements[playerid][ach_KILLED_ZOMBIE])
			{
			    case 10:    { UnlockAchievement(playerid, 13); return 1; }
			    case 100:   { UnlockAchievement(playerid, 14); return 1; }
			    case 1000:  { UnlockAchievement(playerid, 15); return 1; }
	        }
			return 1;
	    }
	    case ach_KILLED_PLAYERS:
	    {
	        switch(Player[playerid][pKills])
			{
			    case 10000:  { UnlockAchievement(playerid, 16); return 1; }
			}
			return 1;
	    }
	    case ach_COLLECTED_MEATS:
	    {
	        switch(Achievements[playerid][ach_COLLECTED_MEATS])
			{
			    case 100:   { UnlockAchievement(playerid, 17); return 1; }
			    case 1000:  { UnlockAchievement(playerid, 18); return 1; }
			    case 5000:  { UnlockAchievement(playerid, 19); return 1; }
			}
			return 1;
	    }
	    case ach_ACHIEVED_KILLSTREAK:
	    {
	        switch(Player[playerid][Killstreak])
			{
			    case 5:    { UnlockAchievement(playerid, 20); return 1; }
			    case 50:   { UnlockAchievement(playerid, 21); return 1; }
			    case 100:  { UnlockAchievement(playerid, 22); return 1; }
			}
			return 1;
	    }
	    case ach_CURED_HUMANS:
	    {
	        switch(Achievements[playerid][ach_CURED_HUMANS])
			{
			    case 1:    { UnlockAchievement(playerid, 23); return 1; }
			    case 50:   { UnlockAchievement(playerid, 24); return 1; }
			    case 100:  { UnlockAchievement(playerid, 25); return 1; }
			}
			return 1;
	    }
	    case ach_DUELS_WIN:
	    {
	        switch(Player[playerid][DuelsWin])
			{
			    case 10:    { UnlockAchievement(playerid, 26); return 1; }
			    case 100:   { UnlockAchievement(playerid, 27); return 1; }
			    case 250:   { UnlockAchievement(playerid, 28); return 1; }
			}
			return 1;
	    }
	    case ach_SHOCK: { UnlockAchievement(playerid, 29); return 1; }
	    case ach_DIED_TIMES:
	    {
	        switch(Achievements[playerid][ach_DIED_TIMES])
			{
			    case 10:    { UnlockAchievement(playerid, 30); return 1; }
			    case 100:   { UnlockAchievement(playerid, 31); return 1; }
			    case 1000:  { UnlockAchievement(playerid, 32); return 1; }
			}
			return 1;
	    }
	    case ach_REPORTED_TIMES:
	    {
	        switch(Achievements[playerid][ach_REPORTED_TIMES])
			{
			    case 10:    { UnlockAchievement(playerid, 33); return 1; }
			    case 50:    { UnlockAchievement(playerid, 34); return 1; }
			    case 1000:  { UnlockAchievement(playerid, 35); return 1; }
			}
			return 1;
	    }
	    case ach_SHOP_TIMES:
	    {
	        switch(Achievements[playerid][ach_SHOP_TIMES])
			{
			    case 25:    { UnlockAchievement(playerid, 36); return 1; }
			    case 50:    { UnlockAchievement(playerid, 37); return 1; }
			    case 100:   { UnlockAchievement(playerid, 38); return 1; }
			}
			return 1;
	    }
	    case ach_VOID: { UnlockAchievement(playerid, 39); return 1; }
	    case ach_WINNER:
	    {
	    	switch(Player[playerid][RoundsWin])
			{
			    case 300: { UnlockAchievement(playerid, 40); return 1; }
			}
			return 1;
	    }
	    case ach_HOURS_PLAYED:
	    {
	    	switch(Achievements[playerid][Hours])
			{
			    case 24:    { UnlockAchievement(playerid, 41); return 1; }
			    case 300:   { UnlockAchievement(playerid, 42); return 1; }
			    case 650:   { UnlockAchievement(playerid, 43); return 1; }
			}
			return 1;
	    }
	    case ach_PULSATION: { UnlockAchievement(playerid, 44); return 1; }
	    case ach_KILL_IN_5_SEC: { UnlockAchievement(playerid, 45); return 1; }
	    case ach_SESSION_TIME:
	    {
	    	switch(Achievements[playerid][ach_SESSION_TIME])
			{
			    case 2:    { UnlockAchievement(playerid, 46); return 1; }
			    case 8:    { UnlockAchievement(playerid, 47); return 1; }
			}
			return 1;
	    }
	}
	return 1;
}

stock UnlockAchievement(playerid, index, bool:giveEXP = true)
{
    //index++;
    if(index > sizeof(achNames[])) return 0;
    //if(achEndProgress[index-1] >= 2 && GetAchievementProgress(playerid,index-1) < achEndProgress[index-1]) return 0;
	switch(index)
	{
	    case 0..30:  if(GetBitSlot(Achievements[playerid][ach_BMask][0], index) >= 1) return 0;
	    case 31..64: if(GetBitSlot(Achievements[playerid][ach_BMask][1], index-31) >= 1) return 0;
	}

    switch(index)
	{
	    case 0..30:  SetBitSlot(Achievements[playerid][ach_BMask][0], index, 1);
	    case 31..64: SetBitSlot(Achievements[playerid][ach_BMask][1], index-31, 1);
	}
	
	if(giveEXP)
	{
		foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][171], Player[playerid][UserName], achNames[Player[i][pLang]][index+1], achXPReward[index]);
		Player[playerid][pXP] += achXPReward[index];

		switch(Player[playerid][pLang])
	    {
			case 0: GameTextForPlayer(playerid,"~y~NEW Achievement", 4000, 5);
	        case 1: GameTextForPlayer(playerid,RusToGame("~y~НОВОЕ ДОСТИЖЕНИЕ"), 4000, 5);
	        case 2: GameTextForPlayer(playerid,"~y~NUEVO logro", 4000, 5);
		}

	    #if debug_mode == 0
		new y, m, d, h, i, s, msg[164];
		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		DiscordChannel = DCC_FindChannelById("680542440587001915");
		format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got an achievement (%s) (+%d)\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], achNames[0][index], achXPReward[index-1]);
		DCC_SendChannelMessageEx(DiscordChannel, msg);
		#endif
	}
	return 1;
}

enum ac_req
{
	ac_reason[16],
	ac_type,
	ac_additional,
	ac_time,
	Float:ac_pl
};
new AC_Requests[MAX_PLAYERS][ac_req];

#define ADMIN_CHANNEL 9999
#define DIALOG_CHANNELS 10345

stock UpdateSign(playerid)
{
	new query[144];
    mysql_format(Base, query, sizeof(query), "UPDATE `signs` SET `EXP`='%d',`VIP`='%d',`Admin`='%d' WHERE `Sign` = '%e' AND `build`='"SERVER_BUILD"'",
	Player[playerid][pXP],
	Player[playerid][pVip],
	Player[playerid][pAdmin],
	Player[playerid][pSign]);
	mysql_tquery(Base, query, "", "", "");
}

fun RandomMessages()
{
    new randomMsg = random(sizeof(randomMessages[]));
    foreach(Player, i) SendClientMessage(i, -1, randomMessages[Player[i][pLang]][randomMsg]);
}

fun OnGameModeExit()
{
    for( new i; i < 29; i++ )
	{
        Delete3DTextLabel(GangHouseText[i]);
        Delete3DTextLabel(GangHouseExitText[i]);
	}

    UnloadFilterScript(Map[m_FSMapName]);
    if(strlen(EventFilterScript) >= 1) UnloadFilterScript(EventFilterScript);
    
    if(IsValidObject(mapGate))
	{
		DestroyObject(mapGate);
		mapGate = INVALID_OBJECT_ID;
	}
	
	if(IsValidObject(mapFlag))
	{
		DestroyObject(mapFlag);
		mapFlag = INVALID_OBJECT_ID;
	}
	
	if(IsValidObject(mapGate2))
	{
		DestroyObject(mapGate2);
		mapGate2 = INVALID_OBJECT_ID;
	}
    
	mysql_close(Base);
	foreach(Player, i)
	{
	    TextDrawHideForPlayer(i, XP[i]);
	    
	    for( new j; j < sizeof(DisplayAlerts); j++ )
		{
			TextDrawHideForPlayer(i, DisplayAlerts[j][i]);
			TextDrawDestroy(DisplayAlerts[j][i]);
	    }
	    
	    for( new j; j < sizeof(DisplayInfo); j++ )
		{
			TextDrawHideForPlayer(i, DisplayInfo[j][i]);
			TextDrawDestroy(DisplayInfo[j][i]);
	    }
	    
	    TextDrawHideForPlayer(i, AliveInfo[i]);
	    TextDrawHideForPlayer(i, FPS_Info[i]);
	    
	    TextDrawHideForPlayer(i, UntillEvac[0][i]);
	    TextDrawHideForPlayer(i, UntillEvac[0][i]);
	    
		TextDrawDestroy(XP[i]);
		TextDrawDestroy(AliveInfo[i]);
		TextDrawDestroy(FPS_Info[i]);
		TextDrawDestroy(UntillEvac[0][i]);
	    TextDrawDestroy(UntillEvac[1][i]);
		
		
	    TextDrawHideForPlayer(i, Infected[i]);
		TextDrawDestroy(Infected[i]);
		TextDrawHideForPlayer(i, SpawnProtection[i]);
		TextDrawDestroy(SpawnProtection[i]);
		for( new j; j < 5; j++ )
		{
	    	TextDrawHideForPlayer(i, ServerIntro[i][j]);
			TextDrawDestroy(ServerIntro[i][j]);
		}
		
		TextDrawHideForPlayer(i, Poision[i]);
		TextDrawDestroy(Poision[i]);
		
		TextDrawHideForPlayer(i, GreenScreen[i]);
		TextDrawDestroy(GreenScreen[i]);
		
		TextDrawHideForPlayer(i, AIR[i]);
		TextDrawDestroy(AIR[i]);
		TextDrawHideForPlayer(i, Blidnes[i]);
		TextDrawDestroy(Blidnes[i]);
		TextDrawHideForPlayer(i, Stun[i]);
		TextDrawDestroy(Stun[i]);
		TextDrawHideForPlayer(i, Blind[i]);
		TextDrawDestroy(Blind[i]);
    }
    
	TextDrawHideForAll(TimeLeft);
	TextDrawDestroy(TimeLeft);
	return 1;
}

Float:GetXYInFrontOfPlayer(playerid, &Float:q, &Float:w, Float:distance)
{
	new Float:a;
	GetPlayerPos(playerid, q, w, a);
	if (GetPlayerState(playerid) == PLAYER_STATE_DRIVER) GetVehicleZAngle(GetPlayerVehicleID(playerid), a);
	else GetPlayerFacingAngle(playerid, a);
	q += (distance * floatsin(-a, degrees));
	w += (distance * floatcos(-a, degrees));
	return a;
}

fun CancelQuiz()
{
	if(QuizStarted)
	{
    	foreach(Player, i) SendClientMessage(i, -1, serverLang[Player[i][pLang]][176]);
    	QuizStarted = false;
    	if(QuizIndex > -1) QuizIndex = -1;
	}
	QuizStarted = false;
	if(QuizIndex > -1) QuizIndex = -1;
	return 1;
}

stock randomString(strDest[], strLen = 15)
{
    while(strLen--) strDest[strLen] = CodeLetters[random(sizeof(CodeLetters))];
}

fun RandomQuiz()
{
    /*if(random(4) == 0)
    {
        foreach(Player, i)
		{
		    lotteryNumber[i] = -1;
			SendClientMessage(i, -1, serverLang[Player[i][pLang]][177]);
	    }

	    lotteryStarted = true;
	    LotteryTime = 60;
	    LotteryWon = 1+random(49);
    }
	else*/
	{
	    if(!QuizStarted)
	    {
	        QuizStarted = true;
	        QuizType = random(4);
	        QuizXp = 1 + random(39);
			switch(QuizType)
			{
			    case 0:
			    {
			        //new string[10];
			        strmid(QuizTextAnswer, "", 0, 10);
			        randomString(QuizTextAnswer, 10);

					foreach(Player, i)
			        {
			            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
			            SendClientMessageFormat(i, 0xC659B6FF, serverLang[Player[i][pLang]][172], QuizXp, QuizTextAnswer);
			            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
			        }
				}
				case 1:
				{
				    if(playerOnline >= 2)
				    {
					    new pl = random(MAX_PLAYERS);
						while(!IsPlayerConnected(pl) || pl == 0) { pl = random(MAX_PLAYERS); }
						QuizRealAnswer = pl;
					    foreach(Player, i)
				        {
				            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
				            SendClientMessageFormat(i, 0xC659B6FF, serverLang[Player[i][pLang]][175], QuizXp, Player[pl][UserName]);
				            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
				        }
					}
				}
				case 2:
				{
				    QuizRealAnswer = 0;
				    new tx[32];
				    for( new a, j; a < 5; a++ )
				    {
				        j = random(2);
				        if(j == 0)
				        {
				            new num = 1 + random(99), n[3];
				            if(a >= 1) strins(tx, " + ", strlen(tx));
				            valstr(n, num);
				            strins(tx, n, strlen(tx));
				            QuizRealAnswer += num;
				        }
				        else
				        {
				            new num = 1 + random(99), n[3];
				            if(a == 0) strins(tx, "- ", 0);
							else strins(tx, " - ", strlen(tx));
							valstr(n, num);
				            strins(tx, n, strlen(tx));
				            QuizRealAnswer -= num;
				        }
				        if(a == 4) strins(tx, " = ?", strlen(tx));
				    }

				    foreach(Player, i)
				    {
				        SendClientMessage(i, -1, "{FFFFFF}\"-------------------------------------------------\"");
				        SendClientMessageFormat(i, 0xC659B6FF, serverLang[Player[i][pLang]][173], QuizXp, tx);
				        SendClientMessage(i, -1, "{FFFFFF}\"-------------------------------------------------\"");
				    }
				}
			 	case 3:
			    {
					QuizXp += (10 + random(20));
					new rand = random(sizeof(questions[]));
					QuizIndex = rand;
					foreach(Player, i)
			        {
			            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
			            SendClientMessageFormat(i, 0xC659B6FF, questions[Player[i][pLang]][rand], QuizXp);
			            SendClientMessage(i, -1, "{FFFFFF}\"------------------------------------------------------------\"");
			        }
				}
			}
			SetTimer("CancelQuiz", 90000, false);
	    }
	}
    return 1;
}

public OnPlayerClickMap(playerid, Float:fX, Float:fY, Float:fZ)
{
	if(Player[playerid][pAdmin] >= 5 || GetUnlockedSlot(Player[playerid][pSettings], 29) == 1 && Player[playerid][aDuty]) SetPlayerPos(playerid, fX, fY, fZ);
	return 1;
}

fun l_PlayerFalling(playerid)
{
	if(IsPlayerConnected(playerid) && p_FallingCheck{playerid} == 1 && IsFalling(playerid) && !Player[playerid][aDuty])
	{
		p_FallingCheck{playerid} = 2;
		return 1;
	}
	p_FallingCheck{playerid} = 0;
	return 0;
}

fun bool:IsJumping(playerid)
{
	if(GetPlayerAnimationIndex(playerid) == 1062
	|| GetPlayerAnimationIndex(playerid) == 1141
	|| GetPlayerAnimationIndex(playerid) == 1064
	|| (GetPlayerAnimationIndex(playerid) >= 1195 && GetPlayerAnimationIndex(playerid) <= 1198)) return true;
	return false;
}

fun bool:IsRunning(playerid)
{
	if(GetPlayerAnimationIndex(playerid) == 1249
	|| GetPlayerAnimationIndex(playerid) == 1064
	|| GetPlayerAnimationIndex(playerid) == 1457
	|| (GetPlayerAnimationIndex(playerid) >= 1222 && GetPlayerAnimationIndex(playerid) <= 1236)
    || (GetPlayerAnimationIndex(playerid) >= 1276 && GetPlayerAnimationIndex(playerid) <= 1280)) return true;
	return false;
}

fun Update()
{
	static h, m, seconds;
	gettime(h, m, seconds);

	humansEvacuated = 0;
    static Float:pos[3], Float:Health[2];
    static exp[15];
    AntiCheatAlertMode = false;
	
	if(GetWeekDay() == GANG_WARS_DAY && h == 15 && m == 0 && seconds == 0 ) {
	    #if debug_mode == 0
		new DCC_Channel:tempChannel;
		tempChannel = DCC_FindChannelById("610987221431877642");
        DCC_SendChannelMessage(tempChannel, "@here\n```yaml\n-----------------------------------------------------------------\n\nI'd like to point out that Gang Wars've been begun!\nSpeed up 'n' don't fall behind, Dear Gang Member!\nSort out problems with maps capturin' without run out of time!\n\nLast but not least, the more the maps you captured the more the reward you will get!\n\nTIME: 15:00 - 20:00 (Moscow)\n\n-----------------------------------------------------------------\n```\nhttps://www.youtube.com/watch?v=1hNXD3hYNrU");
		#endif
	}
	
	if(GetWeekDay() == GANG_WARS_DAY && h == 20 && m == 0 && seconds == 0)
	{
        new query[200];
    	mysql_format(Base, query, sizeof(query), "UPDATE `maps` SET `controlled`='0',`tnx`='0' WHERE `tnx` < '%d'", gettime());
		mysql_tquery(Base, query, "", "");

		for( new igID = 1; igID < sizeof(Clan); igID++ ) {
			mysql_format(Base, query, sizeof(query), "SELECT count(`Clan`) members, (SELECT count(`controlled`) FROM `maps` WHERE `controlled` = '%d' GROUP BY `controlled`) AS maps FROM `users` WHERE `Clan` = '%d' GROUP BY `Clan`", igID, igID);
			mysql_tquery(Base, query, "GetGangMembers", "i", igID);
			Clan[igID][g_IsRulles] = false;
		}

		setGangRuller();
		SendClientMessageToAll(-1,"{ffcc99}>> All undefended castles collapsed...");
		
		#if debug_mode == 0
		new DCC_Channel:tempChannel;
		tempChannel = DCC_FindChannelById("610987221431877642");
        DCC_SendChannelMessage(tempChannel, "@here\n```yaml\n-----------------------------------------------------------------\n\nGang Wars've just ended!\n\nAll unprotected castles are gone:\n\nYou can change the color of your username to the usual one 'n' get EXP for conquerin' on all captured maps!\n\n-----------------------------------------------------------------\n```");
		#endif
    }
	
    for( new eventID = 0, i; eventID < 10; eventID++ )
  	{
 		if(gettime() > EventInfo[eventID][e_TimeToEnd] && EventInfo[eventID][e_TimeToEnd] > 0)
 	    {
            if(strlen(EventInfo[eventID][e_Name]) > 0) SendMessageFormatToAll(-1, "{33cc33}|: The event \"%s\" was over", EventInfo[eventID][e_Name]);

            EventInfo[eventID][e_IsStarted] = false;
            EventInfo[eventID][e_IsJoinsClosed] = false;
            EventInfo[eventID][e_IsGangNeed] = false;
            EventInfo[eventID][e_RequestToDelete] = false;
            for(i = 1; i < 6; i++) EventInfo[eventID][e_IsTeamActive][i] = false;
            for(i = 0; i < 6; i++) EventInfo[eventID][e_Skin][i] = 0;
           	for(i = 0; i < 3; i++) EventInfo[eventID][e_defaultPoses][i] = 0.0;
           	
           	EventInfo[eventID][e_Gravity] = 0.008;
           	
           	EventInfo[eventID][e_Time] = 12;
			EventInfo[eventID][e_Weather] = 0;
           	
	   		for(i = 0; i < MAX_PLAYERS; i++) if(IsValidPickup(EventInfo[eventID][e_Pickups][i])) DestroyPickupEx(EventInfo[eventID][e_Pickups][i], true);
           	
           	new newID;
			for( i = 0; i < 18; i++)
			{
			    newID = (i-1) > -1 ? i * 2 : 0;
 		    	if(EventInfo[eventID][e_CarProps][newID] > 0) DestroyVehicle(EventInfo[eventID][e_CarProps][newID]);
			}
            for(i = 0; i < 36; i++) EventInfo[eventID][e_CarProps][i] = 0;
            for(i = 0; i < 8; i++) EventInfo[eventID][e_RulersPermisions][i] = 0;

           	EventInfo[eventID][e_VirtualWorld] = 0;
           	EventInfo[eventID][e_minPlayers] = 0;
           	EventInfo[eventID][e_maxPlayers] = MAX_PLAYERS;
           	EventInfo[eventID][e_curPlayers] = 0;
           	EventInfo[eventID][e_minRank] = 0;
           	EventInfo[eventID][e_minExp] = 0;
           	EventInfo[eventID][e_TimerCount] = 0;
           	EventInfo[eventID][e_TimeToEnd] = -1;

            for(i = 0; i < 100; i++)
			{
				if(IsValidDynamicObject(EventInfo[eventID][e_Objects][i]))
			    {
					DestroyDynamicObject(EventInfo[eventID][e_Objects][i]);
					EventInfo[eventID][e_Objects][i] = INVALID_OBJECT_ID;
				}
			}

            EventInfo[eventID][e_IsEnded] = true;
            EventInfo[eventID][e_OwnerID] = -1;
            for(i = 0; i < 10; i++) EventInfo[eventID][e_Rulers][i] = 0;
            strmid(EventInfo[eventID][e_Name], "", 0, 65, 65);

			foreach(Player, j)
			{
				if(Player[j][eventMember] == eventID)
				{
                    SetPlayerVirtualWorld(j, 0);
			 	    ClearAnimations(j);
			 	    SetPlayerSpecialAction(j, SPECIAL_ACTION_NONE);
					Player[j][Jailed] = -1;
					Player[j][eventMember] = -1;
					SetPlayerGravity(j, 0.008);
					configureClass(j);
					setupZombie(j);
			        SetSpawnInfo(j,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
					SpawnPlayer(j);
			 	    setupZombie(j);
				}
			}
 	    }
	}
	
	foreach(Player, i)
	{
        if(i == INVALID_PLAYER_ID || i >= MAX_PLAYERS) continue;
        if(!IsPlayerConnected(i)) continue;
        
	    if(AFK[i] >= 350)
	    {
	        foreach(Player, j)
			{
			    switch(Player[j][pLang])
			    {
			        case 0: SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Too long in AFK]", Player[i][UserName]);
                    case 1: SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> Игрок %s был кикнут [Причина: Слишком долго в AFK]", Player[i][UserName]);
                    case 2: SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> El jugador %s ha sido expulsado [Razon: demasiado tiempo en AFK]", Player[i][UserName]);
				}
			}
			PlayerKick(i);
	        continue;
	    }
		
	    if(Player[i][pLogged] && GetPlayerPing(i) >= 650)
        {
            foreach(Player, j) SendClientMessageFormat(j, 0x33CCFFFF, serverLang[Player[j][pLang]][101], Player[i][UserName]);
            PlayerKick(i, "Conn");
            continue;
        }
        
        if(Player[i][pLogged] && GetPlayerPing(i) >= 500) SendClientMessage(i, -1, serverLang[Player[i][pLang]][102]);
        
        /////////// SAVE USER DATA ////////////////////
        static hours, mints, secs;
        gettime(hours, mints, secs);
        if(mints == 0 && secs == 0) SaveUserData(i);
        if(mints == 5 && secs == 0) SaveUserData(i);
        if(mints == 10 && secs == 0) SaveUserData(i);
        if(mints == 15 && secs == 0) SaveUserData(i);
        if(mints == 20 && secs == 0) SaveUserData(i);
        if(mints == 25 && secs == 0) SaveUserData(i);
        if(mints == 30 && secs == 0) SaveUserData(i);
        if(mints == 35 && secs == 0) SaveUserData(i);
        if(mints == 40 && secs == 0) SaveUserData(i);
        if(mints == 45 && secs == 0) SaveUserData(i);
        if(mints == 50 && secs == 0) SaveUserData(i);
        if(mints == 55 && secs == 0) SaveUserData(i);
        
        UpdateAliveInfo(i);

		switch(Player[i][pLang])
		{
		    case 0: format(exp,sizeof(exp), "EXP: %d", Player[i][pXP]);
		    case 1: format(exp,sizeof(exp), RusToGame("ОПЫТ: %d"), Player[i][pXP]);
		    case 2: format(exp,sizeof(exp), "EXP: %d", Player[i][pXP]);
		}
		TextDrawSetString(XP[i], exp);
		
        if(FakeData[i][8] <= 0) SetPlayerScore(i,Player[i][pXP]);
		else SetPlayerScore(i,FakeData[i][8]);
        
   	    if(PlayerDamageChecker[i][uAFK] > 0 && gettime() > PlayerDamageChecker[i][uAFK] && GetPlayerTeamEx(i) == TEAM_HUMAN && AFK[i] >= -3 && GetPlayerTeamEx(i) != 254)
	    {
	        new playerid = i;
	        if(Player[playerid][eventMember] > -1)
			{
			    new bool:something = false, str[64], p;
			    for(p = 0; p < 10; p++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][p] == Player[playerid][pAccountID]) { something = true; break; }

				new eventID = Player[playerid][eventMember];
			    if(strlen(EventInfo[eventID][e_Name]) >= 1)
			    {
					if(!something) {
						EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
						format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						SendEventMessage(str);
					} else {
					    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						SendEventMessage(str);
					}

					if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers] && !EventInfo[eventID][e_IsStarted] && EventInfo[eventID][e_IsJoinsClosed])
			        {
			            EventInfo[eventID][e_IsJoinsClosed] = false;
						format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto opened (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
						SendEventMessage(str);
			        }
				}
			    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
				Player[playerid][eventMember] = -1;
				SetPlayerGravity(playerid, 0.008);
			}
    		foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][195], Player[i][UserName]);
    		Player[i][Killstreak] = 0;
    		SortKillstreakList();
    		DeleteFromKillstreakList(i);
   			setupZombie(i);
   			configureClass(i);
   			setClass(i);
	    }
	    else if(PlayerDamageChecker[i][uAFK] > 0 && gettime() > PlayerDamageChecker[i][uAFK] && GetPlayerTeamEx(i) == TEAM_HUMAN && AFK[i] <= -2)
	    {
	        PlayerDamageChecker[i][uAFK] = 0;
	    }

	    if(playerStats[i][2] > 0) playerStats[i][2]--;
	    if(playerStats[i][3] > 0) playerStats[i][3]--;
		GetPlayerArmour(i, Health[1]);
 		if(Health[1] >= 0.1 && GetPlayerTeamEx(i) == TEAM_ZOMBIE) SetPlayerArmourAC(i, 0.0);
        if(Player[i][Jailed] > 0) {
            Player[i][Jailed]--;
            if(Player[i][Jailed] <= 0) {
                SetPlayerTeamEx(i, TEAM_ZOMBIE);
                SpawnPlayer(i);
            }
        }
        
		if(gettime() > Abilitys[i][QueenJumps][1]) if(Abilitys[i][QueenJumps][0] <= 0) Abilitys[i][QueenJumps][0]++;
		if(gettime() > Abilitys[i][ZombieJumps][1]) if(Abilitys[i][ZombieJumps][0] <= 2) Abilitys[i][ZombieJumps][0]++;
		if(GetPlayerSurfingVehicleID(i) != INVALID_VEHICLE_ID) { GetPlayerPos(i,OldPos[i][0],OldPos[i][1],OldPos[i][2]); }
		if(IsJumping(i) && pos[2] >= (OldPos[i][2]+2.5) && !IgnoreThisClass(i) && gettime() > AntiPlayerSlap[i] && GetPlayerSurfingObjectID(i) == INVALID_OBJECT_ID && GetPlayerSurfingVehicleID(i) != INVALID_VEHICLE_ID)
		{
		    GetPlayerVelocity(i, pos[0], pos[1], pos[2]);
		    if(gettime() > AntiCheat[i][ac_Tick] && pos[2] <= -0.05)
        	{
			    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses Jump Hack", Player[i][UserName], i);
				AntiCheat[i][ac_Tick] = (gettime() + 1);
				if(AntiCheatAlertMode) SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Jump Hacks? Type:{FFFFFF}/report %d JH{FFF000} if he/she is.", Player[i][UserName], i, i);
			}
		}
		if(GetPlayerAnimationIndex(i) == -1 && pos[2] > 0.0)
		{
			foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses Parkour Mode", Player[i][UserName], i);
            if(AntiCheatAlertMode) SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Anim Hacks? Type:{FFFFFF}/report %d PM{FFF000} if he/she is.", Player[i][UserName], i, i);
		}
		
		GetPlayerPos(i, pos[0], pos[1], pos[2]);
		
		if(gettime() > AntiCheat[i][ac_Tick])
        {
			if(GetPlayerAnimationIndex(i) == 1250 && GetPlayerInterior(i) <= 0 && pos[2] >= 8.0 && gettime() > AntiPlayerTP[i] && GetPlayerSurfingVehicleID(i) != INVALID_VEHICLE_ID && GetPlayerSurfingObjectID(i) == INVALID_OBJECT_ID)
			{
				foreach(Player, j) if(Player[j][pAdmin] >= 1 && Player[j][pLogged]) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses Fly Hack", Player[i][UserName], i);
                if(AntiCheatAlertMode) SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Fly Hacks? Type:{FFFFFF} /report %d FH{FFF000} if he/she is.", Player[i][UserName], i, i);
			}
		}

		GetPlayerPos(i,OldPos[i][0],OldPos[i][1],OldPos[i][2]);
		
		if(GetPVarInt(i, "WeapHack") >= 1) SetPVarInt(i, "WeapHack", GetPVarInt(i, "WeapHack") - 1);
		if(GetPVarInt(i, "SpeedHack") >= 1) SetPVarInt(i, "SpeedHack", GetPVarInt(i, "SpeedHack") - 1);
		if(GetPVarInt(i, "Pizdorvanka") >= 1) SetPVarInt(i, "Pizdorvanka", GetPVarInt(i, "Pizdorvanka") - 1);
		
		if(GetPlayerSurfingVehicleID(i) != INVALID_VEHICLE_ID)
		{
		    GetPlayerPos(i,OldPos[i][0],OldPos[i][1],OldPos[i][2]);
		}
		
		if(playerStats[i][3] <= 0)
		{
			GetPlayerArmour(i, Health[1]);
			if(playerStats[i][1] < Health[1]) { SetPlayerArmour(i, playerStats[i][1]); } else { playerStats[i][1] = Health[1]; }
		}
		TextDrawHideForPlayer(i, SpawnProtection[i]);
		if(Player[i][Muted] > 1) Player[i][Muted]--;
		if(Player[i][Muted] == 1)
		{
		    SendClientMessage(i, -1, serverLang[Player[i][pLang]][113]);
		    Player[i][Muted] = 0;
		}
	
 		if(GetTeamPlayersAlive(TEAM_HUMAN) <= 1 && !LastAlive && playerOnline >= 2)
		{
			foreach(Player, j) SendClientMessage(j,-1,serverLang[Player[j][pLang]][42]);
			LastAlive = true;
		}
	
		if(Time <= 0 && MapStarted)
		{
			if(IsEvacuated[i]) humansEvacuated++;
			if(humansEvacuated >= GetTeamPlayersAlive(TEAM_HUMAN) && IsValidTimer(mapvar[0]))
			{
			    KillTimerEx(mapvar[0]);
				KillTimerEx(mapvar[1]);
				if(IsValidTimer(mapvar[2])) KillTimerEx(mapvar[2]);
				foreach(Player, j) SendClientMessage(j,-1, serverLang[Player[j][pLang]][39]);
	   			mapvar[2] = SetTimer("EndMap", MAX_RESTART_TIME, false);
	   			MapStarted = false;
			}
		}
		
		if(gettime() > Player[i][pVipTime] && Player[i][pVip] > 0 && Player[i][pVipTime] > 0 && Player[i][pLogged])
		{
			Player[i][pVip] = 0;
			Player[i][pVipTime] = 0;
			switch(Player[i][pLang])
			{
				case 0: SendClientMessage(i, -1, "{FFF000}*** [VIP]: The VIP status has expired");
				case 1: SendClientMessage(i, -1, "{FFF000}*** [VIP]: ВИП статус истек");
				case 2: SendClientMessage(i, -1, "{FFF000}*** [VIP]: El estado VIP ha expirado");
			}
			new query[96];
			mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `VIP` = '0',`VipTime` = '0' WHERE `ID` = '%d'", Player[i][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
		}
		
		if(GetPlayerMoney(i) > 0) { IsBanned{i} = true; BanPlayer(i, "Money Hack"); }
		
		if(GetPlayerSpecialAction(i) == SPECIAL_ACTION_USEJETPACK && Player[i][pAdmin] <= 1 && GetPlayerTeamEx(i) != 254) { IsBanned{i} = true; BanPlayer(i, "Jetpack"); }

		if(Player[i][pLogged] && Player[i][Jailed] <= 0 && !Player[i][aDuty] && !HumanZombieBoss[i] && !Player[i][pInGangMatch]) AFK[i]++;
		if(AFK[i] > 15 && GetPlayerTeamEx(i) == TEAM_HUMAN && !Player[i][pInGangMatch] && GetPlayerColor(i) != COLOR_EVACUATED && !IsPlayerInRangeOfPoint(i, 30.0, 493.390991, -22.722799, 1000.679687) && GetPlayerInterior(i) != 17)
		{
            if(!Player[i][aDuty] && GetPlayerTeamEx(i) != 254)
    		{
	    		SendClientMessage(i, -1, serverLang[Player[i][pLang]][35]);
	   			setupZombie(i);
	   			configureClass(i);
	   			setClass(i);
	   			new playerid = i;
		        if(Player[playerid][eventMember] > -1)
				{
				    new bool:something = false, str[64], p;
				    for(p = 0; p < 10; p++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][p] == Player[playerid][pAccountID]) { something = true; break; }

					new eventID = Player[playerid][eventMember];
				    if(strlen(EventInfo[eventID][e_Name]) >= 1)
				    {
						if(!something) {
							EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
							format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
							SendEventMessage(str);
						} else {
						    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
							SendEventMessage(str);
						}

						if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers] && !EventInfo[eventID][e_IsStarted] && EventInfo[eventID][e_IsJoinsClosed])
				        {
				            EventInfo[eventID][e_IsJoinsClosed] = false;
							format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto opened (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
							SendEventMessage(str);
				        }
					}
				    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
					Player[playerid][eventMember] = -1;
					SetPlayerGravity(playerid, 0.008);
				}
			}
		}

        if(IsPlayerInWater(i) && !Map[m_AllowWater] && GetPlayerTeamEx(i) == TEAM_HUMAN)
		{
			GetPlayerHealth(i, Health[0]);
			SetPlayerHealthAC(i, Health[0] - 4.0);
			ShowDamageTaken(i, 4.0);
			switch(Player[i][pLang])
			{
			    case 0: GameTextForPlayer(i, "~r~ACID WATER", 1000, 5);
			    case 1: GameTextForPlayer(i, RusToGame("~r~КИСЛОТНАЯ ВОДА"), 1000, 5);
			    case 2: GameTextForPlayer(i, "~r~AGUA БCIDA", 1000, 5);
			}
        }
        
		Player[i][AbilityUsed] = false;
		
		if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pClass][TEAM_ZOMBIE+1] == GUNJAMMERZOMBIE && gettime() < Abilitys[i][GunJammer] && !Player[i][aDuty])
		{
		    new Float:radius = 6.0;
		    GetPlayerPos(i, pos[0], pos[1], pos[2]);
		    foreach(Player, j)
		    {
		        if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]) && GetPlayerTeamEx(j) == TEAM_HUMAN)
				{
				    if(GetPlayerWeapon(j) >= 1 && CanBeWeaponRemoved(j))
				    {
		    			switch(Player[j][pLang])
				        {
			    			case 0: GameTextForPlayer(j,"~r~Gun Jammer Attack", 2000, 5);
			                case 1: GameTextForPlayer(j,RusToGame("~r~ОБЕЗОРУЖЕН"), 2000, 5);
			                case 2: GameTextForPlayer(j,"~r~Desarmado", 2000, 5);
						}

		    			SetPlayerArmedWeapon(j, 0);
						Player[j][GunJammerAttack] = true;
						if(!Player[i][AbilityUsed])
			    		{
			    		    Player[i][AbilityUsed] = true;
			    		    GivePlayerXP(i, 1);
			    		}
					}
				}
		    }
		}
		
		if(gettime() >= HeroFieldTime[i][1])
		{
		    HeroFieldTime[i][0] = (gettime() + 30);
		    HeroFieldTime[i][1] = (gettime() + 75);
		}
		
		if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == ADVANCEDHERO)
		{
		    if(gettime() < HeroFieldTime[i][0])
		    {
			    GetPlayerPos(i, pos[0], pos[1], pos[2]);
			    new Float:radius = 20.0;
			    foreach(Player, j)
			    {
			        if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]) && GetPlayerTeamEx(j) == TEAM_ZOMBIE)
					{
					    GameTextForPlayer(j,"~g~Hero Field", 2000, 5);
		    			SetPlayerArmedWeapon(j, 0);
         				Player[j][HeroField] = true;
					}
			    }
			}
		}
		
		if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == SCOUT && !IsPlayerOnDuel[i])
		{
			 foreach(Player, other) if(GetPlayerTeamEx(other) != TEAM_HUMAN) SetPlayerMarkerForPlayer(other, i, 0xFFFFFF00);
		}
	    if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == ADVANCEDSCOUT && !IsPlayerOnDuel[i])
	   	{
	   	    foreach(Player, other) {
                if(GetPlayerTeamEx(other) != TEAM_HUMAN)
                {
				   	ShowPlayerNameTagForPlayer(other, i, 0);
					SetPlayerMarkerForPlayer(other, i, 0xFFFFFF00);
				}
			}
		}
	    if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pClass][TEAM_ZOMBIE+1] == CAMOUFLAGEZOMBIE && !IsPlayerOnDuel[i])
		{
		    foreach(Player, other) {
		        if(GetPlayerTeamEx(other) != TEAM_ZOMBIE)
		        {
					ShowPlayerNameTagForPlayer(other, i, 0);
					SetPlayerMarkerForPlayer(other, i, 0xFFFFFF00);
				}
			}
		}
		
		if(IsRunning(i) && Time <= 265 && GetPlayerTeamEx(i) == TEAM_HUMAN)
	    {
	        if(Achievements[i][ach_Counter] <= 259)
			{
			    if(GetPlayerSpeed(i) >= 15) Achievements[i][ach_Counter]++;
			    else Achievements[i][ach_Counter] = 0;
			}
			if(Achievements[i][ach_Counter] == 260)
			{
				AchievementAddProgress(i, ach_PULSATION);
				Achievements[i][ach_Counter] = 300;
			}
		}
		
		if(Achievements[i][ach_BMask][0] == 2147483647 && Achievements[i][ach_BMask][1] == 65535) AchievementAddProgress(i, ach_CONQUEROR);
		
		if(Player[i][Tasered] && GetPlayerTeamEx(i) == TEAM_ZOMBIE) ApplyAnimation(i, "CRACK", "CRCKIDLE2", 4.1, 0, 1, 1, 0, 1150, 1);
		
		Achievements[i][Seconds]++;

		if(Player[i][pAdmin] > 0 && AFK[i] <= -2) Player[i][AdminActivity][0]++;
        if(Player[i][AdminActivity][0] >= 60)
        {
            Player[i][AdminActivity][1]++;
            Player[i][AdminActivity][4]++;

            if(Player[i][AdminActivity][1] >= 60) { Player[i][AdminActivity][1] = 0; Player[i][AdminActivity][2]++; }
            Player[i][AdminActivity][0] = 0;
        }
		
		if(Achievements[i][Seconds] >= 60)
        {
			Achievements[i][Minutes]++;
			if(Achievements[i][Minutes] >= 60)
			{
				++Achievements[i][Hours];
				
				if(HoursForAch[i][0] >= 1)
				{
				    if(Achievements[i][Hours] == HoursForAch[i][0])
				    {
				        Achievements[i][ach_SESSION_TIME] = 2;
				        AchievementAddProgress(i, ach_SESSION_TIME);
				        HoursForAch[i][0] = -1;
				    }
				}
				
				if(HoursForAch[i][1] >= 1)
				{
				    if(Achievements[i][Hours] == HoursForAch[i][1])
				    {
				        Achievements[i][ach_SESSION_TIME] = 8;
	                    AchievementAddProgress(i, ach_SESSION_TIME);
	    				HoursForAch[i][1] = -1;
					}
				}
				
				Achievements[i][Minutes] = 0;
				AchievementAddProgress(i, ach_HOURS_PLAYED);
			}
			Achievements[i][Seconds] = 0;
		}
		
		if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pClass][TEAM_ZOMBIE+1] == RADIOACTIVEZOMBIE && !Player[i][aDuty])
		{
			if(Player[i][RadioctiveField])
			{
			    new Float:radius = 6.0;
			    
       			GetPlayerPos(i, pos[0], pos[1], pos[2]);
		    	foreach(Player, j)
			    {
			        if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]) && canBeInRadioactiveField(j))
					{
					    GetPlayerArmour(j, Health[1]);
					    GetPlayerHealth(j, Health[0]);

                        if(GetPlayerTeamEx(j) == TEAM_HUMAN)
						{
						    if(Health[1] <= 0.0 && Health[0] <= 70.0)
						    {
						        if(!Player[i][AbilityUsed])
					    		{
					    		    Player[i][AbilityUsed] = true;
					    		    GivePlayerXP(i, 1, false);
					    		}
					    		
						        switch(Player[j][pLang])
						        {
					    			case 0: GameTextForPlayer(j,"~r~Radioactive ~g~Field", 2000, 5);
	                                case 1: GameTextForPlayer(j,RusToGame("~r~РАДИОАКТИВНОЕ ~g~ПОЛЕ"), 2000, 5);
	                                case 2: GameTextForPlayer(j,"~r~Campo ~g~Radiactivo", 2000, 5);
								}
								
								GetPlayerHealth(j, Health[0]);
								SetPlayerHealthAC(j, Health[0] - 3.5);
								ShowDamageTaken(j, 3.5);
							}
						}
					}
			    }
			}
		}
		
		if(Player[i][IsBurned][0])
		{
		    GetPlayerHealth(i, Health[0]);
	    	TextDrawShowForPlayer(i, Stun[i]);
			switch(Player[i][pLang])
	        {
    			case 0: GameTextForPlayer(i,"~y~You're burning", 2000, 5);
                case 1: GameTextForPlayer(i,RusToGame("~y~ВЫ ГОРИТЕ"), 2000, 5);
                case 2: GameTextForPlayer(i,"~y~Estas ardiendo", 2000, 5);
			}
			SetPlayerHealthAC(i, Health[0] - 2.0);
		}
		
		if(Player[i][IsPlayerAdvancedInfected] && GetPlayerTeamEx(i) == TEAM_HUMAN)
		{
		    GetPlayerPos(i, pos[0], pos[1], pos[2]);
		    foreach(Player, j)
		    {
		        if(IsPlayerInRangeOfPoint(j, 1.0, pos[0], pos[1], pos[2]) && !Player[j][IsPlayerAdvancedInfected] && GetPlayerTeamEx(j) == TEAM_HUMAN && PlayerGuitarTime[j] <= 1)
				{
					if(InfectPlayer(1.0, j, i, 1.0, 15000, true))
					{
				    	foreach(Player, q) SendClientMessageFormat(q, 0x009900FF, serverLang[Player[q][pLang]][63], Player[j][UserName], Player[i][UserName]);
					}
				}
			}
		}
		
		static j;
     	for( j = 0; j < sizeof(Map[ZombieSpawnX]); j++ )
		{
     		if((IsPlayerInRangeOfPoint(i, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j]) || (gettime() < ZombieSpawnProtection[i] && ZombieSpawnProtection[i] > 0)) && GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pLogged] && !Player[i][aDuty])
     		{
     			TextDrawShowForPlayer(i, SpawnProtection[i]);
     		}
		}
		
		if(GetPlayerTeamEx(i) == TEAM_HUMAN && GetTeamPlayersAlive(TEAM_HUMAN) == 1 && !lastHuman[i] && Player[i][pLogged])
		{
			lastHuman[i] = true;
			foreach(Player, k)
			{
				if(GetPlayerTeamEx(k) == TEAM_ZOMBIE)
				{
				    switch(Player[k][pLang])
				    {
						case 0: GameTextForPlayer(k, "~r~KILL~w~ THE LAST HUMAN", 4000, 5);
						case 1: GameTextForPlayer(k, RusToGame("~r~УБЕЙТЕ~w~ ПОСЛЕДНЕГО ЧЕЛОВЕКА"), 4000, 5);
						case 2: GameTextForPlayer(k, "~r~MATAR~w~ AL ЪLTIMO HUMANO", 4000, 5);
					}
				}
			}
			continue;
		}
	}
}

fun AntiRemovePlayerFromVehicle(i)
{
    if(GetPlayerState(i) == 2)//IN CAR
    {
        IsBanned{i} = true;
		BanPlayer(i, "Vehicle-Hack", "conn");
		return 0;
	}
	return 1;
}

fun OnPlayerSpawn(playerid)
{
	/// TODO:
    ////////////////////////////////////////////////////////////////////////////
    PR_VirtualWorldForPlayer[playerid] = 0;
    
    PlayerDamageChecker[playerid][uAFK] = 0;
    AntiCheat[playerid][ac_OldHP] = 0.0;
    AntiCheat[playerid][ex_OldHP] = 0.0;
    AntiCheat[playerid][weap_OldHP] = -100.0;
    
    KilledBy[playerid] = INVALID_PLAYER_ID;
    KilledByWeapon[playerid] = 0;
    DamageApplyType[playerid][0] = 0;
    DamageApplyType[playerid][1] = 0;
    
   	/*if(UserTankInWarState[playerid] >= 1)
	{
	    printf("DEBUG, blyat");
		return 1; // Event
	}*/
    
	for( new i = 0; i < MAX_SELLING_INFO; i++) Player[playerid][isInSelling][i] = -1;
    
    Player[playerid][pWasGangAffected] = false;
    
    ClearAnimations(playerid);
    
    if(Player[playerid][pInGangMatch]) {
        ShowPlayerDialog(playerid, DIALOG_MATCH_CLASS, DIALOG_STYLE_LIST, "{FFFF00}[MATCH]", "SHIELDER\nMELEE KILLER\nRANGED KILLER", "Select", "Close");
		return 1;
    }
    
    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    SetPlayerHealthAC(playerid, 100.0, true, 100.0);
	}
	else SetPlayerHealthAC(playerid, 100.0, true, 100.0);
	SetPlayerArmourAC(playerid, 0.0);
    
    Player[playerid][Blidness] = 0;
    TextDrawHideForPlayer(playerid, Blidnes[playerid]);
    KillTimer(Player[playerid][BlidnessTimer]);
    if(GetUnlockedSlot(Player[playerid][pSettings], PS_SHOW_EXP) == 1) TextDrawShowForPlayer(playerid, XP[playerid]);
    Player[playerid][IsBurned][0] = 0;
    Player[playerid][IsBurned][1] = 0;
    Player[playerid][IsCursed] = false;
    Player[playerid][Poisioned] = false;
	Player[playerid][Tasered] = false;
	Player[playerid][Accelerated] = -1;
	if(IsPlayerAcceleratedText[playerid]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[playerid]),IsPlayerAcceleratedText[playerid]=Text3D:-1;
	p_FallingTime[playerid] = -1;
   	p_FallingCheck{playerid} = 0;
   	CockroachAbility[playerid] = false;
    AttachUserObjects(playerid);
    AFK[playerid] = 0;
    
	if(Player[playerid][Jailed] > 0)
	{
    	SetPlayerSkinAC(playerid, 62, 1);
		SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
		SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		SetPlayerFacingAngle(playerid, 263.0160);
		SetPlayerInterior(playerid, 6);
		SetPlayerColor(playerid, 0x000000FF);
		SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		ResetWeapons(playerid);
		SetPlayerArmourAC(playerid, 0.0);
		SetPlayerHealthAC(playerid, 100.0);
		Player[playerid][Accelerated] = -1;
		if(IsPlayerAcceleratedText[playerid] > Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[playerid]),IsPlayerAcceleratedText[playerid]=Text3D:-1;
		return 1;
	}
	
 	//if(Player[playerid][LeatherFace][0]) Player[playerid][pClass][TEAM_ZOMBIE+1]=Player[playerid][LeatherFace][1],Player[playerid][LeatherFace][0]=0;
    if(IsSpecing[playerid])
    {
        IsSpecing[playerid] = false;
		IsBeingSpeced[spectatorid[playerid]] = false;
		spectatorid[playerid] = -1;
	}
	
	if(InGangHouse[playerid])
	{
	    SetPlayerPos(playerid, 313.0039,-164.4616,999.6010);
	    SetActorFacingAngle(playerid, 180.6503);
	    SetPlayerInterior(playerid, 6);
	    SetPlayerVirtualWorld(playerid, 10 + Player[playerid][pClan]);
	    AntiTPTimerEx(playerid, 4);
		AntiSlap(playerid, 2);
		AntiSpeedHack(playerid, 3);
		SetPlayerSkinAC(playerid, 252, 1);
		SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		return 1;
	}
	
	if(GetWeekDay() == GANG_WARS_DAY) {
	    static h;
	    gettime(h, _, _);
		if(h >= 15 && h < 20 && Player[playerid][pClanRank] > 0) SendClientMessage(playerid, -1, "{FF0000}>> Gang Wars is going right now! (/gang match [mapid])");
    }
    
    ShowDisplayInfo(playerid);
    CheckToStartMap();
	
	SetPlayerInterior(playerid, Map[m_Interior]);
	SetPlayerVirtualWorld(playerid, Map[m_World]);
    
	SetPlayerTime(playerid, Map[m_Time], 0);
	SetPlayerWeather(playerid, Map[m_Weather]);
	
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
 		switch(getZombieClass(playerid))
		{
			case FREEZERZOMBIE, DEMONZOMBIE, BOOMERZOMBIE, KAMIKAZEZOMBIE: ZombieSpawnProtection[playerid] = gettime() + 5;
			default: ZombieSpawnProtection[playerid] = gettime() + 12;
		}
        new bool:ns, p = random(sizeof(Map[ZombieSpawnX])), Float:dist = (float(1+random(19))/100.0);
        if(NewSpawnPoints[0][0] != 0.0)
		{
			if(random(2) == 0)
			{
				SetPlayerPosAC(playerid, NewSpawnPoints[0][0]+dist, NewSpawnPoints[0][1]+dist, NewSpawnPoints[0][2]);
				foreach(Player, i) if(i == NewSpawnsCreators[0] && i != playerid) GivePlayerXP(i, 1);
				ns = true;
				ZombieSpawnProtection[playerid] = 3;
			}
        }
        if(NewSpawnPoints[1][0] != 0.0)
		{
			if(random(2) == 0)
			{
				SetPlayerPosAC(playerid, NewSpawnPoints[1][0]+dist, NewSpawnPoints[1][1]+dist, NewSpawnPoints[1][2]);
				foreach(Player, i) if(i == NewSpawnsCreators[1] && i != playerid) GivePlayerXP(i, 2, false);
				ns = true;
				ZombieSpawnProtection[playerid] = 3;
			}
        }
        if(!ns) SetPlayerPosAC(playerid, Map[ZombieSpawnX][p]+dist, Map[ZombieSpawnY][p]+dist, Map[ZombieSpawnZ][p]);

        switch(getZombieClass(playerid))
		{
			case MEGAJUMPERZOMBIE, FASTZOMBIE: ZombieSpawnProtection[playerid] = 0;
		}

     	/*new p = random(sizeof(Map[ZombieSpawnX])), Float:dist = (float(1+random(19))/100.0);
      	SetPlayerPosAC(playerid, Map[ZombieSpawnX][p]+dist, Map[ZombieSpawnY][p]+dist, Map[ZombieSpawnZ][p]);*/
	}
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    new p = random(sizeof(Map[HumanSpawnX])), Float:dist = (float(1+random(19))/100.0);
	    SetPlayerPosAC(playerid, Map[HumanSpawnX][p]+dist, Map[HumanSpawnY][p]+dist, Map[HumanSpawnZ][p]);
	}
	
	if(!Player[playerid][aDuty])
	{
	    if(!NewbieChangedClass[playerid])
		{
			setPlayerClass(playerid, GetPlayerMaxClass(playerid), GetPlayerTeamEx(playerid));
			SendClientMessage(playerid, -1, "{FFFFFF}[SYSTEM]:{FFF000} Your class was auto-changed, to change it by yourself type{FFFFFF} (/class)");
	    }
        configureClass(playerid);
    	setClass(playerid);
	}
	else
	{
		SetPlayerSkinAC(playerid, 217);
	}
	return 1;
}

/// Commands

fun TryToGiveZaps(playerid, targetid, ct)
{
    if(cache_num_rows())
	{
        if(floor(Player[playerid][pBalance]) >= ct)
        {
            Player[playerid][pBalance] -= float(ct);
            Player[targetid][pBalance] += float(ct);
            
            new y, m, d, h, i, s, query[256], ip[16];
		  	TimestampToDate(gettime(), y, m, d, h, i, s, 3);
			GetPlayerIp(playerid, ip, 16);
			mysql_format(Base, query, sizeof(query), "INSERT INTO `payments` (`from`,`whom`,`amount`,`type`,`date`,`id`,`ip`) VALUES ('%e','%e','%d','%d','%d','%d','%e')", Player[playerid][UserName], Player[targetid][UserName], ct, 3, gettime(), Player[playerid][pAccountID], ip);
		 	mysql_tquery(Base, query, "", "", "");

			#if debug_mode == 0
			DiscordChannel = DCC_FindChannelById("622114307131572225");
			format(query, sizeof query, "```\n%04d-%02d-%02d %02d:%02d %s has paid %d ZAPS to %s\n```", y, m, d, h, i, Player[playerid][UserName], ct, Player[targetid][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, query);
			#endif
			
			foreach(Player, j) SendClientMessageFormat(j, -1, "{ff33ff}>> %s has paid {FFF000}%d{ff33ff} zaps to %s!", Player[playerid][UserName], ct, Player[targetid][UserName]);
        }
        else
        {
            SendClientMessage(playerid, -1, "{FFF000}Error, not enough zaps!");
        }
	}
	return 1;
}

public OnPlayerStreamOut(playerid, forplayerid)
{
   	/*if(GetPlayerTeamEx(forplayerid) == TEAM_HUMAN && Player[forplayerid][pClass][TEAM_HUMAN] == SCOUT && !IsPlayerOnDuel[forplayerid])
	{
	    if(GetPlayerTeamEx(playerid) != TEAM_HUMAN) SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
	}

    if(GetPlayerTeamEx(forplayerid) == TEAM_HUMAN && Player[forplayerid][pClass][TEAM_HUMAN] == ADVANCEDSCOUT && !IsPlayerOnDuel[forplayerid])
   	{
   	    if(GetPlayerTeamEx(playerid) != TEAM_HUMAN)
   	    {
	   		ShowPlayerNameTagForPlayer(forplayerid, playerid, 0);
			SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
		}
	}
    if(GetPlayerTeamEx(forplayerid) == TEAM_ZOMBIE && Player[forplayerid][pClass][TEAM_ZOMBIE+1] == CAMOUFLAGEZOMBIE && !IsPlayerOnDuel[forplayerid])
	{
 		if(GetPlayerTeamEx(playerid) != TEAM_ZOMBIE)
	    {
			ShowPlayerNameTagForPlayer(forplayerid, playerid, 0);
		 	SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
		}
	}*/
	return 1;
}

public OnPlayerStreamIn(playerid, forplayerid)
{
    /*if(GetPlayerTeamEx(forplayerid) == TEAM_HUMAN && Player[forplayerid][pClass][TEAM_HUMAN] == SCOUT && !IsPlayerOnDuel[forplayerid])
	{
	    if(GetPlayerTeamEx(playerid) != TEAM_HUMAN) SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
	}
	
    if(GetPlayerTeamEx(forplayerid) == TEAM_HUMAN && Player[forplayerid][pClass][TEAM_HUMAN] == ADVANCEDSCOUT && !IsPlayerOnDuel[forplayerid])
   	{
   	    if(GetPlayerTeamEx(playerid) != TEAM_HUMAN)
   	    {
	   		ShowPlayerNameTagForPlayer(forplayerid, playerid, 0);
			SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
		}
	}
    if(GetPlayerTeamEx(forplayerid) == TEAM_ZOMBIE && Player[forplayerid][pClass][TEAM_ZOMBIE+1] == CAMOUFLAGEZOMBIE && !IsPlayerOnDuel[forplayerid])
	{
 		if(GetPlayerTeamEx(playerid) != TEAM_ZOMBIE)
	    {
			ShowPlayerNameTagForPlayer(forplayerid, playerid, 0);
		 	SetPlayerMarkerForPlayer(playerid, forplayerid, 0xFFFFFF00);
		}
	}*/
    return 1;
}

public OnActorStreamIn(actorid, forplayerid)
{
	return 1;
}

fun LoadMembers(playerid, gangid)
{
	if(cache_num_rows())
	{
	    new str[4096], n[25], online_t[25], id, r, f[128], t[32], i;
	    strcat(str, "{FF0000}Name\t{FF0000}Rank\t{FF0000}Last login\n");
		for( i = 0; i < cache_num_rows(); i++)
		{
		    if( i == 50 ) break;
            cache_get_value_name(i, "Name", n, 25);
		    cache_get_value_name_int(i, "ID", id);
            cache_get_value_name(i, "lalog", online_t, 25);
	    	cache_get_value_name_int(i, "ClanRank", r);
	    	foreach(Player, j) if(Player[j][pAccountID] == id) format(f, sizeof(f), "{66ff66}%s\t{66ff66}%d\t{66ff66}Online\n", n, r);
		    else format(f, sizeof(f), "{FFFFFF}%s\t%d\t{cdcdcd}%s\n", n, r, online_t);
		    strcat(str, f);
		    GangPanelIDs[playerid][i] = id;
		}
		format(t, sizeof(t), "{B2F558}Member list (%d / %d)", i, cache_num_rows());
		ShowPlayerDialog(playerid, DIALOG_GANG_MEMBERS_LIST, DIALOG_STYLE_TABLIST_HEADERS, t, str, "Ok", "");
	}
	return 1;
}

CMD:donate(playerid)
{
	switch(Player[playerid][pLang])
	{
    	case 0:
		{
		    ShowPlayerDialog(playerid, DIALOG_DONATE_ACTIONS, DIALOG_STYLE_MSGBOX, "{33adff}DONATE", "{FFFFFF}Welcome to the donation section, select what you want to do", "Info", "Shop");
		    return 1;
		}
		case 1:
		{
		    ShowPlayerDialog(playerid, DIALOG_DONATE_ACTIONS, DIALOG_STYLE_MSGBOX, "{33adff}БЛАГОТВОРИТЕЛЬСНОСТЬ", "{FFFFFF}Добро пожаловать в раздел доната, выберите то, что вы хотите сделать", "Инфо", "Магазин");
		    return 1;
		}
		case 2:
		{
		    ShowPlayerDialog(playerid, DIALOG_DONATE_ACTIONS, DIALOG_STYLE_MSGBOX, "{33adff}DONAR", "{FFFFFF}Bienvenido a la seccion de donaciones, selecciona lo que quieres hacer", "Info", "Tienda");
		    return 1;
		}
	}
	return 1;
}

CMD:discordpm(playerid, params[])
{
	new m[200];
	if(sscanf(params, "is[200]", params[0], m)) {
	    SendClientMessage(playerid, -1, "{FFF000}>> /discordpm (to) (message)");
	    return 1;
	}
	
	if(params[0] < 0 || params[0] >= UserCreatedChannels[playerid]) {
	    SendClientMessage(playerid, -1, "{FFF000}>> /discordpm (to) (message)");
	    return 1;
	}

	if(strlen(m) < 1) {
        SendClientMessage(playerid, -1, "{FFF000}>> /discordpm (to) (message)");
	    return 1;
	}

    if(CheckForWebsite(m) || CheckForIP(m)) {
        SendClientMessage(playerid, -1, "{FFFF00}>> Something went wrong, try to use letters instead of sites and digits!");
	    return 1;
	}

	new DCC_Channel: ToSent = DCC_FindChannelById(UserPrivateChannelID[playerid][params[0]]), msg[200];
	if(ToSent == DCC_Channel:0) {
		SendClientMessage(playerid, -1, "{FFFF00}>> Something went wrong on other side!");
	    return 1;
	}
	
	format(msg, sizeof(msg), "```\n%s: %s\n```", Player[playerid][UserName], m);
    DCC_SendChannelMessageEx(ToSent, msg);
    
    SendClientMessageFormat(playerid, -1, "{FFFF00}>> [DISCORD PM to %s]: %s", UserPrivateChannelUserNames[playerid][params[0]], m);

    new __action[200], y, mnt, d, h, minutes, s;
	TimestampToDate(gettime(), y, mnt, d, h, minutes, s, 3);
	DiscordChannel = DCC_FindChannelById("662009556817149962");
	format(__action, sizeof __action, "```\n[DISCORD]: %02d/%02d/%04d %02d:%02d %s(%d) to %s(%d) (Message: %s)\n```", d, mnt, y, h, minutes, Player[playerid][RealName], Player[playerid][pAccountID], UserPrivateChannelUserNames[playerid][params[0]], params[0], m);
	DCC_SendChannelMessageEx(DiscordChannel, __action);
	
	return 1;
}

CMD:adva(playerid, params[])
{
	if(Player[playerid][pAdmin] >= 3)
	{
	    if(sscanf(params, "i", params[0]))
		{
		    SendClientMessage(playerid, -1, "/adva (id)");
		    return 1;
		}
		if(strlen(PlayerText[params[0]]) <= 0)
		{
		    SendClientMessage(playerid, -1, "The player did not commit this action");
		    return 1;
		}
		switch(PlayerTextType[params[0]])
		{
		    case 1:
			{
				PlayerTextType[params[0]] = 1000;
				OnPlayerText(params[0], PlayerText[params[0]]);
			}
			case 2:
			{
			    new str[128];
			    format(str, sizeof(str), "%s", PlayerText[params[0]]);
			    PlayerTextType[params[0]] = 1000;
			    cmd::pm(params[0], str);
			}
			case 3:
			{
			    new str[128];
			    format(str, sizeof(str), "%s", PlayerText[params[0]]);
			    PlayerTextType[params[0]] = 1000;
			    cmd::v(params[0], str);
			}
			case 4:
			{
			    new str[128];
			    format(str, sizeof(str), "%s", PlayerText[params[0]]);
			    PlayerTextType[params[0]] = 1000;
			    //cmd::ask(params[0], str);
			}
			case 5:
			{
			    new str[128];
			    format(str, sizeof(str), "%s", PlayerText[params[0]]);
			    PlayerTextType[params[0]] = 1000;
			    //cmd::trade(params[0], str);
			}
		}
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> %s allowed %s to send a message: %s", Player[playerid][RealName], Player[params[0]][UserName], PlayerText[params[0]]);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /adva on player %s (Message: %s)\n```",  Player[playerid][RealName], Player[params[0]][UserName], PlayerText[params[0]]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		PlayerTextType[params[0]] = 0;
		strmid(PlayerText[params[0]], "", 0, 128, 128);
		return 1;
	}
	return 0;
}

stock UserVerifiyed(playerid)
{
   	return 1;
}

fun ShowNews(playerid)
{
	return 1;
}

fun RemovePlayersEXP(playerid, skidka)
{
    if(cache_num_rows() > 0)
 	{
  		new id, user[24], ex;
		cache_get_value_name_int(0, "ID", id);
		cache_get_value_name(0, "Name", user);
		cache_get_value_name_int(0, "EXP", ex);

        new Float:tsena = float(ex), query[81];
        ex -= floatround(((tsena/100)*skidka), floatround_round);
		mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `EXP` = '%d' WHERE `ID` = '%d'", ex, id);
		mysql_tquery(Base, query, "", "", "");
	   	foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s took %d percents of {FFFFFF}%s's EXP", Player[playerid][RealName], skidka, user);
			if(!strcmp(user, Player[i][UserName]))
			{
	    		Player[i][pXP] -= floatround(((tsena/100)*skidka), floatround_round);
			}
		}
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /removeexp on player %s\n```",  Player[playerid][RealName], user);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	else SendClientMessage(playerid, -1, "{FFF000}>> This player isnt't found");
	return 1;
}

CMD:removexp(playerid, params[])
{
	if(Player[playerid][pAdmin] <= 4) return 0;
	new name[24];
	if(sscanf(params, "s[24]i", name, params[0]))
	{
	    SendClientMessage(playerid, -1, "/removexp (name) (percent)");
	    return 1;
	}
	
	if(params[0] <= 0 || params[0] > 100)
	{
	    SendClientMessage(playerid, -1, "/removexp (name) (percent)");
	    return 1;
	}
	
	new query[128];
	mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`EXP` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name); 
	mysql_tquery(Base, query, "RemovePlayersEXP", "i", playerid, params[0]);
	
	return 1;
}

fun ShowMaps(playerid)
{
	if(cache_num_rows())
	{
	    new i, size = cache_num_rows(), str[4096], id, name[96], frm[128], gang, gang_controll[64], tnx, defender[32];
    	strcat(str, "{B2F558}Title\t{FFFFFF}ID\t{FFFFFF}OWNED BY\n");
    
   		for( i = 0; i < size; i++ )
   		{
            cache_get_value_name_int(i, "ID", id);
            cache_get_value_name_int(i, "controlled", gang);
            cache_get_value_name_int(i, "tnx", tnx);
     	    cache_get_value_name(i, "Name", name);
     	    
     	    if(GetWeekDay() == GANG_WARS_DAY)
     	    {
     	    	if(gettime() < tnx) defender = " (PROTECTED)";
     	    	else defender = " (PENDING)";
     	    }
 			else defender = " ";
     	    
     	    if(gang > 0) format(gang_controll, sizeof(gang_controll), "\t{FFFFFF}%s%s", Clan[gang][Full], defender);
     	    else gang_controll = "\t{7e13a8}BROKEN";
     	    
     	    if( i == current_map ) format(frm, sizeof(frm), "{FF0000}%s\t{FFFFFF}%d%s\n", name, id+1, gang_controll);
     	    else
		 	{
		 	    if(i % 2 == 0) format(frm, sizeof(frm), "{817e81}%s\t{FFFFFF}%d%s\n", name, id+1, gang_controll);
		 	    else format(frm, sizeof(frm), "{FFFFFF}%s\t{FFFFFF}%d%s\n", name, id+1, gang_controll);
			}
     	    strcat(str, frm);
		}
		ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_TABLIST_HEADERS, "{B2F558}Maps", str, "Ok", "");
	}
	return 1;
}

CMD:maps(playerid)
{
    new query[128];
    mysql_format(Base, query, sizeof(query), "SELECT `Name`,`ID`,`controlled`,`tnx` FROM `maps` WHERE `ID` > -1");
 	mysql_tquery(Base, query, "ShowMaps", "i", playerid);
    return 1;
}

fun ShowPlayerActivity(pos, id, h, m, s, playerid)
{
	if(cache_num_rows())
	{
	    new User[MAX_PLAYER_NAME];
	    cache_get_value_name(0, "Name", User, MAX_PLAYER_NAME);
	    SendClientMessageFormat(playerid, -1, "{FFD500}(%d place) >> %s (%d hours, %d minutes, %d seconds)", pos, User, h, m, s);
	}
	return 1;
}

CMD:achievements(playerid, params[])
{
	new targetid = -1;
    sscanf(params,"i", targetid);
	if(targetid == -1 || isnull(params)) targetid = playerid;
	if(!IsPlayerConnected(targetid))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	PrepareAchievements(playerid, targetid);
	return 1;
}

stock PrepareAchievements(playerid, targetid)
{
	new str[4096], f[164], w[64], Float:rn[] = {10.000, 50.000, 200.000}, col[] = COLOR_ACHS_LO;
	strcat(str, achTrnsl[0][0]);
	for( new i = 1; i < sizeof(achNames[]); i++ )
	{
	    switch(i-1)
	    {
	        case 0..30:  { if(GetBitSlot(Achievements[playerid][ach_BMask][0],  i-1) <= 0)  col = COLOR_ACHS_LO; else col = COLOR_ACHS_UN; }
	        case 31..64: { if(GetBitSlot(Achievements[playerid][ach_BMask][1],  i-32) <= 0) col = COLOR_ACHS_LO; else col = COLOR_ACHS_UN; }
	    }
	    switch(i-1)
	    {
	        case 4..6:
			{
				format(w, sizeof(w), achTrnsl[0][achIndexes[i-1]], rn[i-5]);
				format(f, sizeof(f), "%s%s\t%s%s (%d EXP) [%.3f/%.3f]\n", col, achNames[0][i], col, w, achXPReward[i-1], (Achievements[playerid][ach_RUNNED] < rn[i-5])?Achievements[playerid][ach_RUNNED]:rn[i-5], rn[i-5]);
			}
			case 0,29,39,44,45,46,47,48:
			{
                format(w, sizeof(w), achTrnsl[0][achIndexes[i-1]], achEndProgress[i-1]);
				format(f, sizeof(f), "%s%s\t%s%s (%d EXP)\n", col, achNames[0][i], col, w, achXPReward[i-1], Achievements[targetid][achInfo:achIndexes[i-1]], achEndProgress[i-1]);
			}
	    	default:
			{
				format(w, sizeof(w), achTrnsl[0][achIndexes[i-1]], achEndProgress[i-1]);
				format(f, sizeof(f), "%s%s\t%s%s (%d EXP) [%d/%d]\n", col, achNames[0][i], col, w, achXPReward[i-1], (GetAchievementProgress(targetid,i-1)<achEndProgress[i-1])?GetAchievementProgress(targetid,i-1):achEndProgress[i-1], achEndProgress[i-1]);
			}
		}
		strcat(str, f);
	}
	
	format(f, sizeof(f), "%s's %s", Player[targetid][UserName], achNames[0][0]);
	ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_TABLIST_HEADERS, f, str, "Ok", "");
}

CMD:weapons(playerid)
{
	ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_TABLIST_HEADERS, "Weapons", "Weapon\tID\nChainsaw\t9\nGrenade\t16\nMolotov\t18\nColt45\t22\nSilenced Pistol\t23\nDesert Eagle\t24\nShotgun\t25\nSawnoff Shotgun\t26\nCombat Shotgun\t27\nUZI\t28\nMP5\t29\nAK-47\t30\nM4\t31\nTec-9\t32\nCountry Rifle\t33\nSniper Rifle\t34", "Ok", "");
	return 1;
}

CMD:duel(playerid, params[])
{
	new UserID = -1, weaponID = -1,
		dExp = 0, rules[2] = {0,0};

    sscanf(params, "iiiii", UserID, weaponID, dExp, rules[0], rules[1]);

	if(weaponID == -1 || UserID == -1)
	{
	    SendClientMessage(playerid, -1, "/duel (id) (weapon id) [..exp (1000 MAX), c-bug = 0 - OFF | 1 - ON, type = 0 - 50 Armour | 1 - No Armour | 2 - 85 Armour]");
		return 1;
	}
	if(!IsPlayerConnected(UserID))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(playerid == UserID) return 1;
	if(weaponID > 34 || weaponID < 9 || weaponID >= 10 && weaponID <= 15 || weaponID == 17 || weaponID == 19 || weaponID == 20 || weaponID == 21)
	{
	    SendClientMessage(playerid, -1, "{B2F558}>> Use /weapons to see weapons list");
		return 1;
	}

    if(rules[0] > 1) rules[1] = 1;
	if(rules[0] < 0) rules[1] = 0;

	if(rules[1] > 2) rules[1] = 2;
	if(rules[1] < 0) rules[1] = 0;
	
	if(dExp > Player[playerid][pXP] || dExp > Player[UserID][pXP])
	{
        SendClientMessage(playerid, -1, "{B2F558}>> Not enough exp from one of sides");
		return 1;
	}
	
	if(HumanHumanBoss[playerid] || HumanZombieBoss[playerid] || HumanHumanBoss[UserID] || HumanZombieBoss[UserID] || GetUnlockedSlot(Player[UserID][pSettings], PS_BLOCK_DUELS) == 1 || IsPlayerOnDuel[UserID] || Player[UserID][aDuty] || Player[playerid][aDuty])
	{
	    SendClientMessage(playerid, -1, "{e9dec8}>> You cannot send a request to this person");
		return 1;
	}
	
	if(dExp <= 0)
	{
		rules[0] = 0;
		rules[1] = 0;
	}
	
	if(dExp > 0 && (Player[playerid][pRank] < 10 ||  Player[UserID][pRank] < 10))
	{
	    SendClientMessage(playerid, -1, "{e9dec8}>> You / your opponent need min. rank 10!");
	    return 1;
	}
	
	if(Player[playerid][Jailed] >= 1) return 1;
	
	DuelReceived[UserID] = true;
	DuelerID[UserID] = playerid;
	DuelerID[playerid] = UserID;
	DuelerWeapon[playerid] = weaponID;
	
	if(dExp > 1000) dExp = 1000;
	
	DuelEXP[playerid] = dExp;
	DuelRules[0][playerid] = rules[0];
	DuelRules[1][playerid] = rules[1];
	
	DuelEXP[UserID] = dExp;
	DuelRules[0][UserID] = rules[0];
	DuelRules[1][UserID] = rules[1];
	
	switch(Player[UserID][pLang])
	{
		case 0: GameTextForPlayer(UserID, "~y~DUEL REQUEST RECEIVED", 2000, 5);
		case 1: GameTextForPlayer(UserID, RusToGame("~y~ЗАЯВКА НА ДУЭЛЬ"), 2000, 5);
		case 2: GameTextForPlayer(UserID, "~y~SOLICITUD DE DUELO RECIBIDA", 2000, 5);
	}
	
	new gunname[32], rls[32]=" ";
	GetWeaponName(weaponID, gunname, sizeof(gunname));
	
	DuelEXP[UserID] = dExp;
	DuelRules[0][UserID] = rules[0];
	DuelRules[1][UserID] = rules[1];
	
	switch(Player[UserID][pLang])
	{
	    case 0:
	    {
	        switch(rules[1])
	        {
	            case 1: rls = " (No Armour)";
	            case 2: rls = " (85 '/. of Armour)";
				case 0: rls = " (50 '/. of Armour)";
				default: rls = " (50 '/. of Armour)";
			}
	        
	        if(dExp <= 0) SendClientMessageFormat(UserID, -1, "{e9dec8}>> %s is inviting you to duel with weapon: %s (ID %d)", Player[playerid][UserName], gunname, weaponID);
            else SendClientMessageFormat(UserID, -1, "{e9dec8}>> %s is inviting you to duel with weapon: %s (ID %d) (Bet %d EXP) %s%s", Player[playerid][UserName], gunname, weaponID, dExp, (rules[0] >= 1) ? ("With C-BUG") : ("(Without C-BUG)"), rls);
            
			SendClientMessage(UserID, -1, "{e9dec8}>> Type {00FF00}/y{e9dec8} to agree and {FF0000}/n{e9dec8} to deny");
		}
		case 1:
	    {
	        switch(rules[1])
	        {
	            case 1: rls = " (Без Брони)";
	            case 2: rls = " (С 85 '/. брони)";
				case 0: rls = " (С 50 '/. брони)";
				default: rls = " (С 50 '/. брони)";
			}
			
			if(dExp <= 0) SendClientMessageFormat(UserID, -1, "{e9dec8}>> Игрок %s приглашает вас на дуэль с оружием: %s (ИД %d)", Player[playerid][UserName], gunname, weaponID);
			else SendClientMessageFormat(UserID, -1, "{e9dec8}>> Игрок %s приглашает вас на дуэль с оружием: %s (ИД %d) (Ставка: %d опыта) %s%s", Player[playerid][UserName], gunname, weaponID, dExp, (rules[0] >= 1) ? ("+С разрешено") : ("(+С отключено)"), rls);
			
			SendClientMessage(UserID, -1, "{e9dec8}>> Введите {00FF00}/y{e9dec8} для согласия и {FF0000}/n{e9dec8} для отказа");
		}
		case 2:
	    {
	        switch(rules[1])
	        {
	            case 1: rls = " (Sin armadura)";
	            case 2: rls = " (85 '/. de armadura)";
				case 0: rls = " (50 '/. de armadura)";
				default: rls = " (50 '/. de armadura)";
			}
			
			if(dExp <= 0) SendClientMessageFormat(UserID, -1, "{e9dec8}>> El jugador %s te invita a un duelo con un arma: %s (ID %d)", Player[playerid][UserName], gunname, weaponID);
			else SendClientMessageFormat(UserID, -1, "{e9dec8}>> El jugador %s te invita a un duelo con un arma: %s (ID %d) (Tasa: %d EXP) %s%s", Player[playerid][UserName], gunname, weaponID, dExp, (rules[0] >= 1) ? ("Con C-BUG") : ("(Sin C-BUG)"), rls);
			
			SendClientMessage(UserID, -1, "{e9dec8}>> Entrar {00FF00}/y{e9dec8} por consentimiento y {FF0000}/n{e9dec8} para el rechazo");
		}
	}
	
	switch(Player[playerid][pLang])
	{
		case 0: SendClientMessageFormat(playerid, -1, "{e9dec8}>> You sent a duel request to %s!", Player[UserID][UserName]);
	    case 1: SendClientMessageFormat(playerid, -1, "{e9dec8}>> Вы отослали заявку игроку %s!", Player[UserID][UserName]);
	    case 2: SendClientMessageFormat(playerid, -1, "{e9dec8}>> Enviaste una solicitud de duelo a %s!", Player[UserID][UserName]);
	}
	return 1;
	
}

CMD:n(playerid)
{
	if(DuelReceived[playerid])
	{
		SendClientMessage(playerid, -1, "{e9dec8}>> You have denied the duel!");
		SendClientMessage(DuelerID[playerid], -1, "{e9dec8}>> The player denied your request!");
		DuelReceived[playerid] = false;
		DuelerID[playerid] = -1;
		
		DuelEXP[playerid] = 0;
		DuelRules[0][playerid] = 0;
		DuelRules[1][playerid] = 0;
	}
	else
	{
	    SendClientMessage(playerid, -1, "{C0C0C0}[Server] You aren't invited!");
	}
	return 1;
}

CMD:y(playerid)
{
    if(!CanPay) return 0;
	if(DuelReceived[playerid])
	{
	    new Float:hp[2];
		GetPlayerHealth(playerid, hp[0]);
		GetPlayerHealth(DuelerID[playerid], hp[1]);
		if(hp[0] <= 2.0 || hp[1] <= 2.0)
		{
		    SendClientMessage(playerid, -1, "You / Opponent isn't ready to accept the duel!");
			return 1;
		}
	    if(IsPlayerConnected(DuelerID[playerid]) && DuelerID[DuelerID[playerid]] == playerid && Player[DuelerID[playerid]][pLogged])
	    {
	        if(Player[playerid][pXP] < DuelEXP[playerid] || Player[DuelerID[playerid]][pXP] < DuelEXP[DuelerID[playerid]])
	        {
	            cmd::n(playerid);
	            return 1;
	        }
	        
	        SetPlayerTeamEx(DuelerID[playerid], NO_TEAM);
	        SetPlayerTeamEx(playerid, NO_TEAM);
	        
	        CanUseCBugTime[playerid] = 0;
	        CanUseCBugTime[DuelerID[playerid]] = 0;
	        
			SendClientMessage(playerid, -1, "{e9dec8}>> You have accepted the duel!");
			SendClientMessage(DuelerID[playerid], -1, "{e9dec8}>> The player accepted your request!");
			IsPlayerOnDuel[playerid] = true;
			IsPlayerOnDuel[DuelerID[playerid]] = true;
			DuelReceived[playerid] = false;
			CockroachAbility[playerid] = false;
			CockroachAbility[DuelerID[playerid]] = false;
			
			ResetWeapons(playerid);
			SetPlayerColor(playerid, 0x9900CCFF);
			SetPlayerSkinAC(playerid, 217, 1);
			SetPlayerPosAC(playerid, 1406.0436,-17.5633,1000.9139);
			SetPlayerFacingAngle(playerid, 90.8023);
			SetPlayerHealthAC(playerid, 100.0);
			
			if(DuelEXP[playerid] >= 1)
			{
				if(DuelRules[1][playerid] <= 0) SetPlayerArmourAC(playerid, 50.0);
				if(DuelRules[1][playerid] >= 2) SetPlayerArmourAC(playerid, 85.0);
			}
			else
			{
			    SetPlayerArmourAC(playerid, 50.0);
			}
			SetPlayerInterior(playerid, 1);
			SetPlayerVirtualWorld(playerid, 2 + playerid);
			GivePlayerWeaponAC(playerid, DuelerWeapon[DuelerID[playerid]], 9999, false);
			SetPlayerTime(playerid, 12, 0);
			SetPlayerWeather(playerid, 0);

			ResetWeapons(DuelerID[playerid]);
			SetPlayerColor(DuelerID[playerid], 0x9900CCFF);
			SetPlayerSkinAC(DuelerID[playerid], 217, 1);
			SetPlayerPosAC(DuelerID[playerid], 1373.0170,-17.2518,1000.9219);
			SetPlayerFacingAngle(DuelerID[playerid], 267.2106);
		    SetPlayerHealthAC(DuelerID[playerid], 100.0);
			
			if(DuelEXP[playerid] >= 1)
			{
				if(DuelRules[1][playerid] <= 0) SetPlayerArmourAC(DuelerID[playerid], 50.0);
				if(DuelRules[1][playerid] >= 2) SetPlayerArmourAC(DuelerID[playerid], 85.0);
			}
			else
			{
			    SetPlayerArmourAC(DuelerID[playerid], 50.0);
			}
			
			SetPlayerInterior(DuelerID[playerid], 1);
			SetPlayerVirtualWorld(DuelerID[playerid], 2 + playerid);
			GivePlayerWeaponAC(DuelerID[playerid], DuelerWeapon[DuelerID[playerid]], 9999, false);
			SetPlayerTime(DuelerID[playerid], 12, 0);
			SetPlayerWeather(DuelerID[playerid], 0);
			
			for( new i = 0; i < 10; i++) RemovePlayerAttachedObject(playerid, i);
			for( new i = 0; i < 10; i++) RemovePlayerAttachedObject(DuelerID[playerid], i);

			new gunname[32];
			GetWeaponName( DuelerWeapon[DuelerID[playerid]], gunname, sizeof(gunname));
			
			foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
			        case 0:
					{
						if(DuelEXP[playerid] <= 0) SendClientMessageFormat(i, -1, "{e9dec8}>> %s started a duel with %s. Weapon: %s (ID %d)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]]);
						else
						{
						    new rls[32];
						    switch(DuelRules[1][playerid])
						    {
						        case 1: rls = " and No Armour";
						        case 2: rls = " and 85 '/. of Armour";
								case 0: rls = " and 50 '/. of Armour";
								default: rls = " and 50 '/. of Armour";
							}
							
							SendClientMessageFormat(i, -1, "{e9dec8}>> %s started a duel with %s. Weapon: %s (ID %d) (Bet %d EXP) (Rule(s): %s%s)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]], DuelEXP[playerid], (DuelRules[0][playerid] >= 1) ? ("With C-BUG") : ("Without C-BUG"), rls);
						}
					}
					case 1:
					{
						if(DuelEXP[playerid] <= 0) SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s начал дуэль с игроком %s. Оружие: %s (ID %d)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]]);
						else
						{
						    new rls[32];
						    switch(DuelRules[1][playerid])
						    {
						        case 1: rls = " и Без Брони";
						        case 2: rls = " и 85 '/. брони";
								case 0: rls = " и 50 '/. брони";
								default: rls = " и 50 '/. брони";
							}

							SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s начал дуэль с игроком %s. Оружие: %s (ID %d) (Ставка %d ОПЫТА) (Правило(а): %s%s)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]], DuelEXP[playerid], (DuelRules[0][playerid] >= 1) ? ("С +C") : ("Без +C"), rls);
						}
					}
					case 2:
					{
						if(DuelEXP[playerid] <= 0) SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s comenzo un duelo con el jugador %s. Arma: %s (ID %d)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]]);
						else
						{
						    new rls[32];
						    switch(DuelRules[1][playerid])
						    {
						        case 1: rls = " y Sin armadura";
					            case 2: rls = " y 85 '/. de armadura";
								case 0: rls = " y 50 '/. de armadura";
								default: rls = " y 50 '/. de armadura";
							}

							SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s comenzo un duelo con el jugador %s. Arma: %s (ID %d) (Tasa %d EXP) (Regla(s): %s%s)", Player[playerid][UserName], Player[DuelerID[playerid]][UserName], gunname, DuelerWeapon[DuelerID[playerid]], DuelEXP[playerid], (DuelRules[0][playerid] >= 1) ? ("Con C-BUG") : ("Sin C-BUG"), rls);
						}
					}
				}
			}
		}
		else
		{
		    SendClientMessage(playerid, -1, "{e9dec8}>> The player did not invite you!");
		    IsPlayerOnDuel[playerid] = false;
		    DuelReceived[playerid] = false;
			DuelerID[playerid] = -1;
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, "{C0C0C0}[Server] You aren't invited!");
	}
	return 1;
}

CMD:savegangs(playerid)
{
    if(Player[playerid][pAdmin] <= 5) return 0;
	SaveGangs(true);
	SendClientMessage(playerid, -1, "Saved");
	return 1;
}

/*CMD:resetgangs(playerid)
{
    if(Player[playerid][pAdmin] <= 5) return 0;
    new query[128], i;
	for( i = 1; i < 30; i++ )
	{
		mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `Clan` = '%d' AND `ClanRank` < 6", i);
		mysql_tquery(Base, query, "ClearGangMembers", "i", i);
	}
	for( i = 1; i < 30; i++ )
	{
		Clan[i][g_MaxMembers] = cache_num_rows();
		printf("Gang #%d is %d of members!", i, cache_num_rows());
		SetGangBuff(i, Clan[i][g_MaxMembers]);
	}
    return 1;
}*/

/*
CMD:gangexp(playerid, params[])
{
    if(Player[playerid][pAdmin] <= 5) return 0;
    if(sscanf(params, "ii", params[0], params[1])) return SendClientMessage(playerid, -1, "/gangexp (gang) (exp)");
    if(params[0] <= 0) return SendClientMessage(playerid, -1, "/gangexp (gang) (exp)");
    if(params[1] <= 0) return SendClientMessage(playerid, -1, "/gangexp (gang) (exp)");
	Clan[params[0]][EXP] = params[1];
	SendClientMessage(playerid, -1, "Set");
	return 1;
}*/

stock UnloadFilterScript(filename[])
{
	new string[128];
	format(string, sizeof(string), "unloadfs %s", filename);
	SendRconCommand(string);

	//printf("Unloaded in %d sec", GetTickCount() - time);

	return 1;
}

CMD:test(playerid, params[])
{
	if(Player[playerid][pAccountID] == 1)
	{
	    if(sscanf(params, "d", params[0])) {
			SendClientMessage(playerid, -1, "/test (ID)");
			return 1;
		}
        UnlockAchievement(playerid, params[0]);
        return 1;
	}
	return 0;
}


CMD:load_event(playerid, params[])
{
	if(Player[playerid][pAccountID] == 1)
	{
	    new str[64];
	    if(sscanf(params, "s[64]", str)) {
			SendClientMessage(playerid, -1, "/load_event (filename)");
			return 1;
		}
        LoadFilterScript(str);
        strmid(EventFilterScript, str, 0, 128, 129);
        return 1;
	}
	return 0;
}

CMD:unload_event(playerid, params[])
{
	if(Player[playerid][pAccountID] == 1)
	{
	    new str[64];
	    if(sscanf(params, "s[64]", str)) {
			SendClientMessage(playerid, -1, "/unload_event (filename)");
			return 1;
		}
        UnloadFilterScript(str);
        strmid(EventFilterScript, "", 0, 128, 129);
        return 1;
	}
	return 0;
}

CMD:getobjects(playerid)
{
    if(Player[playerid][pAccountID] == 1)
	{
		new i, count;
		for(i = 0; i < 1000; i++) if(IsValidObject(i)) count++;
		SendClientMessageFormat(playerid, -1, "Server: %d | GateID: (ID %d) Model: %d | Gate2ID: (ID %d) Model: %d | Script: %s", count, mapGate, Map[m_GateID], mapGate2, Map[m_Gate2ID], Map[m_FSMapName]);
		return 1;
	}
	return 0;
}

CMD:setmap(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	 	if(sscanf(params,"i", params[0]))
		{
		    SendClientMessage(playerid, -1, "/setmap (id)");
			return 1;
		}
		
		new query[128];
	    mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name` FROM `maps` ORDER BY `ID` DESC LIMIT 1");
	 	mysql_tquery(Base, query, "LoadMapsCount");
	 	
        mapid = (params[0]-1);
		if((params[0]-1) > maps || params[0] <= 0) mapid = 0;
		
		foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s has set next map ID to %d", Player[playerid][RealName], mapid == 0 ? 1 : mapid+1);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /setmap\n```", Player[playerid][RealName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:skip(playerid)
{
	if(Player[playerid][pAdmin] > 2)
	{
	    if(!already_skipped)
	    {
	        if(Time <= 280)
	        {
				KillTimerEx(mapvar[0]);
				KillTimerEx(mapvar[1]);
				KillTimerEx(mapvar[2]);
				mapvar[2] = SetTimer("EndMap", MAX_RESTART_TIME, false);
				if(Player[playerid][pAdmin] <= 5)
				{
				    #if debug_mode == 0
			        new __action[128];
					DiscordChannel = DCC_FindChannelById("623193667628433438");
					format(__action, sizeof __action, "```\n%s used /skip\n```",  Player[playerid][RealName]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
				}
				already_skipped = true;
				return 1;
			}
			else
			{
			    SendClientMessage(playerid, -1, "Wait some time...");
			    return 1;
			}
		}
		else
		{
		    SendClientMessage(playerid, -1, "Already skipped");
		    return 1;
		}
	}
	return 0;
}

stock Justice(playerid)
{
    new Float:pos[4], j;
	GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	GetPlayerFacingAngle(playerid, pos[3]);

	j = CreateObject(18856, pos[0], pos[1], pos[2] + 2.5, 0.0, 0.0, pos[3]);
	SetTimerEx("RemoveObject", 15000, 0, "i", j);

	/*j = CreateObject(18751,  pos[0], pos[1], pos[2]-6.5,   0.00000, 0.00000, 0.0);
	for(new i = 0; i < 3; i++) SetObjectMaterial(j, i, 18752, "volcano", "LavaLake", 0);
	SetTimerEx("RemoveObject", 15000, 0, "i", j);*/

	SetPlayerPosAC(playerid, pos[0], pos[1], pos[2] + 1.5);
	CreateObjectsX(3524, pos[0], pos[1], pos[2], 0.0, 0.0, 35, 6.0, 15);

	CreateObjectsX(18691, pos[0], pos[1], pos[2], 0.0, 0.0, 10, 2.0, 15);

	ApplyAnimation(playerid, "SWEET", "Sweet_injuredloop", 4.1, 0, 0, 0, 0, 25000, 1);
	GameTextForPlayer(playerid, "~r~Sacrificed", 3000, 3);
	SetTimerEx("Drugsoff", 15000, false, "i", playerid);

	SetPlayerWeather(playerid, -84);
	SetPlayerDrunkLevel(playerid, 100000);
	SetPlayerTime(playerid,4,0);

	Player[playerid][IsBurned][0] = 1;
	Player[playerid][IsBurned][1] = 2;
	SetPlayerAttachedObject(playerid,9,18689,1,0.000000,-0.130999,-1.650999,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);

	FirstPerson[playerid] = CreateObject(19300, 0, 0, 0, 0, 0, 0);
	AttachObjectToPlayer(FirstPerson[playerid], playerid, 0.0, 0.13, 0.65, 0, 0, 0);
	AttachCameraToObject(playerid, FirstPerson[playerid]);
	SetTimerEx("RemoveObject", 15000, 0, "i", FirstPerson[playerid]);
}

fun ReturnToDefaultGravity(playerid)
{
    if(GravityReset[playerid])
    {
    	SetPlayerGravity(playerid, 1.0);
	}
	RemovePlayerAttachedObject(playerid, 9);
	GravityReset[playerid]= false;
	return 1;
}

fun RemoveFromCoffin(playerid)
{
	return 1;
}

fun Shovel(playerid, times)
{
	return 1;
}

public OnPlayerEditObject(playerid, playerobject, objectid, response, Float:fX, Float:fY, Float:fZ, Float:fRotX, Float:fRotY, Float:fRotZ)
{
	new Float:oldX, Float:oldY, Float:oldZ, Float:oldRotX, Float:oldRotY, Float:oldRotZ;
	GetObjectPos(objectid, oldX, oldY, oldZ);
	GetObjectRot(objectid, oldRotX, oldRotY, oldRotZ);
	if(!playerobject) // If this is a global object, sync the position for other players
	{
	    if(!IsValidObject(objectid)) return 1;
	    SetObjectPos(objectid, fX, fY, fZ);
	    SetObjectRot(objectid, fRotX, fRotY, fRotZ);
	}

	if(response == EDIT_RESPONSE_FINAL)
	{
		printf("CreateObject(%d, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, 300.0);", objectid, fX, fY, fZ, fRotX, fRotY, fRotZ);
	}

	if(response == EDIT_RESPONSE_CANCEL)
	{
		//The player cancelled, so put the object back to it's old position
		if(!playerobject) //Object is not a playerobject
		{
			SetObjectPos(objectid, oldX, oldY, oldZ);
			SetObjectRot(objectid, oldRotX, oldRotY, oldRotZ);
		}
		else
		{
			SetPlayerObjectPos(playerid, objectid, oldX, oldY, oldZ);
			SetPlayerObjectRot(playerid, objectid, oldRotX, oldRotY, oldRotZ);
		}
	}
	return 0;
}

fun CreateDisplayInfo(playerid, Float:x, Float:y, type, Float:toX, Float:toY, Float:step, time)
{
    if(GetUnlockedSlot(Player[playerid][pSettings], PS_ALERTS) == 1) return 0;
    if(alreadyNotificated[playerid] != type && alreadyNotificated[playerid] >= 0) return 0;
    
    alreadyNotificated[playerid] = type;
    
	new i, Float:size = 100.0;
	
	new text[96];
	switch(type)
	{
	    case 0: text = "~p~GANGWARS_~y~IN_15_MINUTES!";
		case 1: text = "~p~GANGWARS_~y~IN_30_MINUTES!";
        case 2: text = "~p~GANGWARS_~y~IN_45_MINUTES!";
        
        case 3: text = "~p~x2_EXP_~y~IN_5_MINUTES!";
        case 4: text = "~p~x2_EXP_~y~IN_10_MINUTES!";
		case 5: text = "~p~x2_EXP_~y~IN_15_MINUTES!";
        case 6: text = "~p~x2_EXP_~y~IN_30_MINUTES!";
        case 7: text = "~p~x2_EXP_~y~IN_45_MINUTES!";
        case 8: text = "~p~x2_EXP_~y~IN_1_HOUR!";
        case 9: text = "~p~x2_EXP_~y~IN_2_HOURS!";
        case 10: text = "~p~x2_EXP_~y~IN_3_HOURS!";
        
        case 11: text = "~y~YOUR_SHOP_ITEM_SOLD!";
        case 12: text = "~y~NEW_~p~PM~y~_notification!";
        case 13: text = "~p~NICE_DUDE!_~w~/chaos!";
        
        case 14: text = "~b~~h~~h~NEW_UPDATE!_~w~/news";
        case 15: text = "~g~~h~~h~NEW_ACHIEVEMENT!_~w~/achievements";
        
        case 16: text = "~p~GANGWARS_~y~IN_10_MINUTES!";
		case 17: text = "~p~GANGWARS_~y~IN_5_MINUTES!";
        case 18: text = "~p~GANGWARS_~y~has_begun!";
        
        case 19: text = "~p~x2_EXP_~y~has_begun!";
        case 20: text = "~p~x2_EXP_~y~is_gone!";
	}
	
	size = float(strlen(text))*6.8;
	if(type == 12) size -= 25.0;
	if(type == 15) size -= 35.0;

 	new Float:iDistance = 20.0,
		Float:tDistance = ((size - iDistance) / 1.75); // BOX: 558.0000 - Text: 485.0000 [73]
	 	// BOX: 558.0000 - Image: 462.0000 [96]
	if(step >= 0.1 && x > toX)
	{
		x -= step;
		for( i = 0; i < sizeof(DisplayAlerts); i++)
		{
			TextDrawHideForPlayer(playerid, DisplayAlerts[i][playerid]);
			TextDrawDestroy(DisplayAlerts[i][playerid]);
	    }

	    DisplayAlerts[0][playerid] = TextDrawCreate(x, 354.9375, "Box"); // ?????
		TextDrawLetterSize(DisplayAlerts[0][playerid], 0.0000, 1.4000);
		TextDrawTextSize(DisplayAlerts[0][playerid], (x + size), 0.0000); // (x + size)
		TextDrawAlignment(DisplayAlerts[0][playerid], 1);
		TextDrawColor(DisplayAlerts[0][playerid], 187);
		TextDrawUseBox(DisplayAlerts[0][playerid], 1);
		TextDrawBoxColor(DisplayAlerts[0][playerid], 85);
		TextDrawBackgroundColor(DisplayAlerts[0][playerid], 187);
		TextDrawFont(DisplayAlerts[0][playerid], 1);
		TextDrawSetProportional(DisplayAlerts[0][playerid], 1);
		TextDrawSetShadow(DisplayAlerts[0][playerid], 0);

		DisplayAlerts[1][playerid] = TextDrawCreate(x + tDistance, 355.3750, text); // ?????
		TextDrawLetterSize(DisplayAlerts[1][playerid], 0.2588, 1.2848);
		TextDrawTextSize(DisplayAlerts[1][playerid], 0.0000, 413.0000);
		TextDrawAlignment(DisplayAlerts[1][playerid], 2);
		TextDrawColor(DisplayAlerts[1][playerid], -1);
		TextDrawBackgroundColor(DisplayAlerts[1][playerid], 255);
		TextDrawFont(DisplayAlerts[1][playerid], 2);
		TextDrawSetProportional(DisplayAlerts[1][playerid], 1);
		TextDrawSetShadow(DisplayAlerts[1][playerid], 1);

		DisplayAlerts[2][playerid] = TextDrawCreate(x - iDistance, 349.2500, "ld_shtr:kami"); // ?????
		TextDrawTextSize(DisplayAlerts[2][playerid], 31.0000, 21.0000);
		TextDrawAlignment(DisplayAlerts[2][playerid], 1);
		TextDrawColor(DisplayAlerts[2][playerid], -2139062017);
		TextDrawBackgroundColor(DisplayAlerts[2][playerid], 255);
		TextDrawFont(DisplayAlerts[2][playerid], 4);
		TextDrawSetProportional(DisplayAlerts[2][playerid], 0);
		TextDrawSetShadow(DisplayAlerts[2][playerid], 0);

		for( i = 0; i < sizeof(DisplayAlerts); i++) TextDrawShowForPlayer(playerid, DisplayAlerts[i][playerid]);
		SetTimerEx("CreateDisplayInfo", 30, 0, "iffifffi", playerid, x, y, type, toX, toY, step, time);
		return 0;
	}
	
	if(time >= 1 && step >= 0.1)
	{
		for( i = 0; i < sizeof(DisplayAlerts); i++) TextDrawShowForPlayer(playerid, DisplayAlerts[i][playerid]);
		SetTimerEx("CreateDisplayInfo", time, 0, "iffifffi", playerid, x, y, type, toX+1024.0, toY, -step, 0);
		return 0;
	}
	
	if(step <= -0.1)
	{
		if(x < toX)
		{
			x -= step;
		    for( i = 0; i < sizeof(DisplayAlerts); i++)
			{
				TextDrawHideForPlayer(playerid, DisplayAlerts[i][playerid]);
				TextDrawDestroy(DisplayAlerts[i][playerid]);
		    }

		    DisplayAlerts[0][playerid] = TextDrawCreate(x, 354.9375, "Box"); // ?????
			TextDrawLetterSize(DisplayAlerts[0][playerid], 0.0000, 1.4000);
			TextDrawTextSize(DisplayAlerts[0][playerid], (x + size), 0.0000); // (x + size)
			TextDrawAlignment(DisplayAlerts[0][playerid], 1);
			TextDrawColor(DisplayAlerts[0][playerid], 187);
			TextDrawUseBox(DisplayAlerts[0][playerid], 1);
			TextDrawBoxColor(DisplayAlerts[0][playerid], 85);
			TextDrawBackgroundColor(DisplayAlerts[0][playerid], 187);
			TextDrawFont(DisplayAlerts[0][playerid], 1);
			TextDrawSetProportional(DisplayAlerts[0][playerid], 1);
			TextDrawSetShadow(DisplayAlerts[0][playerid], 0);

			DisplayAlerts[1][playerid] = TextDrawCreate(x + tDistance, 355.3750, text); // ?????
			TextDrawLetterSize(DisplayAlerts[1][playerid], 0.2588, 1.2848);
			TextDrawTextSize(DisplayAlerts[1][playerid], 0.0000, 413.0000);
			TextDrawAlignment(DisplayAlerts[1][playerid], 2);
			TextDrawColor(DisplayAlerts[1][playerid], -1);
			TextDrawBackgroundColor(DisplayAlerts[1][playerid], 255);
			TextDrawFont(DisplayAlerts[1][playerid], 2);
			TextDrawSetProportional(DisplayAlerts[1][playerid], 1);
			TextDrawSetShadow(DisplayAlerts[1][playerid], 1);

			DisplayAlerts[2][playerid] = TextDrawCreate(x - iDistance, 349.2500, "ld_shtr:kami"); // ?????
			TextDrawTextSize(DisplayAlerts[2][playerid], 31.0000, 21.0000);
			TextDrawAlignment(DisplayAlerts[2][playerid], 1);
			TextDrawColor(DisplayAlerts[2][playerid], -2139062017);
			TextDrawBackgroundColor(DisplayAlerts[2][playerid], 255);
			TextDrawFont(DisplayAlerts[2][playerid], 4);
			TextDrawSetProportional(DisplayAlerts[2][playerid], 0);
			TextDrawSetShadow(DisplayAlerts[2][playerid], 0);

			for( i = 0; i < sizeof(DisplayAlerts); i++) TextDrawShowForPlayer(playerid, DisplayAlerts[i][playerid]);
			SetTimerEx("CreateDisplayInfo", 30, 0, "iffifffi", playerid, x, y, type, toX, toY, step, time);
			return 0;
		}
		else
		{
		    for( i = 0; i < sizeof(DisplayAlerts); i++)
			{
				TextDrawHideForPlayer(playerid, DisplayAlerts[i][playerid]);
				TextDrawDestroy(DisplayAlerts[i][playerid]);
				alreadyNotificated[playerid] = -1;
		    }
		}
		return 0;
	}
	return 1;
}

fun ShowVIPShop(playerid)
{
    new s[48], dial[1600];
    format(s, sizeof(s), "Shop{ffd633} (%.2f ZAPs)", Player[playerid][pBalance]);
	strcat(dial, "{ffd633}--------------[VIP SHOP]--------------\n{ffd633}Bronze VIP - 4 ZAPs (30 days)\n{ffd633}Silver VIP - 7 ZAPs (30 days)\n{ffd633}Gold VIP - 10 ZAPs (30 days)");
    ShowPlayerDialog(playerid, DIALOG_VIP_SHOP, DIALOG_STYLE_LIST, s, dial, "Buy", "Cancel");
    return 1;
}

CMD:shop(playerid)
{
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
    {
		ShowZombieShop(playerid);
    	return 1;
	}
	return 0;
}

stock ShowZombieShop(playerid)
{
	/*if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Time <= 250)
	{
	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{33cc33}Shop", "All goods have already been bought", "Ok", "");
		return 1;
	}*/
	
    new dial[600], frmt[300];
    format(frmt, sizeof(frmt), "{FFFFFF}Anti-Seeker - %d EXP\n\
	Anti-Freezer - %d EXP\n\
	Armour - %d EXP (No Radioactive Field)\n\
	Anti-Burning - %d EXP\n\
	Morphine - %d EXP (No Leg Breaks)\n\
	{FF0000}Anti-Screamer - %d EXP\n\
	{FFFFFF}Anti-Blind - %d EXP\n\
	Helmet - %d EXP (No headshots)",
    ShopPrices[0], ShopPrices[1],
    ShopPrices[2], ShopPrices[3], ShopPrices[4],
    ShopPrices[5], ShopPrices[6], ShopPrices[7]);
    strcat(dial, frmt);
    
    if(Map[m_GangControll] > 0) {
		format(frmt, sizeof(frmt), "\n[CASTLE]: Exchange conquest rewards for EXP (%d)", Player[playerid][pPlayerKills]);
        strcat(dial, frmt);
    }
    
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) {
	    new gid = Map[m_GangControll];
	    new mygid = Player[playerid][pClan];
	    
	    if(mygid == Map[m_GangControll] || Clan[gid][g_AllianceWith][mygid] >= 2) {
		    new ar_price = max(15, 40 - Clan[gid][g_OwnedMaps]),
		        ar_bonus = max(50, 50+(floor(float(min(Clan[gid][g_OwnedMaps], 15))*1.67))),
		        damage_price = 30 + (min(Clan[gid][g_OwnedMaps], 15)*12);

	      	format(frmt, sizeof(frmt), "\n{b338ff}[CASTLE]: %d '/. ARMOR - %d EXP\n{b338ff}[CASTLE]: Increased Damage - %d EXP", ar_bonus, ar_price, damage_price);
	        strcat(dial, frmt);
		 }
	}
	
	ShowPlayerDialog(playerid, DIALOG_ZOMBIE_SHOP, DIALOG_STYLE_LIST, "{33cc33}Shop", dial, "Buy", "Cancel");
	return 1;
}

CMD:att(playerid)
{
    new string[128], ind = 0;
    if(Player[playerid][e_Days] >= 349) ind = 1;
    for(new x;x<4+ind;x++)
    {
    	if(IsPlayerAttachedObjectSlotUsed(playerid, x)) format(string, sizeof(string), "%s%d (Used)\n", string, x);
     	else format(string, sizeof(string), "%s%d\n", string, x);
    }
    ShowPlayerDialog(playerid, DIALOG_ATTACH_INDEX_SELECTION, DIALOG_STYLE_LIST, "{FF0000}Attachment Modification - Index Selection", string, "Select", "Cancel");
	return 1;
}

CMD:vipmenu(playerid)
{
	if(Time <= 0) {
	    SendClientMessage(playerid, -1, "{FFF000}>> Time is up, try in the next round!");
	    return 1;
	}
	if(Player[playerid][pVip] <= 2) {
	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}VIP MENU", "This section is only for VIP Level 3+", "Ok", "");
	    return 1;
	}
	ShowPlayerDialog(playerid, DIALOG_VIP_MENU, DIALOG_STYLE_LIST, "{FFFFFF}VIP MENU", "{FFFFFF}- Start a Round as a {00CCCC}Human\n{FFFFFF}- Start a Round as a {99CC00}Zombie\n{FFFFFF}Reset To Random", "Select", "Close");

	return 1;
}

CMD:vips(playerid)
{
    SendClientMessage(playerid, -1, "{FF500A}VIPS online");
	foreach(Player, i)
	{
	    if(Player[i][pVip] >= 1 || FakeData[i][2] >= 1)
	    {
	        SendClientMessageFormat(playerid, -1, "%s Level: %d", Player[i][UserName], min(3, Player[i][pVip]+FakeData[i][2]));
	    }
	}
	return 1;
}

CMD:dance(playerid, params[])
{
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE || IsPlayerInRangeOfPoint(playerid, 30.0, 493.390991, -22.722799, 1000.679687) && GetPlayerInterior(playerid) == 17)
	{
	    if(sscanf(params,"i", params[0]))
		{
		    SendClientMessage(playerid, -1, "/dance (1-4)");
			return 1;
		}
		if(params[0] < 1 || params[0] > 4)
		{
		    SendClientMessage(playerid, -1, "/dance (1-4)");
			return 1;
		}
		SetPlayerSpecialAction(playerid, 5+params[0]);
		return 1;
	}
	return 1;
}

CMD:radio(playerid)
{
    if(GetUnlockedSlot(Player[playerid][pSettings], PS_MUSIC) == 0) PlayAudioStreamForPlayer(playerid, "http://ep256.hostingradio.ru:8052/europaplus256.mp3");
    return 1;
}

CMD:dleave(playerid)
{
    if(IsPlayerOnDuel[playerid])
	{
		DeathInDuel(playerid);
		setupZombie(playerid);
		SpawnPlayer(playerid);
	}
	else
	{
	    switch(Player[playerid][pLang])
	    {
	    	case 0: SendClientMessage(playerid, -1, "{FFF000}You need to be in a duel!");
	    	case 1: SendClientMessage(playerid, -1, "{FFF000}Вам нужно быть в дуэле!");
	    	case 2: SendClientMessage(playerid, -1, "{FFF000}Necesitas estar en un duelo!");
		}
	}
	return 1;
}

CMD:cmds(playerid)
{
    SendClientMessage(playerid, -1, "{737373}GLOBAL COMMANDS:{b3b3b3} /help /rules /report (/votekick) /cmds /class /maps /stats /ss /radio /settings /pm (Private Message)");
    SendClientMessage(playerid, -1, "{737373}GLOBAL COMMANDS:{b3b3b3} /discordpm (Discord Private Conversation)");
	SendClientMessage(playerid, -1, "{737373}GLOBAL COMMANDS:{b3b3b3} /lastlogin /trade /givevip (/accept) /ask /r(eply) /ignore /unignore /givezaps");
    SendClientMessage(playerid, -1, "{737373}CLASS COMMANDS:{b3b3b3} /cure (Medics) /giveammo (Heavy Support)");
    SendClientMessage(playerid, -1, "{737373}VIP COMMANDS:{b3b3b3} /skin /changename (Free for VIPs) /vipmenu (VIPs 3+) /kickback (VIPs 3+)");
	SendClientMessage(playerid, -1, "{737373}DUEL COMMANDS:{b3b3b3} /duel /dleave (To leave the duel) /weapons (To see Weapon's ID)");
    SendClientMessage(playerid, -1, "{737373}LOCAL EVENT COMMANDS:{b3b3b3} /event help");
	return 1;
}

CMD:lastlogin(playerid, params[])
{
	if(sscanf(params, "i", params[0]))
	{
	    SendClientMessage(playerid, -1, "{cdcdcd}>> /lastlogin (Account ID)");
	    return 1;
	}
	if(params[0] < 1)
	{
	    SendClientMessage(playerid, -1, "{cdcdcd}>> /lastlogin (Account ID)");
	    return 1;
	}
	
	new query[200];
	mysql_format(Base, query, sizeof(query), "SELECT userinfo.*, users.Name FROM userinfo JOIN users WHERE userinfo.id = '%d' AND users.ID = '%d' LIMIT 1;", params[0], params[0]);
	mysql_tquery(Base, query, "ShowLastUserLogin", "i", playerid);
	return 1;
}

CMD:accept(playerid, params[])
{
	new query[1024], t[400], p = -1, type[10];
	if(sscanf(params, "i", p))
	{
	    SendClientMessage(playerid, -1, "/accept (playerid)");
	    return 1;
	}
	if(!IsPlayerConnected(p))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}

	new pl = GetPVarInt(playerid, "pl");

	if(!IsPlayerConnected(pl))
	{
	    ClearPlayerShopInfo(pl);
	    ClearPlayerShopInfo(playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Aborted!");
		return 1;
	}

	if(gettime() > GetPVarInt(pl, "buyt") && GetPVarInt(pl, "buyt") > 0)
	{
	    ClearPlayerShopInfo(playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Time is up!");
		return 1;
	}

	new stype = GetPVarInt(playerid, "stype");
	new inx = GetPVarInt(playerid, "inx");
	new pr = GetPVarInt(playerid, "pr");
	//new vp = GetPVarInt(playerid, "vp");
	//new ct = GetPVarInt(playerid, "ct");
	format(t, sizeof(t), "\n{4db8ff}You are ready to accept the exchange with another player\n{4db8ff}Check the information for compliance with your agreement\n{4db8ff}with him / her to avoid misunderstanding\n\n{0099ff}+ Buyer (You): {FFFFFF}%s\n{0099ff}- Seller (He / She):{FFFFFF} %s\n\n", Player[playerid][UserName], Player[pl][UserName]);
    strcat(query, t);
	switch(stype)
	{
	    case 2:
		{
		    if(inx <= -1)
		    {
		        ClearPlayerShopInfo(playerid);
		        SendClientMessage(playerid, -1, "{FFFFFF}Unexpected error (NULL)");
		        return 1;
		    }
		    type = "VIP";
		    new vsn[3][] = {"Bronze VIP", "Silver VIP", "Gold VIP"};
			format(t, sizeof(t), "{0099ff}+ Name: {FFFFFF}%s\n{0099ff}+ Full Info:{FFFFFF} %s\n\n", type, vsn[inx]);
	        strcat(query, t);
			if(pr > 0)
			{
				format(t, sizeof(t), "{0099ff}+ Price/EXP: {FFFFFF}%d\n{0099ff}+ Count: {FFFFFF}%d\n\n\n", pr, 1);
	        	strcat(query, t);
	        	ShowPlayerDialog(playerid, DIALOG_SHOP_ITEMS, DIALOG_STYLE_MSGBOX, "{0099ff}Shop", query, "Cancel", "Buy");
			}
	        else ShowPlayerDialog(playerid, DIALOG_SHOP_ITEMS, DIALOG_STYLE_MSGBOX, "{0099ff}Shop", query, "Cancel", "Take");
		}
	}
	return 1;
}

CMD:givezaps(playerid, params[])
{
    if(Player[playerid][pBalance] < 1.0)
	{
	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_LIST, "Info", "You need atleast 1 ZAP to give it", "Ok", "");
		return 1;
	}
    if(IsUsingProxy{playerid})
	{
	    SendClientMessage(playerid, -1, ">> There is something wrong with your connection. Try disabling VPN.");
		return 1;
	}
	if(isnull(params))
	{
	    SendClientMessage(playerid, -1, "/givezaps (playerid) (count)");
		return 1;
	}
	new pl = -1, ct = -1;
	sscanf(params, "ii", pl, ct);
	if(!IsPlayerConnected(pl))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(ct <= 0)
	{
	    SendClientMessage(playerid, -1, "/givezaps (playerid) (count)");
		return 1;
	}
	if(playerid == pl)
	{
	    SendClientMessage(playerid, -1, "/givezaps (playerid) (count)");
		return 1;
	}
	if(floor(Player[playerid][pBalance]) < ct)
	{
	    SendClientMessage(playerid, -1, "Not enough zaps!");
	    return 1;
	}

	new query[256];
	mysql_format(Base, query, sizeof(query), "SELECT `Secret` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
	mysql_tquery(Base, query, "TryToGiveZaps", "iii", playerid, pl, ct);
	return 1;
}

CMD:givevip(playerid, params[])
{
	if(Player[playerid][pBalance] < 4.0)
	{
	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_LIST, "Info", "You need atleast 4 ZAPs to give a VIP", "Ok", "");
		return 1;
	}
    if(isnull(params))
	{
	    SendClientMessage(playerid, -1, "/givevip (playerid) (vip name, [...price])");
		return 1;
	}

	new pl = -1, nm[10]="", pr = -1, vns[3][] = {"Bronze VIP", "Silver VIP", "Gold VIP"}, Float:vpp[3] = {4.0, 7.0, 10.0};
	sscanf(params, "is[16]i", pl, nm, pr);

	if(!IsPlayerConnected(pl))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(pl == playerid)
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(strlen(nm) <= 3)
	{
	    SendClientMessage(playerid, -1, "/givevip (playerid) (vip name, [...price])");
		return 1;
	}
	for( new i; i < sizeof(vns); i++ )
	{
		if(strfind(vns[i], nm, true) != -1)
		{
			if(Player[playerid][pBalance] < vpp[i])
			{
			    SendClientMessageFormat(playerid, -1, "{FFF000}>> You do not have enough ZAPs %.0f need", vpp[i] - Player[playerid][pBalance]);
			    return 1;
			}
			else
			{
			    if(pr > 0)
				{
					SendClientMessageFormat(pl, -1, "{2fa192}>> %s is selling you a %s. Price:{FFFFFF} %d{2fa192} exp, use /accept %d", Player[playerid][UserName], vns[i], pr, playerid);
					SendClientMessageFormat(playerid, -1, "{2fa192}>> You are selling a %s to %s for {FFFFFF}%d{2fa192} exp.",vns[i], Player[pl][UserName], pr - floor(pr*TAXES));
				}
				else
				{
					SendClientMessageFormat(pl, -1, "{2fa192}>> %s gives you a %s. Use /accept %d", Player[playerid][UserName], vns[i], playerid);
	                SendClientMessageFormat(playerid, -1, "{2fa192}>> You gives a %s to %s", vns[i], Player[pl][UserName]);
				}
				SetPVarInt(pl, "stype", 2);
				SetPVarInt(pl, "pl", playerid);
				SetPVarInt(pl, "inx", i);
				SetPVarInt(pl, "pr", pr);
				SetPVarInt(pl, "vp", 0);
				SetPVarInt(pl, "clbuy", 1);
				SetPVarInt(pl, "buyt", gettime() + 15);
				return 1;
			}
		}
	}
	return 1;
}

fun ShowLastUserLogin(playerid)
{
	if(cache_num_rows() > 0)
	{
	    new ll, Name[24];
	    cache_get_value_name_int(0, "last_log", ll);
	    if(ll > 0)
	    {
		    cache_get_value_name(0, "Name", Name, 24);
		    new y, m, d, h, i, s;
			TimestampToDate(ll, y, m, d, h, i, s, 3);
		    SendClientMessageFormat(playerid, -1, "{E68687}>> %s's last login: %04d-%02d-%02d at %02d:%02d", Name, y, m, d, h, i);
		}
		else SendClientMessage(playerid, -1, "{E68687}>> Unknow");
	}
	return 1;
}

CMD:admins(playerid)
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    SendClientMessage(playerid, -1, "{00CCCC}Online Admins:");
	    SendClientMessage(playerid, -1, "{FFFFFF}>> Amelia (Level: 1){ff3300} (Sleeping)");
		foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged] && FakeData[i][7] <= 0)
			{
			    if(Player[i][aDuty]) SendClientMessageFormat(playerid, -1, "{FFFFFF}>> %s (ID: %d) (Level: %d){ff3300} (On Duty)", Player[i][RealName], i, Player[i][pAdmin]);
				else SendClientMessageFormat(playerid, -1, "{FFFFFF}>> %s (ID: %d) (Level: %d)", Player[i][RealName], i, Player[i][pAdmin]);
			}
		}
		SendClientMessage(playerid, -1, "{FFFFFF}--------------------------------------------");
	}
	else
	{
	    foreach(Player, i) if(Player[i][pAdmin] > 0 && !Player[i][CanCheckCMD] && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> %s(%d) used /admins", Player[playerid][UserName], playerid);
	    SendClientMessage(playerid, -1, "{FF0000}No admins online!");
	}
	return 1;
}

static const help_page[][][] = {
	{
        "Humans(Blue) kill another team - Zombies(Green)",
        "Zombies(Green), kill another team - Humans(Blue)",
       	"For killing a member of another team, you will gain EXP (/stats, TAB -> Score), later you can open new classes (/class)",
	    "EXP does not disappear when choosing a class",
		"You can use the LEFT ALT to use the class abilities (If it is)",
		"Medics have access to the command /cure (player's ID)",
		"Heavy Support have access to the command /giveammo (player's ID)",
		"In the left corner of the screen - there is a time that you need to survive, as soon as it ends - get to the Checkpoint"
	},
	{
        "Люди(Синие) убивайте другую команду - Зомби(Зеленые)",
        "Зомби(Зеленые), убивайте другую команду - Люди(Синие)",
       	"За убийство члена другой команды вы получите EXP (/stats, TAB -> Score), позднее вы сможите открыть новые классы (/class)",
	    "Опыт не пропадает при выборе класса",
		"Вы можете использовать ЛЕВЫЙ АЛЬТ, чтобы активировать способность класса (Если есть)",
		"Медики могут использовать команду /cure (ID игрока), чтобы вылечить игрока от заражения",
		"Тяжелая Поддержка может давать патроны командой /giveammo (ID игрока), запас ограничен",
		"В левом нижнем углу - это время которое вам нужно прожить перед эвакуацией, как только оно закончится - бегите к чекпоинту (только Люди [Синяя команда])"
	},
	{
        "Humans(Blue) kill another team - Zombies(Green)",
        "Zombies(Green), kill another team - Humans(Blue)",
       	"For killing a member of another team, you will gain EXP (/stats, TAB -> Score), later you can open new classes (/class)",
	    "EXP does not disappear when choosing a class",
		"You can use the LEFT ALT to use the class abilities (If it is)",
		"Medics have access to the command /cure (player's ID)",
		"Heavy Support have access to the command /giveammo (player's ID)",
		"In the left corner of the screen - there is a time that you need to survive, as soon as it ends - get to the Checkpoint"
	}
};

CMD:help(playerid)
{
	new i, l = Player[playerid][pLang], d[1024];
    for( i = 0; i < sizeof(help_page[]); i++ ) {
        strcat(d, help_page[l][i]);
        strcat(d, "\n");
    }
    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "HELP", d, "Ok", "");
	return 1;
}

CMD:rules(playerid)
{
    new str[1600];
    switch(Player[playerid][pLang])
    {
        case 0:
        {
		    strcat(str, "1. You are not allowed to use any kind of hacks/programms that would give you an advantage over the players\n");
			strcat(str, "2. You are not allowed to stay or shoot at zombie's spawn area if you have been spawned as a human\n");
			strcat(str, "3. You are not allowed to block player's way (by human)\n");
			strcat(str, "4. You are not allowed to abuse bugs\n");
			strcat(str, "5. You are not allowed to go out of map\n");
			strcat(str, "7. You are not to demonstrate your hate to others races/nationalities, discuss the politics\n");
			strcat(str, "8. You are not allowed to insult player's honour, trying to humiliate somebody or hurt somebody's feelings\n");
			strcat(str, "9. You are not allowed to prevent player's game, punching them\n");
			strcat(str, "10. You are not allowed to spam/flood at server.(Spam is considered from 5 messages in chat)\n");
			strcat(str, "11. You are not allowed to advertise any servers, unknown links that are not confirmed by the Management Team\n");
			strcat(str, "12. You are allowed to bunny hop, except for these zombies classes: Boomer, Demon, Kamikadze\n");
			strcat(str, "13. You are not allowed to killing friends, etc. for pumping your EXP, doesn't swing the farming of killing an enemy team\n");
			strcat(str, "14. You are not allowed to spam asking / begging for xp\n");
			strcat(str, "15. You do not have the right to sell gaming experience for real money if such actions are noticed - yours and the account of another player will be deleted");
		    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Rules", str, "Ok", "");
		}
		case 1:
		{
		    strcat(str, "1. Вам не разрешается использовать какие-либо читы / программы, которые дадут вам преимущество перед игроками.\n");
			strcat(str, "2. Вам не разрешается оставаться или стрелять в зону возрождения зомби, если вы были возрождены как человек\n");
			strcat(str, "3. Вы не можете заблокировать путь игрока (играя человеком)\n");
			strcat(str, "4. Вам запрещено пользоватся багами сервера\n");
			strcat(str, "5. Вам запрещено выходить из карты, до эвакуации\n");
			strcat(str, "7. Вы не должны демонстрировать свою ненависть к другим расам / народам, обсуждать политику\n");
			strcat(str, "8. Вы не можете оскорблять честь игрока, пытаться кого-то унизить или обидеть\n");
			strcat(str, "9. Вы не можете помешать игре игрока, избивать его\n");
			strcat(str, "10. Вам запрещено спамить / флудить на сервере\n");
			strcat(str, "11. Вы не имеете права рекламировать любые серверы, неизвестные ссылки, которые не подтверждены Командой управления\n");
			strcat(str, "12. Вам разрешено использовать банихоп, кроме этих классов зомби: Бумер, Демон, Камикадзе\n");
			strcat(str, "13. Вы не можете убивать друзей, чтобы быстро получить опыт (Совместный фарминг)\n");
			strcat(str, "14. Вам не разрешено спамить / просить / умолять дать XP\n");
			strcat(str, "15. Вы не имеете права продавать игровой опыт за реальные деньги, если такие действия замечены - ваша учетная запись другого игрока будет удалена");
		    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Правила", str, "Ok", "");
		}
		default:
		{
		    strcat(str, "1. No esta permitido usar ningun tipo de hacks / programas que le den una ventaja sobre los jugadores\n");
			strcat(str, "2. No puedes quedarte ni disparar al бrea de desove de zombies si has sido engendrado como humano\n");
			strcat(str, "3. No tienes permitido bloquear el camino del jugador (por humano)\n");
			strcat(str, "4. No estб permitido abusar de los errores\n");
			strcat(str, "5. No tienes permitido salir del mapa\n");
			strcat(str, "7. No debes demostrar tu odio a otras razas / nacionalidades, discutir la polнtica\n");
			strcat(str, "8. No estб permitido insultar el honor del jugador, tratar de humillar a alguien o herir los sentimientos de alguien\n");
			strcat(str, "9. No estб permitido evitar el juego del jugador, golpeбndolo\n");
			strcat(str, "10. No estб permitido enviar spam / inundaciones en el servidor\n");
			strcat(str, "11. No estб autorizado a anunciar ningъn servidor, enlaces desconocidos que el equipo de gestiуn no ha confirmado\n");
			strcat(str, "12. Se te permite hacer bunnyhop, a excepciуn de estas clases de zombies: Boomer, Demon, Kamikadze\n");
			strcat(str, "13. No estб permitido matar amigos, etc. por bombear su EXP, no hace que la agricultura de matar a un equipo enemigo\n");
			strcat(str, "14. No estб permitido hacer spam pidiendo XP\n");
			strcat(str, "15. No tiene derecho a vender experiencia de juego por dinero real si se notan tales acciones: la suya y la cuenta de otro jugador se eliminaran");
		    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Reglas", str, "Ok", "");
		}
	}
	return 1;
}

CMD:kickback(playerid)
{
	if(Player[playerid][pVip] >= 1)
	{
		Player[playerid][KickBack] =!Player[playerid][KickBack];
		if(Player[playerid][KickBack]) SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][153]);
		else SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][154]);
		return 1;
	}
	return 0;
}

/*CMD:changesword(playerid, params[])
{
    if(IsUsingProxy{playerid})
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
		return 1;
	}
	if(GetUnlockedSlot(Player[playerid][pSettings], PS_IAP) == 0)
    {
        SendClientMessage(playerid, -1, "{FFF000}>> In order to protect your account you need to enable IAP (/settings)");
		return 1;
    }
	new password[128], secretword[64];
    if(sscanf(params,"s[128]s[64]", password, secretword))
	{
	    SendClientMessage(playerid, -1, "/changesword (new secret word) (old secret word)");
		return 1;
	}
    new query[300];
    mysql_format(Base, query, sizeof(query), "SELECT `Secret` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
    mysql_tquery(Base, query, "TryToChangeSecret", "iss", playerid, password, secretword);
	return 1;
}*/

fun TryToChangeSecret(playerid, const password[], const secretword[])
{
    if(cache_num_rows() > 0)
	{
	    new secret[64];
   		cache_get_value_name(0, "Secret", secret, 65);
	   	if(!strcmp(secretword, secret, true))
	   	{
	   	    for( new i = strlen(password); i > -1; i-- )
		  	{
			  	if(password[i] == ' ')
			  	{
			  	    SendClientMessage(playerid, -1, "{FFF000}>> Spaces ins't allowed!");
			  		return 1;
				}
			}
			new query[200];
	   	    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Secret` = '%e' WHERE `ID` = '%d'", password, Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
			SendClientMessageFormat(playerid, -1, "{FFF000}>> Your secret word has been changed to:{FFFFFF} %s", password);
	   	}
	   	else
	   	{
	   	    SendClientMessage(playerid, -1, "{FFF000}>> The entered data is incorrect!");
	   	}
	}
	return 1;
}

/*CMD:changeemail(playerid, params[])
{
    if(IsUsingProxy{playerid})
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
		return 1;
	}
	new password[128], secretword[64];
    if(sscanf(params,"s[128]s[64]", password, secretword))
	{
	    SendClientMessage(playerid, -1, "/changeemail (new email) (secret word)");
		return 1;
	}
    new query[300];
    mysql_format(Base, query, sizeof(query), "SELECT `Secret` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
    mysql_tquery(Base, query, "TryToChangeEmail", "iss", playerid, password, secretword);
	return 1;
}*/

fun TryToChangeEmail(playerid, const password[], const secretword[])
{
    if(cache_num_rows() > 0)
	{
	    new secret[64];
   		cache_get_value_name(0, "Secret", secret, 65);
	   	if(!strcmp(secretword, secret, true))
	   	{
	   	    for( new i = strlen(password); i > -1; i-- )
		  	{
			  	if(password[i] == ' ')
			  	{
			  	    SendClientMessage(playerid, -1, "{FFF000}>> Spaces ins't allowed!");
			  		return 1;
				}
			}
			new query[200];
	   	    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Email` = '%e' WHERE `ID` = '%d'", password, Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
			SendClientMessageFormat(playerid, -1, "{FFF000}>> Your email has been changed to:{FFFFFF} %s", password);
	   	}
	   	else
	   	{
	   	    SendClientMessage(playerid, -1, "{FFF000}>> The entered data is incorrect!");
	   	}
	}
	return 1;
}

/*CMD:changepass(playerid, params[])
{
    if(IsUsingProxy{playerid})
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
		return 1;
	}
	new password[64], secretword[64];
    if(sscanf(params,"s[64]s[64]", password, secretword))
	{
	    SendClientMessage(playerid, -1, "/changepass (new pass) (secret word)");
		return 1;
	}
    new query[300];
    mysql_format(Base, query, sizeof(query), "SELECT `Password`,`Secret` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
    mysql_tquery(Base, query, "TryToChangePassword", "iss", playerid, password, secretword);
	return 1;
}*/

fun TryToChangePassword(playerid, const password[], const secretword[])
{
    if(cache_num_rows() > 0)
	{
	    new pass[64], secret[64];
    	cache_get_value_name(0, "Password", pass, 65);
   		cache_get_value_name(0, "Secret", secret, 65);
	   	if(!strcmp(secretword, secret, true))
	   	{
	   	    for( new i = strlen(password); i > -1; i-- )
		  	{
			  	if(password[i] == ' ')
			  	{
			  	    SendClientMessage(playerid, -1, "{FFF000}>> Spaces ins't allowed!");
			  		return 1;
				}
			}
			new query[500];
	   	    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Password` = '%e' WHERE `ID` = '%d'", password, Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
			SendClientMessageFormat(playerid, -1, "{FFF000}>> Your password has been changed to:{FFFFFF} %s", password);

			new g[41], y, m, d, h, i, s, ip[16];
			gpci(playerid, g, sizeof(g));
			GetPlayerIp(playerid, ip, sizeof(ip));
  			TimestampToDate(gettime(), y, m, d, h, i, s, 3);
            mysql_format(Base, query, sizeof(query), "INSERT INTO `security` (`acc`,`ip`,`date`,`reg`,`sign`,`type`) VALUES ('%d','%e','%d','%e','%e', '1')", Player[playerid][pAccountID], ip, gettime(), Player[playerid][pIP], g);
			mysql_tquery(Base, query, "", "", "");

            #if debug_mode == 0
            new str[128];
			DiscordChannel = DCC_FindChannelById("614265642966843404");
    		format(str, sizeof str, "```%04d-%02d-%02d %02d:%02d:%02d Password: %s(%d) has changed a password (REG: %s | CUR: %s)", y, m, d, h, i, s, Player[playerid][UserName], Player[playerid][pAccountID], Player[playerid][pIP], ip);
			DCC_SendChannelMessageEx(DiscordChannel, str);
			#endif
	   	}
	   	else
	   	{
	   	    SendClientMessage(playerid, -1, "{FFF000}>> The entered data is incorrect!");
	   	}
	}
	return 1;
}

CMD:changename(playerid, params[])
{
    /*if(IsUsingProxy{playerid})
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
		return 1;
	}*/
	if(Player[playerid][pXP] >= 1000 || Player[playerid][pVip] > 0 || ItsNewbie(playerid))
	{
	    new newname[25];
	    if(sscanf(params,"s[24]", newname))
		{
		    SendClientMessage(playerid, -1, "/changename (new name)");
			return 1;
		}
		
		if(CheckForWebsite(newname) || strlen(newname) >= 20 || strlen(newname) <= 3)
		{
		    SendClientMessage(playerid, -1, "{FFF000}>> This nickname does not fit, come up with another one.");
			return 1;
		}
		
        if(strfind(newname, ".", true) != -1)
		{
	        new i_numcount, i_period, i_pos;
	        while(newname[i_pos])
			{
	            if('0' <= newname[i_pos] <= '9') i_numcount ++;
	            switch(newname[i_pos])
	            {
	                case '.': i_period ++;
	            }
				i_pos++;
	        }
	        if(i_numcount >= 5 && i_period >= 3)
		 	{
	            SendClientMessage(playerid, -1, "{FFF000}>> This nickname does not fit, come up with another one");
	        }
		}
		
		new query[300], IP[16];
		GetPlayerIp(playerid, IP, sizeof(IP));
		mysql_format(Base, query, sizeof(query), "SELECT `Date` FROM `namechanger` WHERE `account` = '%d' AND `build`='"SERVER_BUILD"' ORDER BY `Date` DESC LIMIT 1;", Player[playerid][pAccountID]);
		mysql_tquery(Base, query, "TryToFindUserName", "iss", playerid, IP, newname);
	}
	else
	{
	    ShowExpError(playerid, 1000);
		return 1;
	}
	return 1;
}

fun TryToFindUserName(playerid, const IP[], const newname[])
{
    if(cache_num_rows() > 0)
	{
	    new time;
	   	cache_get_value_name_int(0, "Date", time);
	   	if(gettime() < time)
  		{
		  	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][157]);
	    	return 1;
		}
		else
		{
		    new query[200];
		    mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", newname);
			mysql_tquery(Base, query, "TryToChangeName", "iss", playerid, newname, IP);
		}
	}
	else
	{
	    new query[200];
	    mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", newname);
		mysql_tquery(Base, query, "TryToChangeName", "iss", playerid, newname, IP);
	}
	return 1;
}

fun TryToChangeName(playerid, const newname[], const IP[])
{
    if(cache_num_rows() > 0)
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][155]);
	}
	else
	{
	    if(SetPlayerName(playerid, newname) != 1) return SendClientMessage(playerid, -1, "{FFF000}>> This nickname does not fit, come up with another one!") && 1 || 1;

	    foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][156], Player[playerid][UserName], newname);

        new query[300];
	    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Name` = '%e' WHERE `ID` = '%d'", newname, Player[playerid][pAccountID]);
	    mysql_tquery(Base, query, "", "");
	    mysql_format(Base, query, sizeof(query), "INSERT INTO `namechanger` (`newName`,`oldName`,`Date`,`IP`,`account`) VALUES ('%e','%e','%d','%e','%d')", newname, Player[playerid][UserName], gettime()+86400, IP, Player[playerid][pAccountID]);
	    mysql_tquery(Base, query, "", "", "");

        #if debug_mode == 0
  	    DiscordChannel = DCC_FindChannelById("619188479401787425");
  		format(query, sizeof query, "```\n%s renamed to %s\n```",  Player[playerid][UserName], newname);
   		DCC_SendChannelMessageEx(DiscordChannel, query);
		#endif
		
		SetPlayerName(playerid, newname);
		GetPlayerName(playerid, Player[playerid][RealName], MAX_PLAYER_NAME);
		GetPlayerName(playerid, Player[playerid][UserName], MAX_PLAYER_NAME);

	    if(Player[playerid][pVip] >= 1) {}
		else if(ItsNewbie(playerid)) {}
	    else { Player[playerid][pXP] -= 1000; }
	}
	return 1;
}

fun CheckForOffStatsDiscord(p, dstype)
{
    #if debug_mode == 0
    if(cache_num_rows() > 0)
	{
	    new DCC_Channel:ForChannel;
	    if(dstype == 1) ForChannel = DCC_FindChannelById("674323910648397894");
	    else ForChannel = DCC_FindChannelById("613185790683513003");
	    
	    new y, m, d, h, i, s, rd, IP[16];
	    cache_get_value_name_int(0, "reg_date", rd);
		cache_get_value_name(0, "last_ip", IP, 17);
	 	TimestampToDate(rd, y, m, d, h, i, s, 3);
	    new msg[128];
    	format(msg, sizeof(msg), "```\n>> Registered: %04d-%02d-%02d - Last IP: %s\n```", y, m, d, IP);
		DCC_SendChannelMessageEx(ForChannel, msg);
	}
	#endif
	return 1;
}

fun ShowOffStats(playerid, targetid)
{
   	if(cache_num_rows())
	{
		new vip[21], y, m, d, h, i, s, k, ksm, rw, dw, dl, vp, vpt, rk, xp, cln, clnr, nm[24];

	    cache_get_value_name(0, "Name", nm);
	    cache_get_value_name_int(0, "Kills", k);
        cache_get_value_name_int(0, "Killstreak", ksm);
        cache_get_value_name_int(0, "RoundWins", rw);
        cache_get_value_name_int(0, "DuelWins", dw);
        cache_get_value_name_int(0, "DuelLoses", dl);
        cache_get_value_name_int(0, "VIP", vp);
        cache_get_value_name_int(0, "Rank", rk);
        cache_get_value_name_int(0, "EXP", xp);
        cache_get_value_name_int(0, "Clan", cln);
        cache_get_value_name_int(0, "ClanRank", clnr);
        cache_get_value_name_int(0, "VipTime", vpt);

		TimestampToDate(vpt, y, m, d, h, i, s, 3);

		switch(vp)
		{
		    case 0: vip = "No";
		    case 1: vip = "Bronze(1)";
		    case 2: vip = "Silver(2)";
		    case 3: vip = "Gold(3)";
		}
		
		SendClientMessage(playerid, -1, "{33CCFF}********Player Status********");
		SendClientMessageFormat(playerid, -1, ">> Name: %s - Kills: %d - Best Killstreak: %d", nm, k, ksm);
        SendClientMessageFormat(playerid, -1, ">> Wins: %d - Duel Wins: %d - Duel Loses: %d", rw, dw, dl);
        if(d > 0) SendClientMessageFormat(playerid, -1, ">> EXP: %d - VIP: %s - VIP Expire: %02dD/%02dM/%dY", xp, vip, d, m, y);
		else SendClientMessageFormat(playerid, -1, ">> EXP: %d - VIP: %s - VIP Expire: ---", xp, vip);
		SendClientMessageFormat(playerid, -1, ">> Clan: (ID %d)(Rank: %d) - {dfb7bc}Account ID: %d", cln, clnr, targetid);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /ostats on player %s\n```", Player[playerid][RealName], nm);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][48]);
	}
	return 1;
}

fun CheckForOffStats(playerid, p)
{
	new query[128];
    if(cache_num_rows())
	{
		new y, m, d, h, i, s, rd, IP[16], vip[21],
  			k, ksm, rw, dw, dl, vp, vpt, rk, xp,
  			cln, clnr, nm[24];

		cache_get_value_name(0, "Name", nm);

		cache_get_value_name_int(0, "reg_date", rd);
		cache_get_value_name(0, "last_ip", IP, 17);
		
	    cache_get_value_name_int(0, "Kills", k);
        cache_get_value_name_int(0, "Killstreak", ksm);
        cache_get_value_name_int(0, "RoundWins", rw);
        cache_get_value_name_int(0, "DuelWins", dw);
        cache_get_value_name_int(0, "DuelLoses", dl);
        cache_get_value_name_int(0, "VIP", vp);
        cache_get_value_name_int(0, "Rank", rk);
        cache_get_value_name_int(0, "EXP", xp);
        cache_get_value_name_int(0, "Clan", cln);
        cache_get_value_name_int(0, "ClanRank", clnr);
        cache_get_value_name_int(0, "VipTime", vpt);

		TimestampToDate(vpt, y, m, d, h, i, s, 3);
        
		switch(vp)
		{
		    case 0: vip = "No";
		    case 1: vip = "Bronze(1)";
		    case 2: vip = "Silver(2)";
		    case 3: vip = "Gold(3)";
		}

		SendClientMessage(playerid, -1, "{33CCFF}********Player Status********");
		SendClientMessageFormat(playerid, -1, ">> Name: %s - Kills: %d - Best Killstreak: %d", nm, k, ksm);
        SendClientMessageFormat(playerid, -1, ">> Wins: %d - Duel Wins: %d - Duel Loses: %d", rw, dw, dl);
        if(d > 0) SendClientMessageFormat(playerid, -1, ">> EXP: %d - VIP: %s - VIP Expire: %02dD/%02dM/%dY", xp, vip, d, m, y);
		else SendClientMessageFormat(playerid, -1, ">> EXP: %d - VIP: %s - VIP Expire: ---", xp, vip);
		SendClientMessageFormat(playerid, -1, ">> Gang: (ID %d)(Rank: %d) - {dfb7bc}Account ID: %d", cln, clnr, p);
		TimestampToDate(rd, y, m, d, h, i, s, 3);
		SendClientMessageFormat(playerid, -1, "{cccccc}>> Registered: %02dD/%02dM/%04dY - Last IP: %s", d, m, y, IP);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /ostats on player %s\n```", Player[playerid][RealName], nm);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	else
	{
   		mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", p);
	 	mysql_tquery(Base, query, "ShowOffStats", "ii", playerid, p);
	}
	return 1;
}

stock Float:GetUserProgress(playerid)
{
	new Float:exp_prog = min((float(Player[playerid][pXP]) / float(svrCLHXP[sizeof(svrCLHXP)-1]))*100.0, 100.0),
	    Float:ach1_prog = min((float(Achievements[playerid][ach_BMask][0]) / 2147483647.0) * 100.0, 100.0),
	    Float:ach2_prog = min((float(Achievements[playerid][ach_BMask][1]) / 65535.0) * 100.0, 100.0),
		Float:rank_prog = min((float(Player[playerid][pRank]) / float(sizeof(rank_names)-1))*100.0, 100.0),
		Float:gang_prog = min((float(Player[playerid][pClanRank]) / 5.0)*100.0, 100.0);

	return (exp_prog + ach1_prog + ach2_prog + rank_prog + gang_prog) / 5.0;
}

CMD:stats(lol, params[])
{
    new vip[21], year, month, day;
	getdate(year, month, day);
    new y, m, d, h, i, s,
	targetid = -1;
	
	static const toLangs[][][] =
	{
	    {
			"{33CCFF}********Player Status********",
			">> Name: %s - Kills: %d - Killstreak: %d (best: %d)",
			">> Wins: %d - Duel Wins: %d - Duel Loses: %d",
			">> Rank: %s (%d / %d) - (%d / %d Kills)",
			">> EXP: %d - VIP: %s - VIP Expire: %02dD/%02dM/%dY",
			">> EXP: %d - VIP: %s - VIP Expire: ---",
			">> Played: %d Hours - %d Minutes - %d Seconds",
			">> Clan: (ID %d)(Rank: %d) - {dfb7bc}Account ID: %d",
			">> Date: %02dD/%02dM/%dY  Sign: %s",
			">> Conquest Points: %d",
			">> Completed %.2f '/. of server content"
		},
		{
		    "{33CCFF}*******************Статистика Игрока*******************",
		    ">> Ник: %s - Убийств: %d - Серия убийств: %d (лучшая: %d)",
            ">> Побед: %d - Дуэлей выиграно: %d - Дуэлей проиграно: %d",
            ">> Ранг: %s (%d / %d) - (%d / %d убийств)",
            ">> Опыт: %d - VIP: %s - VIP истекает: %02dD/%02dM/%dY",
			">> Опыт: %d - VIP: %s - VIP истекает: ---",
			">> Наигранно: %d час(ов) - %d минут(ы) - %d Секунд(ы)",
			">> Клан: (ИД %d)(Ранг: %d) - {dfb7bc}Account ID: %d",
			">> Дата: %02dD/%02dM/%dY  Запись: %s",
			">> Очков Завоевания: %d",
			">> Завершено %.2f '/. контента сервера"
		},
		{
		    "{33CCFF}********Estadнsticas de jugador********",
		    ">> Nombre: %s - Mata: %d - Killstreak: %d (mejor: %d)",
		    ">> Gana: %d - Duelo gana: %d - Duelo pierde: %d",
		    ">> Rango: %s (%d / %d) - (%d / %d Mata)",
		    ">> EXP: %d - VIP: %s - VIP Expirar: %02dD/%02dM/%dY",
			">> EXP: %d - VIP: %s - VIP Expirar: ---",
			">> Jugo: %d Horas - %d Minutos - %d Segundos",
			">> Clan: (ID %d)(Rango: %d) - {dfb7bc}Account ID: %d",
			">> Fecha: %02dD/%02dM/%dY  Firmar: %s",
			">> Conquest Points: %d",
			">> Completed %.2f '/. of server content"
		}
	};
	
	sscanf(params,"i", targetid);
	if(targetid == -1 || isnull(params)) targetid = lol;
	if(!IsPlayerConnected(targetid))
	{
		SendClientMessage(lol, -1, serverLang[Player[lol][pLang]][15]);
		return 1;
	}
	
	if(FakeData[targetid][3] > 0) TimestampToDate(FakeData[targetid][3], y, m, d, h, i, s, 3);
    else TimestampToDate(Player[targetid][pVipTime], y, m, d, h, i, s, 3);
    
	switch(Player[targetid][pVip]+FakeData[targetid][2])
	{
	    case 0: vip = "No";
	    case 1: vip = "Bronze(1)";
	    case 2: vip = "Silver(2)";
	    case 3: vip = "Gold(3)";
	}
	SendClientMessage(lol, -1, toLangs[Player[lol][pLang]][0]);
	
	if(FakeData[targetid][0] <= 0) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][1], Player[targetid][UserName], Player[targetid][pKills], Player[targetid][Killstreak], Player[targetid][pKillstreakMax] + FakeData[targetid][4]);
	else SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][1], Player[targetid][UserName], FakeData[targetid][0], Player[targetid][Killstreak], Player[targetid][pKillstreakMax] + FakeData[targetid][4]);
	
	SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][2], Player[targetid][RoundsWin] + FakeData[targetid][5], Player[targetid][DuelsWin], Player[targetid][DuelsLose]);
	
	if(Player[targetid][pRank] < sizeof(rank_exp)) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][3], rank_names[Player[targetid][pRank]], Player[targetid][pRank], sizeof(rank_exp), Player[targetid][pKills], rank_exp[Player[targetid][pRank]+1]);
	else SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][3], rank_names[sizeof(rank_names)-1], sizeof(rank_names), sizeof(rank_exp), Player[targetid][pKills], rank_exp[sizeof(rank_exp)-1]);

	if(d > 0)
	{
	    if(FakeData[targetid][0] == 0) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][4], Player[targetid][pXP], vip, d, m, y);
		else SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][4], FakeData[targetid][8], vip, d, m, y);
	}
	else
	{
		if(FakeData[targetid][0] == 0) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][5], Player[targetid][pXP], vip);
		else SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][5], FakeData[targetid][8], vip);
	}
	
	
	SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][6], Achievements[targetid][Hours], Achievements[targetid][Minutes], Achievements[targetid][Seconds]);
	SendClientMessageFormat(lol, -1, ">> Round Wins: %d", Player[targetid][RoundsWin]);

	if(FakeData[targetid][7] <= 0) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][7], Player[targetid][pClan], Player[targetid][pClanRank], Player[targetid][pAccountID] + FakeData[targetid][1]);
	else SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][7], 0, 0, Player[targetid][pAccountID] + FakeData[targetid][1]);
	SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][8], day, month, year, Player[targetid][pSign]);
	
	if(Player[targetid][totalPlayersKilledInGW] > 1 && Player[targetid][pClan] > 0) SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][9], Player[targetid][totalPlayersKilledInGW]);
	
	SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][9], Player[targetid][pPlayerKills]);
	SendClientMessageFormat(lol, -1, toLangs[Player[lol][pLang]][10], GetUserProgress(targetid));
	
	return 1;
}

new EventColors[6] = {
	0xff0000FF,
	0xff6600FF,
	0xffcc00FF,
	0x33cc33FF,
	0x66ffffFF,
	0x0066ffFF
};

stock IsEventRuler(playerid)
{
    new i, j;
	for( i = 0; i < 10; i++ ) for( j = 0; j < 10; j++ ) if(EventInfo[i][e_Rulers][j] == Player[playerid][pAccountID]) return 1;
	return 0;
}

stock SendEventMessage(const message[]) foreach(Player, i) SendClientMessage(i, -1, message);

CMD:event(playerid, const params[])
{
	new command[128], command0[32], command1[32], command2[32], command3[32], command4[32], command5[32], command6[32], command7[32];
	sscanf(params, "S()[32]S()[32]S()[32]S()[32]S()[32]S()[32]S()[32]S()[32]S()[32]", command, command0, command1, command2, command3, command4, command5, command6, command7);
	
	if(strfind(command, "leave") == 0)
 	{
 	    if(Player[playerid][eventMember] <= -1) return 1;
 	    
 	    new bool:something = false, str[64], i;
        for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }

		new eventID = Player[playerid][eventMember];
        if(strlen(EventInfo[eventID][e_Name]) >= 1)
        {
			if(!something) {
				EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
				format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
				SendEventMessage(str);
			} else {
			    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
				SendEventMessage(str);
			}

			if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers] && !EventInfo[eventID][e_IsStarted] && EventInfo[eventID][e_IsJoinsClosed])
	        {
	            EventInfo[eventID][e_IsJoinsClosed] = false;
				format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto opened (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
				SendEventMessage(str);
	        }
		}
		
 	    SetPlayerVirtualWorld(playerid, 0);
 	    ClearAnimations(playerid);
 	    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
		Player[playerid][Jailed] = -1;
		Player[playerid][eventMember] = -1;
		configureClass(playerid);
		setupZombie(playerid);
        SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(playerid);
 	    setupZombie(playerid);
 	    SetPlayerGravity(playerid, 0.008);
	}
	
	if(strfind(command, "join") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
 	    if(Player[playerid][pInGangMatch]) return 1;
 	    
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(Player[playerid][eventMember] > -1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(InGangHouse[playerid]) return 1;
		if(CockroachAbility[playerid]) return 1;
		//if(UserTankInWarState[playerid] >= 1) return 1;
		
		if(strlen(command0) <= 0 || strval(command0)-1 >= sizeof(EventInfo) || strval(command0)-1 <= -1 || strlen(EventInfo[strval(command0)-1][e_Name]) <= 0)
		{
		    SendClientMessage(playerid, -1, "{ffc34d}/event join (event id)");
			return 1;
		}
		
		new eventID = strval(command0)-1, i, bool:something;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		
		SendClientMessage(playerid, -1, "{ffc34d}|: Attempting to join an event...");
		if(!EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: You were kicked, event did not start") && 1 || 1;
        if(EventInfo[eventID][e_IsJoinsClosed]) return SendClientMessage(playerid, -1, "{ffc34d}|: You were kicked, the event is no longer gaining participants") && 1 || 1;
		if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: You were kicked, event is preparing to ending") && 1 || 1;
  		if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: ERROR") && 1 || 1;
                
        something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

        if(Player[playerid][pRank] < EventInfo[eventID][e_minRank]) {
            if(!something) {
			    SendClientMessageFormat(playerid, -1, "{ffc34d}|: You were kicked, you need min. rank %d to join an event", EventInfo[eventID][e_minRank]);
				return 1;
			}
        }
        
        if(Player[playerid][pXP] < EventInfo[eventID][e_minExp]) {
            if(!something) {
			    SendClientMessageFormat(playerid, -1, "{ffc34d}|: You were kicked, you need min. %d exp to join an event", EventInfo[eventID][e_minExp]);
				return 1;
			}
        }
        
        if(EventInfo[eventID][e_IsGangNeed] && Player[playerid][pClan] <= 0 && !something) return SendClientMessage(playerid, -1, "{ffc34d}|: You were kicked, you need to be in a gang") && 1 || 1;
        
        if((++EventInfo[eventID][e_curPlayers]) >= EventInfo[eventID][e_maxPlayers]) {
            if(!something) return SendClientMessage(playerid, -1, "{ffc34d}|: You were kicked, the event gained its maximum number of participants") && 1 || 1;
        }
        
        if(EventInfo[eventID][e_curPlayers] >= EventInfo[eventID][e_maxPlayers])
        {
            EventInfo[eventID][e_IsJoinsClosed] = true;
            new str[64];
			format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto closed (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
			SendEventMessage(str);
        }
        
        SendClientMessageFormat(playerid, -1, "{ffc34d}|: Joined to %s", EventInfo[eventID][e_Name]);

		new str[64];
		if(!something) {
			EventInfo[eventID][e_curPlayers]++;
			format(str, sizeof(str), "{ff6600}[EVENT] %s has joined to an event (%s #%d)", Player[playerid][UserName], EventInfo[eventID][e_Name], eventID+1);
			SendEventMessage(str);
		} else {
		    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has joined to an event (%s #%d)", Player[playerid][UserName], EventInfo[eventID][e_Name], eventID+1);
			SendEventMessage(str);
		}
		
		CurePlayer(playerid);
	    SetPlayerArmour(playerid, 0.0);
	    SetPlayerHealthAC(playerid, 100.0);
   	    Player[playerid][IsBurned][0] = 0;
		Player[playerid][IsBurned][1] = 0;
   	    Player[playerid][Poisioned] = false;
   	    Player[playerid][IsPlayerAdvancedInfected] = false;
	 	Player[playerid][AntiSeeker] = false;
		Player[playerid][AntiFreeze] = false;
		Player[playerid][AntiRadioctive] = false;
		Player[playerid][AntiBuring] = false;
		Player[playerid][AntiLegBreaks] = false;
		Player[playerid][AntiSpider] = false;
		Player[playerid][AntiScreamer] = false;
		Player[playerid][SlowWalk] = 0;
		Player[playerid][Helmet] = false;
        Player[playerid][Fearlessness] = false;
		
		Player[playerid][Cursed] = false;
		RemovePlayerAttachedObject(playerid, 4);
	   	RemovePlayerAttachedObject(playerid, 5);
	   	RemovePlayerAttachedObject(playerid, 6);
	    RemovePlayerAttachedObject(playerid, 7);
	   	RemovePlayerAttachedObject(playerid, 8);
	   	RemovePlayerAttachedObject(playerid, 9);
		ResetWeapons(playerid);
		
	 	HumanZombieBoss[playerid] = false;
	 	HumanHumanBoss[playerid] = false;
	 	Healer[playerid] = false;
		
		AntiTPTimerEx(playerid, 4);
		AntiSlap(playerid, 2);
		AntiSpeedHack(playerid, 3);
		
		SetPlayerTeamEx(playerid, 3);
		
		if(something) {
			SetPlayerSkinAC(playerid, 217, 1);
		    SetPlayerColor(playerid, 0xac00e6FF);
		    new gunname[32];
	    	GetWeaponName(42, gunname, sizeof(gunname));
			SetPVarInt(playerid, gunname, 999999);
			GivePlayerWeaponAC(playerid, 42, 999999);
			SetPlayerPosAC(playerid, EventInfo[eventID][e_defaultPoses][0], EventInfo[eventID][e_defaultPoses][1], EventInfo[eventID][e_defaultPoses][2]);
		} else {
		    SetPlayerSkinAC(playerid, EventInfo[eventID][e_Skin][0], 1);
		    SetPlayerColor(playerid, EventColors[0]);
			SetPlayerPosAC(playerid, EventInfo[eventID][e_HumanPos][0], EventInfo[eventID][e_HumanPos][1], EventInfo[eventID][e_HumanPos][2]);
			SetPlayerFacingAngle(playerid, EventInfo[eventID][e_HumanPos][3]);
		}
		SetCameraBehindPlayer(playerid);
		
		SetPlayerInterior(playerid, 0);
		SetPlayerVirtualWorld(playerid, EventInfo[eventID][e_VirtualWorld]);
		
		Player[playerid][eventMember] = eventID;
		SetPlayerGravity(playerid, EventInfo[eventID][e_Gravity]);
		
		SetPlayerTime(playerid, EventInfo[eventID][e_Time], 0);
		SetPlayerWeather(playerid, EventInfo[eventID][e_Weather]);
		
		return 1;
 	}
 	
 	if(strfind(command, "close") == 0)
 	{
 	    if(strfind(command0, "joins") == 0)
 	    {
 	        if(Player[playerid][eventMember] <= -1) return SendClientMessage(playerid, -1, "{ffc34d}|: You are not at the event");
            new bool:something = false, i;
        	for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[Player[playerid][eventMember]][e_RulersPermisions][1]) { something = true; break; }
        	if(EventInfo[Player[playerid][eventMember]][e_OwnerID] == Player[playerid][pAccountID]) something = true;
        	if(something)
        	{
		 		if(!EventInfo[Player[playerid][eventMember]][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event did not start") && 1 || 1;
				if(EventInfo[Player[playerid][eventMember]][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: The event is already ending") && 1 || 1;
	            if(EventInfo[Player[playerid][eventMember]][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
	            if(strlen(EventInfo[Player[playerid][eventMember]][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: ERROR") && 1 || 1;
	            
	            EventInfo[Player[playerid][eventMember]][e_IsJoinsClosed] = true;

				new str[64];
    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has closed join requests (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
				SendEventMessage(str);
			}
 	        return 1;
 	    }
 	    return 1;
 	}
 	
 	if(strfind(command, "kick") == 0)
 	{
 	    if(Player[playerid][eventMember] <= -1) return SendClientMessage(playerid, -1, "{ffc34d}|: You are not at the event");
 	    if(strlen(EventInfo[Player[playerid][eventMember]][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: ERROR") && 1 || 1;
 	    new bool:something = false, i;
     	for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[Player[playerid][eventMember]][e_RulersPermisions][6]) { something = true; break; }
     	if(EventInfo[Player[playerid][eventMember]][e_OwnerID] == Player[playerid][pAccountID]) something = true;
    	if(something)
    	{
    	    if(!EventInfo[Player[playerid][eventMember]][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event did not start") && 1 || 1;
			if(EventInfo[Player[playerid][eventMember]][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: The event is already ending") && 1 || 1;
            if(EventInfo[Player[playerid][eventMember]][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
    	    if(strlen(command0) <= 0 || !IsPlayerConnected(strval(command0))) return SendClientMessage(playerid, -1, "{ffc34d}|: Player not connected") && 1 || 1;
            if(Player[playerid][eventMember] != Player[strval(command0)][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: The player is not in your event") && 1 || 1;

			new str[64];

			something = false;
			for(i = 0; i < 10; i++) if(EventInfo[Player[strval(command0)][eventMember]][e_Rulers][i] == Player[strval(command0)][pAccountID] && EventInfo[Player[strval(command0)][eventMember]][e_RulersPermisions][6]) { something = true; break; }
			if(EventInfo[Player[strval(command0)][eventMember]][e_OwnerID] == Player[strval(command0)][pAccountID]) something = true;

			if(!something) {
				EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
				if(strlen(command1)) format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has kicked player %s [Reason: %s]", Player[playerid][UserName], Player[strval(command0)][UserName], command1);
				else format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has kicked player %s (%s #%d)", Player[playerid][UserName], Player[strval(command0)][UserName], EventInfo[Player[strval(command0)][eventMember]][e_Name], Player[strval(command0)][eventMember]+1);
				foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
				format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[strval(command0)][UserName], EventInfo[Player[strval(command0)][eventMember]][e_Name], Player[strval(command0)][eventMember]+1);
				foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

                SetPlayerVirtualWorld(strval(command0), 0);
				ClearAnimations(strval(command0));
		 	    SetPlayerSpecialAction(strval(command0), SPECIAL_ACTION_NONE);
				Player[strval(command0)][Jailed] = -1;
				Player[strval(command0)][eventMember] = -1;
				SetPlayerGravity(strval(command0), 0.008);
				configureClass(strval(command0));
				setupZombie(strval(command0));
		        SetSpawnInfo(strval(command0),TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
				SpawnPlayer(strval(command0));
		 	    setupZombie(strval(command0));
		 	    
			} else {
			    SendClientMessage(playerid, -1, "{ffc34d}|: Not enough rights");
			}
			return 1;
		}
 	    return 1;
 	}
	
 	if(strfind(command, "devmode") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(Player[playerid][eventMember] > -1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(CockroachAbility[playerid]) return 1;
        if(InGangHouse[playerid]) return 1;
        
        new bool:something = false, i, j;
        for( i = 0; i < 10; i++ )
        {
        	for( j = 0; j < 10; j++ ) if(EventInfo[i][e_Rulers][j] == Player[playerid][pAccountID] && EventInfo[i][e_RulersPermisions][0]) { something = true; }
            if(something)
            {
                SendClientMessage(playerid, -1, "{ffc34d}|: Reconfiguration and event Integration...");
                
                SetPlayerHealthAC(playerid, 100.0);
                SetPlayerArmourAC(playerid, 0.0);
                SetPlayerTeamEx(playerid, 254);

                ResetWeapons(playerid);
                SendClientMessageFormat(playerid, -1, "{ffc34d}|: Integration completed, Location: #%d", i+1);
                SetPlayerVirtualWorld(playerid, 50 + i);
                Player[playerid][eventMember] = i;
                
                SetPlayerSkinAC(playerid, 217, 1);
			    SetPlayerColor(playerid, 0xac00e6FF);
			    new gunname[32];
		    	GetWeaponName(42, gunname, sizeof(gunname));
				SetPVarInt(playerid, gunname, 999999);
				GivePlayerWeaponAC(playerid, 42, 999999);

                SetPlayerGravity(playerid, EventInfo[i][e_Gravity]);
				SetPlayerTime(playerid, EventInfo[i][e_Time], 0);
				SetPlayerWeather(playerid, EventInfo[i][e_Weather]);

                return 1;
            }
		}

		something = false;
        if(GetUnlockedSlot(Player[playerid][pSettings], 29) == 1)
    	{
			for( i = 0; i < 10; i++ )
	        {
	            if(EventInfo[i][e_IsEnded] || EventInfo[i][e_OwnerID] == Player[playerid][pAccountID])
	            {
	                SetPlayerHealthAC(playerid, 100.0);
	                SetPlayerArmourAC(playerid, 0.0);
	                SetPlayerTeamEx(playerid, 254);
                    SendClientMessage(playerid, -1, "{ffc34d}|: Reconfiguration and event Integration...");
	                ResetWeapons(playerid);
	                SendClientMessageFormat(playerid, -1, "{ffc34d}|: Integration completed, Location: #%d", i+1);
	                SetPlayerVirtualWorld(playerid, 50 + i);
	                EventInfo[i][e_VirtualWorld] = 50 + i;
	                EventInfo[i][e_IsEnded] = false;
	                Player[playerid][eventMember] = i;
	                EventInfo[i][e_OwnerID] = Player[playerid][pAccountID];
	                EventInfo[i][e_IsTeamActive][0] = true;
	                EventInfo[i][e_IsTeamActive][1] = true;

	                SetPlayerSkinAC(playerid, 217, 1);
				    SetPlayerColor(playerid, 0xac00e6FF);
				    new gunname[32];
			    	GetWeaponName(42, gunname, sizeof(gunname));
					SetPVarInt(playerid, gunname, 999999);
					GivePlayerWeaponAC(playerid, 42, 999999);
					
					SetPlayerGravity(playerid, EventInfo[i][e_Gravity]);
					SetPlayerTime(playerid, EventInfo[i][e_Time], 0);
					SetPlayerWeather(playerid, EventInfo[i][e_Weather]);

	                return 1;
	            }
	        }
	    }
	    
	    SendClientMessage(playerid, -1, "{FF0000}>> Unable to Integrate, all slots is full");
	    return 1;
 	}
 	
 	if(strfind(command, "start") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(CockroachAbility[playerid]) return 1;
		if(InGangHouse[playerid]) return 1;
		
		new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, enter an event /event devmode") && 1 || 1;
		
		if(EventInfo[eventID][e_RequestToDelete]) return 1;

        something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    SendClientMessage(playerid, -1, "{ffc34d}|: Attempting to create an event...");
			if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
            //if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, not enough members") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
	        if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

		    SendMessageFormatToAll(-1, "{33cc33}|: The \"%s\" event has begun! {FFF000}/event join %d", EventInfo[eventID][e_Name], eventID+1);
		    EventInfo[eventID][e_IsStarted] = true;
		    EventInfo[eventID][e_TimeToEnd] = gettime() + 1800;
		}
	}

    if(strfind(command, "end") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(CockroachAbility[playerid]) return 1;
		
		new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;

        something = false;
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    if(!EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event did not started") && 1 || 1;
            if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

			if(strlen(EventInfo[eventID][e_Name]) > 0) SendMessageFormatToAll(-1, "{33cc33}|: The event \"%s\" was over", EventInfo[eventID][e_Name]);

            EventInfo[eventID][e_IsStarted] = false;
            EventInfo[eventID][e_IsJoinsClosed] = false;
            EventInfo[eventID][e_IsGangNeed] = false;
            EventInfo[eventID][e_RequestToDelete] = false;
            for(i = 1; i < 6; i++) EventInfo[eventID][e_IsTeamActive][i] = false;
            for(i = 0; i < 6; i++) EventInfo[eventID][e_Skin][i] = 0;
           	for(i = 0; i < 3; i++) EventInfo[eventID][e_defaultPoses][i] = 0.0;
           	EventInfo[eventID][e_Gravity] = 0.008;
           	
           	EventInfo[eventID][e_Time] = 12;
			EventInfo[eventID][e_Weather] = 0;
           	
           	for(i = 0; i < MAX_PLAYERS; i++) if(IsValidPickup(EventInfo[eventID][e_Pickups][i])) DestroyPickupEx(EventInfo[eventID][e_Pickups][i], true);
           	
           	new newID;
			for( i = 0; i < 18; i++)
			{
			    newID = (i-1) > -1 ? i * 2 : 0;
 		    	if(EventInfo[eventID][e_CarProps][newID] > 0) DestroyVehicle(EventInfo[eventID][e_CarProps][newID]);
			}
            for(i = 0; i < 36; i++) EventInfo[eventID][e_CarProps][i] = 0;
            for(i = 0; i < 8; i++) EventInfo[eventID][e_RulersPermisions][i] = 0;
            
           	EventInfo[eventID][e_VirtualWorld] = 0;
           	EventInfo[eventID][e_minPlayers] = 0;
           	EventInfo[eventID][e_maxPlayers] = MAX_PLAYERS;
           	EventInfo[eventID][e_curPlayers] = 0;
           	EventInfo[eventID][e_minRank] = 0;
           	EventInfo[eventID][e_minExp] = 0;
           	EventInfo[eventID][e_TimerCount] = 0;
           	EventInfo[eventID][e_TimeToEnd] = -1;
            
            for(i = 0; i < 100; i++)
			{
				if(IsValidDynamicObject(EventInfo[eventID][e_Objects][i]))
			    {
					DestroyDynamicObject(EventInfo[eventID][e_Objects][i]);
					EventInfo[eventID][e_Objects][i] = INVALID_OBJECT_ID;
				}
			}
            
            EventInfo[eventID][e_IsEnded] = true;
            EventInfo[eventID][e_OwnerID] = -1;
            for(i = 0; i < 10; i++) EventInfo[eventID][e_Rulers][i] = 0;
            strmid(EventInfo[eventID][e_Name], "", 0, 65, 65);
            
			foreach(Player, j)
			{
				if(Player[j][eventMember] == eventID && Player[j][eventMember] > -1)
				{
                    SetPlayerVirtualWorld(j, 0);
			 	    ClearAnimations(j);
			 	    SetPlayerSpecialAction(j, SPECIAL_ACTION_NONE);
					Player[j][Jailed] = -1;
					Player[j][eventMember] = -1;
					SetPlayerGravity(j, 0.008);
					configureClass(j);
					setupZombie(j);
			        SetSpawnInfo(j,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
					SpawnPlayer(j);
			 	    setupZombie(j);
				}
			}
			return 1;
		}
		return 1;
	}
	
    if(strfind(command, "set") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(CockroachAbility[playerid]) return 1;

		new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;

		if(EventInfo[eventID][e_RequestToDelete]) return 1;

        something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    //if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
			//if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			//if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

			if(strfind(command0, "exp") == 0)
 	    	{
 	    	    if(strlen(command1) <= 0 || strval(command1) < 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set exp (exp)") && 1 || 1;
 	    	    else
 	    		{
				    SendClientMessageFormat(playerid, -1, "{ffc34d}|: Event exp set to %d", strval(command1));
			        EventInfo[eventID][e_minExp] = strval(command1);
				}
				return 1;
			}
			if(strfind(command0, "gang") == 0)
 	    	{
 	    	    EventInfo[eventID][e_IsGangNeed] =! EventInfo[eventID][e_IsGangNeed];
 	    	    if(EventInfo[eventID][e_IsGangNeed]) SendClientMessage(playerid, -1, "{ffc34d}|: Event participants {33cc33}must be{ffc34d} in a gang");
       			else SendClientMessage(playerid, -1, "{ffc34d}|: Event participants {FF0000}should not be{ffc34d} in a gang");
				return 1;
			}
		    if(strfind(command0, "name") == 0)
 	    	{
 	    	    if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set name (name)") && 1 || 1;
 	    	    else
 	    		{
 	    		    if(CheckForWebsite(command1) || CheckForIP(command1)) return SendClientMessage(playerid, -1, "{ffc34d}|: Use a different name") && 1 || 1;
				    SendClientMessageFormat(playerid, -1, "{ffc34d}|: Event name set to %s", command1);
				    strmid(EventInfo[eventID][e_Name], command1, 0, 65, 65);
				}
				return 1;
			}
			if(strfind(command0, "hp") == 0)
 	    	{
 	    	    new ID = -1, Float:radius = 0.0, amount = 100;
 	    	    sscanf(command1, "f", radius);
 	    	    sscanf(command1, "i", ID);
 	    	    sscanf(command2, "i", amount);
 	    	    
 	    	    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;
 	    	    
 	    	    if(ID == -1 && radius == 0.0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set hp (player id / radius) ([...amount])") && 1 || 1;
 	    	    else
 	    		{
 	    		    if(ID > -1)
 	    		    {
 	    		        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set hp (player id / radius) ([...amount])") && 1 || 1;
						if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set hp (player id / radius) ([...amount])") && 1 || 1;
 	    		        new str[128];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set %s's HP (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						SetPlayerHealthAC(ID, float(amount));
 	    		    }
 	    		    else if(radius > 0.0)
 	    		    {
 	    		        new str[128], Float:pos[3];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set HP in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						foreach(Player, j) if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2])) if(Player[j][eventMember] == Player[playerid][eventMember]) SetPlayerHealthAC(j, float(amount));
 	    		    }
				}
				return 1;
			}
			if(strfind(command0, "armour") == 0)
 	    	{
 	    	    new ID = -1, Float:radius = 0.0, amount = 100;
 	    	    sscanf(command1, "f", radius);
 	    	    sscanf(command1, "i", ID);
 	    	    sscanf(command2, "i", amount);
 	    	    
 	    	    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

 	    	    if(ID == -1 && radius == 0.0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set armour (player id / radius) ([...amount])") && 1 || 1;
 	    	    else
 	    		{
 	    		    if(ID > -1)
 	    		    {
 	    		        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set armour (player id / radius) ([...amount])") && 1 || 1;
 	    		        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set armour (player id / radius) ([...amount])") && 1 || 1;
 	    		        new str[128];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set %s's Armour (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						SetPlayerArmourAC(ID, float(amount));
 	    		    }
 	    		    else if(radius > 0.0)
 	    		    {
 	    		        new str[128], Float:pos[3];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set Armour in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						foreach(Player, j) if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2])) if(Player[j][eventMember] == Player[playerid][eventMember]) SetPlayerArmourAC(j, float(amount));
 	    		    }
				}
				return 1;
			}
			
			if(strfind(command0, "car") == 0)
 	    	{
			    something = false;
			    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][3]) { something = true; break; }
			    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

			    if(something)
			    {
	 	    	    new ID = -1, carID = -1, color = -1, color2 = -1, for_team = -1;
	 	    	    sscanf(command1, "i", ID);
	 	    	    sscanf(command2, "i", carID);
	 	    	    sscanf(command3, "i", color);
	 	    	    sscanf(command4, "i", color2);
	 	    	    sscanf(command5, "i", for_team);

                    if(for_team > -1)
                    {
		 	    	    if(for_team < 1 || for_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
			    		if(!EventInfo[eventID][e_IsTeamActive][for_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;
					}
					
					if(ID == -1 && carID == -1 && color == -1 && color2 == -1 || (ID-1) >= 17 || strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set car (car number) (carid) (color1) (color2) ([...for team]) [LIMIT 18]") && 1 || 1;
	 	    	    else
	 	    		{
	 	    		    if(carID < 400 || carID > 605) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set car (car number) (carid) (color1) (color2) ([...for team]) [LIMIT 18]") && 1 || 1;
	 	    		    new Float:pos[4];
	 	    		    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						GetPlayerFacingAngle(playerid, pos[3]);
						GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 3.0);

						new newID = (ID-1) > -1 ? ID * 2 : 0;

	 	    		    if(EventInfo[eventID][e_CarProps][newID] == 0)
			 			{
						 	EventInfo[eventID][e_CarProps][newID] = CreateVehicle(carID, pos[0], pos[1], pos[2], pos[3], color, color2, 120);
							if(for_team == -1) EventInfo[eventID][e_CarProps][newID+1] = -1;
							else EventInfo[eventID][e_CarProps][newID+1] = (3*(eventID+1))+(for_team-1);
	                        SendClientMessageFormat(playerid, -1, "{FFF000}|: Vehicle created: #%d", ID);
	                        SetVehicleVirtualWorld(EventInfo[eventID][e_CarProps][newID], GetPlayerVirtualWorld(playerid));
						}
						else
						{
						    DestroyVehicle(EventInfo[eventID][e_CarProps][newID]);
						    EventInfo[eventID][e_CarProps][newID] = CreateVehicle(carID, pos[0], pos[1], pos[2], pos[3], color, color2, 120);
	        				if(for_team == -1) EventInfo[eventID][e_CarProps][newID+1] = -1;
							else EventInfo[eventID][e_CarProps][newID+1] = (3*(eventID+1))+(for_team-1);
	                        SendClientMessageFormat(playerid, -1, "{FFF000}|: Vehicle created: #%d", ID);
	                        SetVehicleVirtualWorld(EventInfo[eventID][e_CarProps][newID], GetPlayerVirtualWorld(playerid));
						}
	 	    		}
				}
				return 1;
			}
			
			if(strfind(command0, "permissions") == 0)
 	    	{
 	    	    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID])
 	    	    {
					if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "/event set permissions (dev mode) ([...close joins, set spawns, set car spawns, set skins, set teams, kick players])") && 1 || 1;

					new j, type[7][4] = {"OFF", ...}, desc[7][] = {"dev mode", "close joins", "set spawns", "set cars", "set skins", "set teams", "kick players"};
				 	sscanf(command1, "s[4]", type[0]);
 	    	        sscanf(command2, "s[4]", type[1]);
 	    	        sscanf(command3, "s[4]", type[2]);
 	    	        sscanf(command4, "s[4]", type[3]);
 	    	        sscanf(command5, "s[4]", type[4]);
 	    	        sscanf(command6, "s[4]", type[5]);
 	    	        sscanf(command7, "s[4]", type[6]);
 	    	        
 	    	        for( i = 0; i < 7; i++ )
 	    	        {
 	    	            EventInfo[eventID][e_RulersPermisions][i] = 0;
 	    	            if(!strcmp(type[i], "ON", true))
		 				{
						 	EventInfo[eventID][e_RulersPermisions][i] = 1;
						 	
						 	foreach(Player, a) for(j = 0; j < 10; j++) if(EventInfo[eventID][e_Rulers][j] == Player[a][pAccountID]) SendClientMessageFormat(a, -1, "{FFF000}%s = ON", desc[i]);

						 	SendClientMessageFormat(playerid, -1, "{FFF000}%s = ON", desc[i]);
						}
						else if(EventInfo[eventID][e_RulersPermisions][i] != 1)
						{
						    SendClientMessageFormat(playerid, -1, "%s = OFF", desc[i]);
						    foreach(Player, a) for(j = 0; j < 10; j++) if(EventInfo[eventID][e_Rulers][j] == Player[a][pAccountID]) SendClientMessageFormat(a, -1, "%s = OFF", desc[i]);
						}
 	    	        }
 	    	        return 1;
 	    	    }
 	    	    return 1;
 	    	}
			
			if(strfind(command0, "ruler") == 0)
 	    	{
 	    	    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID])
 	    	    {
 	    	        new ID = -1;
 	    	        //if(strlen(command1) >= 1) ID = strval(command1);
 	    	        sscanf(command1, "i", ID);
 	         		//sscanf(command2, "s[5]", type);
 	    	        if(ID == -1 || strlen(command1) <= 0) return SendClientMessage(playerid, -1, "/event set ruler (account id) ([...off])") && 1 || 1;
 	    	        if(ID < 1 || Player[playerid][pAccountID] == ID) return SendClientMessage(playerid, -1, "/event set ruler (account id) ([...off])") && 1 || 1;

					/*if(strlen(type) >= 3)
					{
					    if(!strcmp(type, "off", true))
					    {
					        for(i = 0; i < 10; i++)
							{
								if(EventInfo[eventID][e_Rulers][i] == ID)
								{
								    EventInfo[eventID][e_Rulers][i] = 0;
                                    SendClientMessage(playerid, -1, "{FFF000}Removed!");
									return 1;
								}
							}
							SendClientMessage(playerid, -1, "Not found");
							return 1;
					    }
					}*/
					printf("%d", ID);
					for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == ID) return SendClientMessage(playerid, -1, "He / She is already ruler") && 1 || 1;
                    for(i = 0; i < 10; i++)
					{
						if(EventInfo[eventID][e_Rulers][i] <= 0)
	                    {
	                        EventInfo[eventID][e_Rulers][i] = ID;
	                        SendClientMessageFormat(playerid, -1, "{FFF000}Set! (ID %d)", ID);
	                        return 1;
	                    }
					}
                    SendClientMessage(playerid, -1, "All places are already taken...");
                    return 1;
				}
				else SendClientMessage(playerid, -1, "Not enough permissions");
				return 1;
			}
			
			if(!strcmp(command0, "team"))
 	    	{
			    something = false;
			    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][5]) { something = true; break; }
			    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

			    if(something)
			    {
	 	    	    new ID = -1, Float:radius = 0.0, command_team = -1;
	 	    	    sscanf(command1, "f", radius);
	 	    	    sscanf(command1, "i", ID);
	                sscanf(command2, "i", command_team);
	 	    	    if(ID == -1 && radius == 0.0 &&  command_team == -1 || strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set team (player id / radius) (1 - 6)") && 1 || 1;
	 	    	    else
	 	    		{
	 	    		    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;
						if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
	  	        		if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

	 	    		    if(ID > -1)
	 	    		    {
	 	    		        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set team (player id / radius) (1 - 6)") && 1 || 1;
	 	    		        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set team (player id / radius) (1 - 6)") && 1 || 1;

	                        if(EventInfo[eventID][e_OwnerID] == Player[ID][pAccountID]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set team (player id / radius) (1 - 6)") && 1 || 1;
							for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[ID][pAccountID]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set team (player id / radius) (1 - 6)") && 1 || 1;

						 	new str[128];
			    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set %s's team (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
							foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

							SetPlayerTeamEx(ID, (3*(eventID+1))+(command_team-1));
						 	SetPlayerSkinAC(ID, EventInfo[eventID][e_Skin][command_team-1], 1);
						    SetPlayerColor(ID, EventColors[command_team-1]);
						    
						    switch((command_team-1))
						    {
						        case 0:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][0], EventInfo[eventID][e_HumanPos][1], EventInfo[eventID][e_HumanPos][2]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][3]);
								}
								case 1:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][4], EventInfo[eventID][e_HumanPos][5], EventInfo[eventID][e_HumanPos][6]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][7]);
								}
								case 2:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][8], EventInfo[eventID][e_HumanPos][9], EventInfo[eventID][e_HumanPos][10]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][11]);
								}
								case 3:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][12], EventInfo[eventID][e_HumanPos][13], EventInfo[eventID][e_HumanPos][14]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][15]);
								}
								case 4:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][16], EventInfo[eventID][e_HumanPos][17], EventInfo[eventID][e_HumanPos][18]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][19]);
								}
								case 5:
						        {
									SetPlayerPosAC(ID, EventInfo[eventID][e_HumanPos][20], EventInfo[eventID][e_HumanPos][21], EventInfo[eventID][e_HumanPos][22]);
									SetPlayerFacingAngle(ID, EventInfo[eventID][e_HumanPos][23]);
								}
							}
			    		}
	 	    		    else if(radius > 0.0)
	 	    		    {
	 	    		        new str[128], Float:pos[3];
			    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set team in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
							foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

							GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
							foreach(Player, j)
							{
								if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
								{
									if(Player[j][eventMember] == Player[playerid][eventMember])
									{
									    if(EventInfo[eventID][e_OwnerID] == Player[j][pAccountID]) continue;
										for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[j][pAccountID]) continue;

									    SetPlayerTeamEx(j, (3*(eventID+1))+(command_team-1));
									 	SetPlayerSkinAC(j, EventInfo[eventID][e_Skin][command_team-1], 1);
									    SetPlayerColor(j, EventColors[command_team-1]);
									    switch((command_team-1))
									    {
									        case 0:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][0], EventInfo[eventID][e_HumanPos][1], EventInfo[eventID][e_HumanPos][2]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][3]);
											}
											case 1:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][4], EventInfo[eventID][e_HumanPos][5], EventInfo[eventID][e_HumanPos][6]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][7]);
											}
											case 2:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][8], EventInfo[eventID][e_HumanPos][9], EventInfo[eventID][e_HumanPos][10]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][11]);
											}
											case 3:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][12], EventInfo[eventID][e_HumanPos][13], EventInfo[eventID][e_HumanPos][14]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][15]);
											}
											case 4:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][16], EventInfo[eventID][e_HumanPos][17], EventInfo[eventID][e_HumanPos][18]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][19]);
											}
											case 5:
									        {
												SetPlayerPosAC(j, EventInfo[eventID][e_HumanPos][20], EventInfo[eventID][e_HumanPos][21], EventInfo[eventID][e_HumanPos][22]);
												SetPlayerFacingAngle(j, EventInfo[eventID][e_HumanPos][23]);
											}
										}
									}
								}
							}
	 	    		    }
					}
				}
				return 1;
			}
			
			if(!strcmp(command0, "teams"))
 	    	{
			    something = false;
			    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][5]) { something = true; break; }
			    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

			    if(something)
			    {
	 	    	    if(strlen(command1) <= 0 || strval(command1) < 1 || strval(command1) > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set teams (1-6)") && 1 || 1;

					for( i = 0; i < 6; i++ ) EventInfo[eventID][e_IsTeamActive][i] = false;
					for( i = 0; i < strval(command1); i++ ) EventInfo[eventID][e_IsTeamActive][i] = true;
					SendClientMessageFormat(playerid, -1, "{ffc34d}|: Event teams set to %d", strval(command1));
				}
			}
			
 	    	if(strfind(command0, "time") == 0)
 	    	{
 	    	    new time = -1;
 	    	    sscanf(command1, "i", time);
                if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set time (time)") && 1 || 1;
                if(time < 0 || time > 23) time = 0;
                new str[128];
    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set time to %d (EVENT #%d)", Player[playerid][UserName], time, Player[playerid][eventMember]+1);
    			foreach(Player, j)
				{
					if(Player[j][eventMember] == Player[playerid][eventMember])
					{
						SendClientMessage(j, -1, str);
						SetPlayerTime(j, time, 0);
					}
				}
				EventInfo[eventID][e_Time] = time;
				return 1;
			}
			
			if(strfind(command0, "weather") == 0)
 	    	{
 	    	    new time = -1;
 	    	    sscanf(command1, "i", time);
                if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set weather (weather)") && 1 || 1;
                if(time < 0) time = 0;
                new str[128];
    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set weather to %d (EVENT #%d)", Player[playerid][UserName], time, Player[playerid][eventMember]+1);
    			foreach(Player, j)
				{
					if(Player[j][eventMember] == Player[playerid][eventMember])
					{
						SendClientMessage(j, -1, str);
						SetPlayerWeather(j, time);
					}
				}
				EventInfo[eventID][e_Weather] = time;
				return 1;
			}
			
			if(strfind(command0, "gravity") == 0)
 	    	{
 	    	    new Float:intensity = 0.008;
 	    	    sscanf(command1, "f", intensity);
 	    	    
                if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set gravity (Float:intensity | Default: 0.008)") && 1 || 1;
                
                new str[128];
    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set gravity to %.8f (EVENT #%d)", Player[playerid][UserName], intensity, Player[playerid][eventMember]+1);
    			
				foreach(Player, j)
				{
					if(Player[j][eventMember] == Player[playerid][eventMember])
					{
					    SendClientMessage(j, -1, str);
					    SetPlayerGravity(j, intensity);
					}
				}
				
				EventInfo[eventID][e_Gravity] = intensity;
				return 1;
 	    	}
			
			if(strfind(command0, "weapon") == 0)
 	    	{
 	    	    new ID = -1, Float:radius = 0.0, weaponid = 0, ammo = 1000, command_team = 1, gunname[32];
 	    	    
 	    	    sscanf(command1, "f", radius);
 	    	    sscanf(command1, "i", ID);
 	    	    sscanf(command2, "i", weaponid);
                sscanf(command3, "i", ammo);
                sscanf(command4, "i", command_team);
                
 	    	    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

				if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
  	        	if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

 	    	    if(ID == -1 && radius == 0.0 && weaponid == 0 && ammo == 0 || strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set weapon (player id / radius) (weaponid) (ammo) ([...team])") && 1 || 1;
 	    	    else
 	    		{
 	    		    if(ID > -1)
 	    		    {
 	    		        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set weapon (player id / radius) (weaponid) (ammo) ([...team])") && 1 || 1;
 	    		        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set weapon (player id / radius) (weaponid) (ammo) ([...team])") && 1 || 1;
 	    		        new str[128];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set %s's weapon (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						
						GetWeaponName(weaponid, gunname, sizeof(gunname));
						if(GetPVarInt(ID, gunname) <= 1) GivePlayerWeaponAC(ID, weaponid, min(ammo, 1000));
 	    	    		else SetPlayerAmmoAC(ID, weaponid, ammo);
 	    	    		
 	    	    		SetPVarInt(ID, gunname, ammo);
 	    		    }
 	    		    else if(radius > 0.0)
 	    		    {
 	    		        new str[128], Float:pos[3];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has set weapon in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						foreach(Player, j)
						{
							if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
							{
								if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(command_team-1))
								{
								    GetWeaponName(weaponid, gunname, sizeof(gunname));
								    
								    if(GetPVarInt(j, gunname) <= 1) GivePlayerWeaponAC(j, weaponid, min(ammo, 1000));
 	    	    					else SetPlayerAmmoAC(j, weaponid, min(ammo, 1000));
 	    	    					SetPVarInt(j, gunname, min(ammo, 1000));
								}
							}
						}
 	    		    }
				}
				return 1;
			}
			
			if(strfind(command0, "spawn") == 0)
			{
			    something = false;
			    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][2]) { something = true; break; }
			    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
			    
			    if(something)
			    {
				    new ID, Float:pos[4];
				    if(sscanf(command1, "i", ID)) return SendClientMessage(playerid, -1, "{ffc34d}/event set spawn (spawn number) [LIMIT 6]") && 1 || 1;
					if((ID-1) < 0 || (ID-1) >= 17) return SendClientMessage(playerid, -1, "{ffc34d}/event set spawn (spawn number) [LIMIT 6]") && 1 || 1;
					if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
					if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

	                
					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					GetPlayerFacingAngle(playerid, pos[3]);
					
					switch(ID)
					{
					    case 1:
					    {
					        EventInfo[eventID][e_HumanPos][0] = pos[0];
							EventInfo[eventID][e_HumanPos][1] = pos[1];
				            EventInfo[eventID][e_HumanPos][2] = pos[2];
				            EventInfo[eventID][e_HumanPos][3] = pos[3];
					    }
					    case 2:
					    {
					        EventInfo[eventID][e_HumanPos][4] = pos[0];
							EventInfo[eventID][e_HumanPos][5] = pos[1];
				            EventInfo[eventID][e_HumanPos][6] = pos[2];
				            EventInfo[eventID][e_HumanPos][7] = pos[3];
					    }
					    case 3:
					    {
					        EventInfo[eventID][e_HumanPos][8] = pos[0];
							EventInfo[eventID][e_HumanPos][9] = pos[1];
				            EventInfo[eventID][e_HumanPos][10] = pos[2];
				            EventInfo[eventID][e_HumanPos][11] = pos[3];
					    }
					    case 4:
					    {
					        EventInfo[eventID][e_HumanPos][12] = pos[0];
							EventInfo[eventID][e_HumanPos][13] = pos[1];
				            EventInfo[eventID][e_HumanPos][14] = pos[2];
				            EventInfo[eventID][e_HumanPos][15] = pos[3];
					    }
					    case 5:
					    {
					        EventInfo[eventID][e_HumanPos][16] = pos[0];
							EventInfo[eventID][e_HumanPos][17] = pos[1];
				            EventInfo[eventID][e_HumanPos][18] = pos[2];
				            EventInfo[eventID][e_HumanPos][19] = pos[3];
					    }
					    case 6:
					    {
					        EventInfo[eventID][e_HumanPos][20] = pos[0];
							EventInfo[eventID][e_HumanPos][21] = pos[1];
				            EventInfo[eventID][e_HumanPos][22] = pos[2];
				            EventInfo[eventID][e_HumanPos][23] = pos[3];
					    }
					    default:
					    {
					        EventInfo[eventID][e_HumanPos][0] = pos[0];
							EventInfo[eventID][e_HumanPos][1] = pos[1];
				            EventInfo[eventID][e_HumanPos][2] = pos[2];
				            EventInfo[eventID][e_HumanPos][3] = pos[3];
					    }
					}
					
					

		            SendClientMessage(playerid, -1, "{FFF000}>> Set!");
				}
				return 1;
			}
			
			if(strfind(command0, "min") == 0)
 	    	{
 	    	    if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
 	    	    if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
				if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
				new count;
				if(sscanf(command1, "i", count)) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set min (min players)") && 1 || 1;
				if(count < 1 || count > MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set min (min players)") && 1 || 1;
				
				EventInfo[eventID][e_minPlayers] = count;
				SendClientMessageFormat(playerid, -1, "{ffc34d}|: Min. players is set to %d", count);
				return 1;
 	    	}
 	    	
 	    	if(strfind(command0, "max") == 0)
 	    	{
 	    	    if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
 	    	    if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
				if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
				new count;
				if(sscanf(command1, "i", count)) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set max (min players)") && 1 || 1;
				if(count < 1 || count > MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set max (min players)") && 1 || 1;

				EventInfo[eventID][e_maxPlayers] = count;
				SendClientMessageFormat(playerid, -1, "{ffc34d}|: Max. players is set to %d", count);
				return 1;
 	    	}
			
			if(strfind(command0, "skin") == 0)
 	    	{
			    something = false;
			    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][4]) { something = true; break; }
			    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

			    if(something)
			    {
	 	    	    if(strlen(command1) <= 0 || strval(command1) < 0 || strval(command1) > 311) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set skin (skin id) ([...team])") && 1 || 1;
	 	    	    if(strlen(command2) >= 1)
	 	    	    {
	 	    	        if(strval(command2) < 1 || strval(command2) > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: /event set skin (skin id) (1-6)") && 1 || 1;
	 	    	        if(!EventInfo[eventID][e_IsTeamActive][strval(command2)-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

	                    foreach(Player, j)
	 	    		    {
							if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(strval(command2)-1))
							{
							    SetPlayerSkinAC(j, strval(command1), 1);
							    SetPlayerColor(j, EventColors[strval(command2)-1]);
							}
						}
					}
	 	    	    else
	 	    		{
	 	    		    foreach(Player, j)
	 	    		    {
	 	    		        if(Player[j][eventMember] == Player[playerid][eventMember])
	 	    		        {
	 	    		            SetPlayerSkinAC(j, strval(command1), 1);
	 	    		            SetPlayerColor(j, EventColors[strval(command2)-1]);
	 	    		        }
	 	    		    }
					}
				}
				return 1;
			}
		}
		return 1;
	}

	if(strfind(command, "take") == 0)
 	{
 	    if(strfind(command0, "weapons") == 0)
 		{
 		    new something = false, i, eventID = Player[playerid][eventMember];
		    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }
		    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		    if(something)
		    {
		        new command_team = -1, Float:radius = 0.0;
				sscanf(command1, "i", command_team);
				sscanf(command1, "f", radius);
				
			 	if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;
				if(command_team > -1)
				{
					if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
	  				if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;
				}
				
				if(command_team == -1 && radius == 0.0)
    		    {
    		        new str[128];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has take weapons (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					foreach(Player, j)
					{
						if(Player[j][eventMember] == Player[playerid][eventMember])
						{
						   ResetWeapons(j);
						}
					}
    		    }
    		    else if(command_team > -1)
    		    {
    		        new str[128];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has take weapons from a team (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					foreach(Player, j)
					{
						if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(command_team-1))
						{
						   ResetWeapons(j);
						}
					}
    		    }
    		    else if(radius > 0.0)
    		    {
    		        new str[128], Float:pos[3];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has take weapons in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					foreach(Player, j)
					{
						if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
						{
							if(Player[j][eventMember] == Player[playerid][eventMember])
							{
								ResetWeapons(j);
							}
						}
					}
    		    }
				return 1;
		    }
		    return 1;
		}
 	    if(strfind(command0, "weapon") == 0)
 		{
 		    new something = false, i, eventID = Player[playerid][eventMember];
		    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }
		    if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;

		    if(something)
		    {
				new ID = -1, command_team = -1, Float:radius = 0.0;
				sscanf(command1, "i", ID);
				sscanf(command2, "i", command_team);
				sscanf(command2, "f", radius);
				if(command_team == -1 && radius == 0.0 || strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event take weapon (weapon) ([...player id / radius])") && 1 || 1;
				
				if(ID >= 0 && ID <= 45)
				{
				    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: ERROR") && 1 || 1;
					new gunname[32];
					GetWeaponName(ID, gunname, sizeof(gunname));
                    
					if(radius > 0.0)
				    {
	       				new str[128], Float:pos[3];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has take weapon in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						foreach(Player, j)
						{
							if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
							{
								if(Player[j][eventMember] == Player[playerid][eventMember])
								{
					               	SetPVarInt(j, gunname, 0);
					        		SetPlayerAmmoAC(j, ID, 0);
								}
							}
						}
				    }
				    else if(command_team > -1)
				    {
				        if(!IsPlayerConnected(command_team) || command_team >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event take weapon (weapon) ([...player id / radius])") && 1 || 1;
				        if(Player[command_team][eventMember] != Player[playerid][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event take weapon (weapon) ([...player id / radius])") && 1 || 1;
				        new str[128];
		    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has take %s's weapon (%s #%d)", Player[playerid][UserName], Player[command_team][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
						
                        GetWeaponName(ID, gunname, sizeof(gunname));
						SetPVarInt(command_team, gunname, 0);
    					SetPlayerAmmoAC(command_team, ID, 0);
						return 1;
					}
				}
				else return SendClientMessage(playerid, -1, "{ffc34d}|: /event take weapon (weapon) ([...player id / radius])") && 1 || 1;
			}
			return 1;
 		}
 		return 1;
	}
	
    if(strfind(command, "show") == 0)
 	{
 	    if(!Player[playerid][pLogged]) return 1;
  		if(IsPlayerOnDuel[playerid])  return 1;
    	if(Player[playerid][Jailed] >= 1) return 1;
		if(IsPlayerInAnyVehicle(playerid)) return 1;
		if(CockroachAbility[playerid]) return 1;


		new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;

		if(EventInfo[eventID][e_RequestToDelete]) return 1;

        something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    if(strfind(command0, "text") == 0)
 	    	{
 	    	    if(strlen(command1) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event show text (text)") && 1 || 1;
 	    	    else
 	    		{
 	    		    if(!EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event did not started") && 1 || 1;
					if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
					if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

 	    		    if(CheckForWebsite(command1) || CheckForIP(command1)) return SendClientMessage(playerid, -1, "{ffc34d}|: Use a different text") && 1 || 1;
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) GameTextForPlayer(j, command1, 2000, 5);
				}
				return 1;
			}
		}
		return 1;
	}
	
	if(strfind(command, "freeze") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    //if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

			new ID = -1, Float:radius = 0.0, command_team = 1;
		    sscanf(command0, "f", radius);
		    sscanf(command0, "i", ID);
	        sscanf(command1, "i", command_team);

		    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

			if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
	    	if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

		    if(ID == -1 && radius == 0.0 || strlen(command0) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event freeze (player id / radius) ([...team])") && 1 || 1;
		    else
			{
			    if(ID > -1)
			    {
			        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event freeze (player id / radius) ([...team])") && 1 || 1;
			        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event freeze (player id / radius) ([...team])") && 1 || 1;
                    if(EventInfo[eventID][e_OwnerID] != Player[ID][pAccountID])
                    {
                        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[ID][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) {}
                        else
                        {
							new str[128];
			    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has froze %s (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
							foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
							TogglePlayerControllable(ID, 0);
						}
					}
				}
			    else if(radius > 0.0)
			    {
			        new str[128], Float:pos[3];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has froze players in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					foreach(Player, j)
					{
						if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
						{
							if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(command_team-1) && EventInfo[eventID][e_OwnerID] != Player[j][pAccountID])
							{
							    for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[j][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) {}
							    else TogglePlayerControllable(j, 0);
							}
						}
					}
			    }
		    	return 1;
			}
		}
		return 1;
 	}
 	
 	if(strfind(command, "getall") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    //if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
			if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;
   			new str[128], Float:pos[3];
			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has teleported all players to him (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
			foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
			GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
			foreach(Player, j)
			{
				if(Player[j][eventMember] == Player[playerid][eventMember] && j != playerid)
				{
    				SetPlayerPos(j, pos[0] + 0.2, pos[1] + 0.2, pos[2] + 0.5);
				}
			}
		}
		return 1;
	}
 	
 	if(strfind(command, "get") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    //if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

			new ID = -1, Float:radius = 0.0, command_team = 1;
		    sscanf(command0, "f", radius);
		    sscanf(command0, "i", ID);
	        sscanf(command1, "i", command_team);

		    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

			if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
	    	if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

		    if(ID == -1 && radius == 0.0 || strlen(command0) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event get (player id / radius) ([...team])") && 1 || 1;
		    else
			{
			    if(ID > -1)
			    {
			        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event get (player id / radius) ([...team])") && 1 || 1;
			        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event get (player id / radius) ([...team])") && 1 || 1;
			        new str[128], Float:pos[3];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has teleported %s to him (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					SetPlayerPos(ID, pos[0] + 0.2, pos[1] + 0.2, pos[2] + 0.5);
			    }
			    else if(radius > 0.0)
			    {
			        new str[128], Float:pos[3];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has teleported players in a range to him (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					foreach(Player, j)
					{
						if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(command_team-1) && j != playerid)
						{
		    				SetPlayerPos(j, pos[0] + 0.2, pos[1] + 0.2, pos[2] + 0.5);
						}
					}
			    }
	            return 1;
	        }
		}
	}

    if(strfind(command, "edit") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][0]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    new ID;
		    if(sscanf(command0, "i", ID)) return SendClientMessage(playerid, -1, "{ffc34d}|: /event edit (object id)") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
            if(ID < 0 || ID > 100 || !IsValidDynamicObject(EventInfo[eventID][e_Objects][ID])) return SendClientMessage(playerid, -1, "{ffc34d}|: /event edit (object id)") && 1 || 1;
            EditDynamicObject(playerid, EventInfo[eventID][e_Objects][ID]);
		}
	}
	
	if(strfind(command, "here") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    new Float:pos[3];
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
            GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
			EventInfo[eventID][e_defaultPoses][0] = pos[0];
			EventInfo[eventID][e_defaultPoses][1] = pos[1];
            EventInfo[eventID][e_defaultPoses][2] = pos[2];
            SendClientMessage(playerid, -1, "{FFF000}>> Set!");
		}
		return 1;
	}
	
	if(strfind(command, "odel") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][0]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    new ID;
		    if(sscanf(command0, "i", ID)) return SendClientMessage(playerid, -1, "{ffc34d}|: /event odel (object id)") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
            if(ID < 0 || ID > 100 || !IsValidDynamicObject(EventInfo[eventID][e_Objects][ID])) return SendClientMessage(playerid, -1, "{ffc34d}|: /event edit (object id)") && 1 || 1;
			DestroyDynamicObject(EventInfo[eventID][e_Objects][ID]);
			EventInfo[eventID][e_Objects][ID] = INVALID_OBJECT_ID;
		}
	}

	if(strfind(command, "object") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][0]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    new ID, Float:pos[3];
		    if(sscanf(command0, "i", ID)) return SendClientMessage(playerid, -1, "{ffc34d}|: /event object (object id)") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;
            GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
            GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 3.0);

	        for( new eoID = 0; eoID < 100; eoID++)
			{
				if(EventInfo[eventID][e_Objects][eoID] == INVALID_OBJECT_ID || !IsValidDynamicObject(EventInfo[eventID][e_Objects][eoID]))
				{
					EventInfo[eventID][e_Objects][eoID] = CreateDynamicObject(ID, pos[0], pos[1], pos[2], 0.0, 0.0, 0.0, GetPlayerVirtualWorld(playerid), -1, -1);
					EditDynamicObject(playerid, EventInfo[eventID][e_Objects][eoID]);
					SendClientMessageFormat(playerid, -1, "{FFF000}[DEVMODE] | Object created: #%d", eoID);
					break;
				}
			}
		}
	}

	if(strfind(command, "unfreeze") == 0)
	{
	    new eventID = Player[playerid][eventMember], i, bool:something;
		if(eventID <= -1) return 1;
		if(EventInfo[eventID][e_RequestToDelete]) return 1;
		something = false;
        for(i = 0; i < 10; i++) if(EventInfo[eventID][e_Rulers][i] == Player[playerid][pAccountID] && EventInfo[eventID][e_RulersPermisions][7]) { something = true; break; }
		if(EventInfo[eventID][e_OwnerID] == Player[playerid][pAccountID]) something = true;
		if(something)
		{
		    //if(EventInfo[eventID][e_IsStarted]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event already started") && 1 || 1;
			if(EventInfo[eventID][e_IsEnded]) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event is preparing to ending") && 1 || 1;
			if(EventInfo[eventID][e_RequestToDelete]) return SendClientMessage(playerid, -1, "{ffc34d}|: Event in reset processing") && 1 || 1;

			new ID = -1, Float:radius = 0.0, command_team = 1;
		    sscanf(command0, "f", radius);
		    sscanf(command0, "i", ID);
	        sscanf(command1, "i", command_team);

		    if(strlen(EventInfo[eventID][e_Name]) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: Error, event name not set, /event set name") && 1 || 1;

			if(command_team < 1 || command_team > 6) return SendClientMessage(playerid, -1, "{ffc34d}|: Min.1 and Max. 6 teams)") && 1 || 1;
	    	if(!EventInfo[eventID][e_IsTeamActive][command_team-1]) return SendClientMessage(playerid, -1, "{ffc34d}|: This team is not activated, /event set teams") && 1 || 1;

		    if(ID == -1 && radius == 0.0 || strlen(command0) <= 0) return SendClientMessage(playerid, -1, "{ffc34d}|: /event unfreeze (player id / radius) ([...team])") && 1 || 1;
		    else
			{
			    if(ID > -1)
			    {
			        if(!IsPlayerConnected(ID) || ID >= MAX_PLAYERS) return SendClientMessage(playerid, -1, "{ffc34d}|: /event unfreeze (player id / radius) ([...team])") && 1 || 1;
			        if(Player[playerid][eventMember] != Player[ID][eventMember]) return SendClientMessage(playerid, -1, "{ffc34d}|: /event unfreeze (player id / radius) ([...team])") && 1 || 1;
			        new str[128];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has thawed %s (%s #%d)", Player[playerid][UserName], Player[ID][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);
					TogglePlayerControllable(ID, 1);
			    }
			    else if(radius > 0.0)
			    {
			        new str[128], Float:pos[3];
	    			format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has thawed players in a range (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
					foreach(Player, j) if(Player[j][eventMember] == Player[playerid][eventMember]) SendClientMessage(j, -1, str);

					GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
					foreach(Player, j)
					{
						if(IsPlayerInRangeOfPoint(j, radius, pos[0], pos[1], pos[2]))
						{
							if(Player[j][eventMember] == Player[playerid][eventMember] && GetPlayerTeamEx(j) == (3*(eventID+1))+(command_team-1))
							{
							    TogglePlayerControllable(j, 1);
							}
						}
					}
			    }
		    	return 1;
			}
		}
		return 1;
 	}
 	
    if(!strlen(command) || strfind(command, "help") == 0)
	{
	    SendClientMessage(playerid, -1, "/event help");
	    SendClientMessage(playerid, -1, "/event join");
	    SendClientMessage(playerid, -1, "/event leave");
	    if(GetUnlockedSlot(Player[playerid][pSettings], 29) == 1 || IsEventRuler(playerid))
	    {
			//SendClientMessage(playerid, -1, "/jetpack");
			SendClientMessage(playerid, -1, "/event set permissions [ON|OFF] (dev mode) ([...close joins, set spawns, set car spawns, set skins, set teams, kick players])"); // OK
			SendClientMessage(playerid, -1, "/event set ruler (account id) ([...off])"); // OK
			SendClientMessage(playerid, -1, "/event set min (min players count)"); // OK
			SendClientMessage(playerid, -1, "/event set max (max players count)"); // OK
			SendClientMessage(playerid, -1, "/event set spawn (spawn number)"); // OK
			SendClientMessage(playerid, -1, "/event set team (player id / radius) (team)"); // OK
			SendClientMessage(playerid, -1, "/event set car (car number) (carid) (color1) (color2) ([...for team])  [LIMIT 18]"); // OK
			SendClientMessage(playerid, -1, "/event here (sets ruler & creator default spawn pos)"); // OK
			SendClientMessage(playerid, -1, "/event odel (event's object id)"); // OK
			SendClientMessage(playerid, -1, "/event edit (event's object id)"); // OK
			SendClientMessage(playerid, -1, "/event object (object id)"); // OK
			SendClientMessage(playerid, -1, "/event devmode"); // OK
            SendClientMessage(playerid, -1, "/event get (player id / radius) ([...team])"); // OK
            SendClientMessage(playerid, -1, "/event getall"); // OK
			SendClientMessage(playerid, -1, "/event freeze (player id / radius) ([...team])"); // OK
			SendClientMessage(playerid, -1, "/event unfreeze (player id / radius) ([...team])"); // OK
			SendClientMessage(playerid, -1, "/event set name (name)"); // OK
			SendClientMessage(playerid, -1, "/event set weapon (player id / radius) (weaponid) (ammo) ([...team])"); // OK
			SendClientMessage(playerid, -1, "/event set hp (player id / radius) ([...team])"); // OK
			SendClientMessage(playerid, -1, "/event set armor (player id / radius) ([...team])"); // OK
			SendClientMessage(playerid, -1, "/event start");// OK
			SendClientMessage(playerid, -1, "/event close joins"); // OK
			SendClientMessage(playerid, -1, "/event end");// ok
			SendClientMessage(playerid, -1, "/event show text (text)"); // OK
			SendClientMessage(playerid, -1, "/event kick (player id)"); // OK
			SendClientMessage(playerid, -1, "/event set skin (skin id) ([...team])");// OK
			SendClientMessage(playerid, -1, "/event set rank (min rank)"); // OK
			SendClientMessage(playerid, -1, "/event set exp (min exp)"); // OK
			SendClientMessage(playerid, -1, "/event set gang"); // OK
			SendClientMessage(playerid, -1, "/event set teams (1 - 6)"); // OK
			SendClientMessage(playerid, -1, "/event set gravity (intensity | Default: 0.008)"); // OK
			SendClientMessage(playerid, -1, "/event set pickup (number 1 ~ 40) (Pickup = Object ID)"); // OK
			SendClientMessage(playerid, -1, "/event set time (time)"); // OK
			SendClientMessage(playerid, -1, "/event set weather (weather)"); // OK
			
	    }
	    return 1;
	}
    return 1;
}

fun FirePlayerFromAGang(playerid)
{
	if(cache_num_rows() > 0)
	{
	    new clan, rank, id, name[MAX_PLAYER_NAME];
	    cache_get_value_name_int(0, "Clan", clan);
		cache_get_value_name_int(0, "ClanRank", rank);
		cache_get_value_name_int(0, "ID", id);
		cache_get_value_name(0, "Name", name, MAX_PLAYER_NAME);
		
		if(Player[playerid][pClan] != clan || Player[playerid][pClan] == clan && Player[playerid][pClanRank] <= rank)
		{
		    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][135]);
			return 1;
		}
		
		new query[144];
		mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan` = '0',`ClanRank` = '0' WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "", "", "");
		
		foreach(Player, i)
        {
            if(Player[i][pClan] == Player[playerid][pClan])
            {
                SendClientMessageFormat(i, -1, "{C659B6}>> %s has been fired by %s", name, Player[playerid][UserName]);
			}
        }
        
        foreach(Player, i)
		{
			if(Player[i][pAccountID] == id)
            {
                Player[i][pClanWarns] = 0;
	            Player[i][pClan] = 0;
	            Player[i][pClanRank] = 0;
            }
		}
		
        Clan[Player[playerid][pClan]][g_MaxMembers]--;
        #if debug_mode == 0
        new __action[200], y, m, d, h, minutes, s;
		TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
		DiscordChannel = DCC_FindChannelById("662009624110694440");
		format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been fired by %s\n```", d, m, y, h, minutes, Player[playerid][pClan], name, Player[playerid][UserName]);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		#endif
	}
	else
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][161]);
	}
	return 1;
}

fun CreateAGang(playerid, kid, targetid, const amount[])
{
	Clan[kid][__RealID] = cache_insert_id();
	if(Clan[kid][__RealID] > -1)
	{
		foreach(Player, i) SendClientMessageFormat(i, -1,  serverLang[Player[i][pLang]][121], Player[targetid][UserName], amount, kid);
		Player[targetid][pClan] = kid;
		Player[targetid][pClanRank] = 6;

		strmid(Clan[Player[targetid][pClan]][Full], amount, 0, 128, 129);
		strmid(Clan[Player[targetid][pClan]][Short], amount, 0, 5, 6);
		strmid(Clan[Player[targetid][pClan]][Rank_0], "Peon", 0, 6, 6);
		strmid(Clan[Player[targetid][pClan]][Rank_1], "Policeman", 0, 15, 15);
		strmid(Clan[Player[targetid][pClan]][Rank_2], "Scout", 0, 8, 8);
		strmid(Clan[Player[targetid][pClan]][Rank_3], "Agent", 0, 8, 8);
		strmid(Clan[Player[targetid][pClan]][Rank_4], "Senior Agent", 0, 20, 20);
		strmid(Clan[Player[targetid][pClan]][Rank_5], "Director", 0, 20, 20);
		strmid(Clan[Player[targetid][pClan]][Owner], Player[targetid][UserName], 0, 25, 25);
		Clan[kid][__isActive] = true;
		Clan[kid][EXP] = 0;

		Clan[kid][g_isClosed] = 0;
	    Clan[kid][g_MinExp] = 0;
	    Clan[kid][g_MaxPayAmt] = 5000;
	    Clan[kid][g_MaxWarns] = 3;
	    Clan[kid][g_RankToPromote] = 2;
	    Clan[kid][g_RankToAccept] = 3;
	    Clan[kid][g_RankToWarn] = 3;
	    Clan[kid][g_RankToMotd] = 5;
	    Clan[kid][g_RankGivePayDay] = 5;
	    Clan[kid][g_RankToEdit] = 6;
	    Clan[kid][g_RankToEditReq] = 6;
	    Clan[kid][g_RankToChangeRules] = 5;
		Clan[kid][g_RankToBan] = 5;
		Clan[kid][g_MaxMembers] = 1;
		Clan[kid][g_IsNeutral] = 1;
		Clan[kid][g_CanPanelUse] = 6;
		Clan[kid][g_OwnerID] = Player[targetid][pAccountID];
		Clan[kid][g_FoundedDate] = gettime();
		
		for( new i; i < 30; i++ )
		{
		    Clan[kid][g_EnemysWith][i] = 0;
		    Clan[kid][g_AllianceWith][i] = 0;
			Clan[kid][g_Cups][i] = 0;
		    Clan[kid][g_CupsAlliance][i] = 0;

		    Clan[i][g_EnemysWith][kid] = 0;
		    Clan[i][g_AllianceWith][kid] = 0;
		    Clan[i][g_CupsAlliance][kid] = 0;
		}

		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /gang create on player %s\n```",  Player[playerid][RealName], Player[targetid][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	return 1;
}

public OnPlayerEditDynamicObject(playerid, objectid, response, Float:x, Float:y, Float:z, Float:rx, Float:ry, Float:rz)
{
    if(response == EDIT_RESPONSE_FINAL)
    {
		SetDynamicObjectPos(objectid, x, y, z);
		SetDynamicObjectRot(objectid, rx, ry, rz);
	}
	return 1;
}

CMD:raws(playerid)
{
    if(Player[playerid][pAccountID] == 1)
	{
	    for( new j; j < 30; j++ )
	    {
			for( new i; i < 30; i++ )
			{
	      		Clan[j][g_EnemysWith][i] = 0;
			    Clan[j][g_AllianceWith][i] = 0;
				Clan[j][g_Cups][i] = 0;
			    Clan[j][g_CupsAlliance][i] = 0;

			    Clan[i][g_EnemysWith][j] = 0;
			    Clan[i][g_AllianceWith][j] = 0;
			    Clan[i][g_CupsAlliance][j] = 0;
			}
		}
		return 1;
	}
	return 0;
}

CMD:gang(playerid, const params[])
{
	new command[32], name[96], amount[128];
	//sscanf(params, "S()[32]I(-1)", command, index);
	sscanf(params, "S()[32]S()[96]S()[128]", command, name, amount);
	
	if(!strlen(command) || strfind(command, "help") == 0)
	{
	    SendClientMessage(playerid, -1, "/gang list");
	    SendClientMessage(playerid, -1, "/gang info");
	    SendClientMessage(playerid, -1, "/gang join");
	    SendClientMessage(playerid, -1, "/gang leave");
	    SendClientMessage(playerid, -1, "/gang chat");
    	SendClientMessage(playerid, -1, "/gang mot");
     	SendClientMessage(playerid, -1, "/gang rules");
     	SendClientMessage(playerid, -1, "/gang policy");
     	
     	SendClientMessage(playerid, -1, "/gang members");
      	SendClientMessage(playerid, -1, "/gang pay");
      	SendClientMessage(playerid, -1, "/gang deposit");
       	SendClientMessage(playerid, -1, "/gang accept");
       	
       	SendClientMessage(playerid, -1, "/gang promote");
       	SendClientMessage(playerid, -1, "/gang demote");
       	SendClientMessage(playerid, -1, "/gang rank");
       	SendClientMessage(playerid, -1, "/gang tag");
       	SendClientMessage(playerid, -1, "/gang name");
       	
       	SendClientMessage(playerid, -1, "/gang alliance (Use '+' to chat with alliance)");
       	SendClientMessage(playerid, -1, "/gang war");
       	SendClientMessage(playerid, -1, "/gang match");
       	SendClientMessage(playerid, -1, "/gang agree");
       	
       	SendClientMessage(playerid, -1, "/gang house"); // OK
       	SendClientMessage(playerid, -1, "/gang warn"); // OK
       	SendClientMessage(playerid, -1, "/gang panel"); // ALMOST
       	
       	SendClientMessage(playerid, -1, "/gang ban"); // OK
       	SendClientMessage(playerid, -1, "/gang unban"); // OK

       	SendClientMessage(playerid, -1, "To create / delete / get ownership of a gang - Contact Gang Manager (GM)");
       	
	}
	else
	{
	    if(strfind(command, "panel") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) panel");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
			{
			    new gid = Player[playerid][pClan];
   				if(Player[playerid][pAccountID] != Clan[gid][g_OwnerID] || Player[playerid][pClanRank] < Clan[gid][g_RankToEditReq]) {
                    SendClientMessage(playerid, -1, "{FFF000}>> Only gang founder can use this panel, or request rights to access it");
   				    return 1;
   				}
   				
   				new info[1024], f[128];
   				if(Clan[gid][g_isClosed]) strcat(info, "{1500ff}- Gang Joining:{FFFFFF} Disabled\n"); else strcat(info, "{1500ff}- Gang Joining:{FFFFFF} Enabled\n");
   				format(f, sizeof(f), "{1500ff}- MIN Rank To Join:{FFFFFF} %d\n", Clan[gid][g_MinExp]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- LIMIT per /gang pay:{FFFFFF} %d\n", Clan[gid][g_MaxPayAmt]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- MAX warnings:{FFFFFF} %d\n", Clan[gid][g_MaxWarns]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- Rank That Can Promote/Demote:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToPromote], gid), Clan[gid][g_RankToPromote]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- Rank That Can Accept Requests:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToAccept], gid), Clan[gid][g_RankToAccept]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- Rank That Can Warn Members:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToWarn], gid), Clan[gid][g_RankToWarn]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- Rank That Can Blacklist Members:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToBan], gid), Clan[gid][g_RankToBan]); strcat(info, f);
                format(f, sizeof(f), "{1500ff}- Rank That Can Give PayDays:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankGivePayDay], gid), Clan[gid][g_RankGivePayDay]); strcat(info, f);
	  			format(f, sizeof(f), "{1500ff}- Rank That Can Edit Gang:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToEdit], gid), Clan[gid][g_RankToEdit]); strcat(info, f);
   				format(f, sizeof(f), "{1500ff}- Rank That Can Use Gang Panel:{FFFFFF}%s (%d)\n", GetRankByID(Clan[gid][g_RankToEditReq], gid), Clan[gid][g_RankToEditReq]); strcat(info, f);
   				
   				ShowPlayerDialog(playerid, DIALOG_GANG_SETTINGS, DIALOG_STYLE_LIST, "Gang Panel", info, "Select", "Cancel");
			}
			return 1;
		}
		
		if(strfind(command, "unban") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) unban");
		        }
			}
            if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToBan])
			{
			    if(strlen(name) <= 0 || strval(name) < 0)
		        {
		            SendClientMessage(playerid, -1, "/unban (id)");
		            return 1;
				}
				if(!IsPlayerConnected(strval(name)))
				{
					SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
					return 1;
				}
				if(GetUnlockedSlot(Player[strval(name)][GangBanned], Player[playerid][pClan]) <= 0)
				{
				    SendClientMessage(playerid, -1, "{C659B6}>> The player is not in the blacklist");
				    return 1;
				}
				foreach(Player, i)
  				{
	                if(Player[i][pClan] == Player[playerid][pClan])
	                {
	                    SendClientMessageFormat(playerid, -1, "{C659B6}>> %s has been deleted from gang blacklist by %s", Player[strval(name)][UserName], Player[playerid][UserName]);
					}
	            }

	            #if debug_mode == 0
	            new __action[200], y, m, d, h, minutes, s;
				TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
				DiscordChannel = DCC_FindChannelById("662009624110694440");
				format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been deleted from gang blacklist by %s\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName]);
				DCC_SendChannelMessageEx(DiscordChannel, __action);
	            #endif

	            SetUnlockedSlot(Player[strval(name)][GangBanned], Player[playerid][pClan], 0);
	            return 1;
			}
	    }
		
		if(strfind(command, "ban") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) ban");
		        }
			}
            if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToBan])
			{
			    if(strlen(name) <= 0 || strval(name) < 0)
		        {
		            SendClientMessage(playerid, -1, "/gang ban (id) (reason)");
		            return 1;
				}
				if(strlen(amount) <= 0)
				{
				    SendClientMessage(playerid, -1, "/gang ban (id) (reason)");
		            return 1;
				}
				if(!IsPlayerConnected(strval(name)))
				{
					SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
					return 1;
				}
				if(Player[strval(name)][pClanRank] >= Player[playerid][pClanRank] || Player[strval(name)][pClan] != Player[playerid][pClan] && Player[strval(name)][pClan] != 0 || Player[strval(name)][pAccountID] == Clan[Player[playerid][pClan]][g_OwnerID])
				{
				    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][135]);
				    return 1;
				}
				foreach(Player, i)
  				{
	                if(Player[i][pClan] == Player[playerid][pClan])
	                {
	                    SendClientMessageFormat(i, -1, "{C659B6}>> %s has been added to gang blacklist by %s [Reason: %s]", Player[strval(name)][UserName], Player[playerid][UserName], amount);
					}
	            }
	            Clan[Player[playerid][pClan]][g_MaxMembers]--;
	            if(Player[strval(name)][pClan] == Player[playerid][pClan])
				{
			 		Player[strval(name)][pClanWarns] = 0;
	            	Player[strval(name)][pClan] = 0;
	            	Player[strval(name)][pClanRank] = 0;
	            	SetUnlockedSlot(Player[strval(name)][GangBanned], Player[playerid][pClan], 1);
				}

				#if debug_mode == 0
				new __action[200], y, m, d, h, minutes, s;
				TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
				DiscordChannel = DCC_FindChannelById("662009624110694440");
				format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been added to gang blacklist by %s [Reason: %s]\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName], amount);
				DCC_SendChannelMessageEx(DiscordChannel, __action);
				#endif

				return 1;
			}
			return 1;
	    }
		
		if(!strcmp(command, "warn"))
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) warn");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToWarn])
			{
		        if(strlen(name) <= 0 || strval(name) < 0)
		        {
		            SendClientMessage(playerid, -1, "/gang warn (id) (reason)");
		            return 1;
				}
				if(strlen(amount) <= 0)
				{
				    SendClientMessage(playerid, -1, "/gang warn (id) (reason)");
		            return 1;
				}
		 		if(!IsPlayerConnected(strval(name)))
				{
					SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
					return 1;
				}
				
				if(Player[strval(name)][pClanRank] >= Player[playerid][pClanRank] || Player[strval(name)][pAccountID] == Clan[Player[playerid][pClan]][g_OwnerID])
				{
				    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][135]);
				    return 1;
				}
				Player[strval(name)][pClanWarns]++;

				#if debug_mode == 0
				new __action[200], y, m, d, h, minutes, s;
				TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
				DiscordChannel = DCC_FindChannelById("662009624110694440");
				format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been warned by %s [Reason: %s] (%d/%d)\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName], amount, Player[strval(name)][pClanWarns], Clan[Player[playerid][pClan]][g_MaxWarns]);
				DCC_SendChannelMessageEx(DiscordChannel, __action);
				#endif

				if(Player[strval(name)][pClanWarns] < Clan[Player[playerid][pClan]][g_MaxWarns])
				{
					foreach(Player, i)
	  				{
		                if(Player[i][pClan] == Player[playerid][pClan])
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s has been warned by %s [Reason: %s] (%d/%d)", Player[strval(name)][UserName], Player[playerid][UserName], amount, Player[strval(name)][pClanWarns], Clan[Player[playerid][pClan]][g_MaxWarns]);
                            ShowPlayerDialog(strval(name), DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{C659B6}Gang Warning", amount, "Ok", "");
						}
		            }
	            }
	            else
	            {
	                foreach(Player, i)
	  				{
		                if(Player[i][pClan] == Player[playerid][pClan])
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s has been fired by %s [Reason: Maximum violations reached]", Player[strval(name)][UserName], Player[playerid][UserName]);
                            ShowPlayerDialog(strval(name), DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{C659B6}Gang Warning", amount, "Ok", "");
						}
		            }
		            Clan[Player[playerid][pClan]][g_MaxMembers]--;
		            Player[strval(name)][pClanWarns] = 0;
		            Player[strval(name)][pClan] = 0;
		            Player[strval(name)][pClanRank] = 0;

		            #if debug_mode == 0
					TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been fired by %s [Reason: Maximum violations reached]\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif

	            }
	            return 1;
			}
			return 1;
	    }
		
		if(strfind(command, "house") == 0)
	    {
	        if(Clan[Player[playerid][pClan]][g_House] >= 1)
	        {
	            if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	            {
	                for( new j = 0; j < sizeof(Map[ZombieSpawnX]); j++ )
					{
     					if(IsPlayerInRangeOfPoint(playerid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j]))
     					{
				            InGangHouse[playerid] = true;
				            SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
							SpawnPlayer(playerid);
							return 1;
						}
					}
					SendClientMessage(playerid, -1, "{FFF000}>> You need to be in a spawn area");
					return 1;
				}
				else
				{
					SendClientMessage(playerid, -1, "{FFF000}>> You need to be a zombie!");
					return 1;
				}
			}
			else
			{
			    SendClientMessage(playerid, -1, "{FFF000}>> You don't have gang house!");
			    return 1;
			}
			return 1;
	    }
		
	    if(strfind(command, "agree") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) agree");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
			{
   				if(Player[playerid][pClanRank] <= 5)
			    {
			        SendClientMessage(playerid, -1, "Only Leader can use this command");
		            return 1;
				}
				
				new gid = Player[playerid][pClan], gang = strval(name);
				if(gang < 1 || gang >= sizeof(Clan)) {
				    SendClientMessage(playerid, -1, "This gang didn't claim to want a match with you");
				    return 1;
				}
				
				if( Clan[gid][g_CupsAlliance][gang] <= 0) {
				    SendClientMessage(playerid, -1, "This gang didn't claim to want a match with you");
				    return 1;
				}
				else if( Clan[gid][g_CupsAlliance][gang] >= 1 )
				{
				    Clan[gid][g_WeeksToKick] = gang;
					ShowPlayerDialog(playerid, DIALOG_ACCEPT_MATCH, DIALOG_STYLE_MSGBOX, "{FFFF00}[Warning]", "Your gang members are free to choose whether to join the match or not\nDo not think that you alone can defeat another gang\n\nDo you already know exactly who and with what forces is going into match?", "Match", "I think");
				    return 1;
				}
			}
			return 1;
		}
		
	    if(strfind(command, "match") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) alliance");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
			{
			    if(InGangHouse[playerid]) {
			        SendClientMessage(playerid, -1, "leave your gang house");
			        return 1;
			    }
			    
   				if(Player[playerid][pClanRank] >= 6)
			    {
			        for( new j = 0; j < sizeof(Clan); j++ ) {
			            if(Clan[Player[playerid][pClan]][g_AllianceWith][j] >= 2 && Clan[j][g_Emblem] >= 1 && Clan[Player[playerid][pClan]][g_Emblem] <= 0) {
                            new gid = Player[playerid][pClan];
                            Clan[gid][g_TimesPlayed] = gettime()+99000;
							Clan[gid][g_WeeksToKick] = Clan[j][g_WeeksToKick];
	    					Clan[gid][g_Emblem] = 100 + j;
					    	Clan[gid][g_WarForCup] = 1;
					    	Clan[gid][g_TimeToJoin] = 1;
					    	Clan[gid][g_WarType] = Clan[j][g_WarType];
					    	
							SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: The match is gaining momentum %s are in action", Clan[Player[playerid][pClan]][Full]);

							foreach(Player, i) {
                                if(Player[i][pClan] == Player[playerid][pClan]) {
							    	if(Player[i][pClanRank] >= 5) SetGangMatchClass(i, 0, Clan[Player[i][pClan]][g_WarType]);
							    	else SendClientMessage(i, -1, "{C659B6}>> Your gang leader has accepted a match join by /gang match, you have 1 minute to join");
                                }
                            }
			                return 1;
			            }
			        }
					if(strlen(name) <= 0) {
					    SendClientMessage(playerid, -1, "/gang match (map id)");
					    return 1;
					}

					new query[128];
		    		mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name` FROM `maps` ORDER BY `ID` DESC LIMIT 1");
		 			mysql_tquery(Base, query, "LoadMapsCount");

					if((strval(name)-1) > maps || strval(name) <= 0) {
	                    SendClientMessageFormat(playerid, -1, "{FFFF00}>> Wrong map id, from 1 to %d", maps);
					    return 1;
					}

		    		mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`controlled` FROM `maps` WHERE `ID` = '%d'", strval(name)-1);
		 			mysql_tquery(Base, query, "LoadMapGang", "d", playerid);
	 				return 1;
				}
				else
				{
				    if(Clan[Player[playerid][pClan]][g_TimeToJoin] >= 1) ShowPlayerDialog(playerid, DIALOG_MATCH_CLASS, DIALOG_STYLE_LIST, "{FFFF00}[MATCH]", "SHIELDER\nMELEE KILLER\nRANGED KILLER", "Go", "Close");
					return 1;
				}
			}
			return 1;
		}
				
	    if(strfind(command, "alliance") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) alliance");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
			{
   				if(Player[playerid][pClanRank] <= 5)
			    {
			        SendClientMessage(playerid, -1, "Only Leader can accept an alliance!");
		            return 1;
				}

		        if(strlen(name) <= 0 || strval(name) < 0 || !Clan[strval(name)][__isActive] || strval(name) == Player[playerid][pClan])
		        {
		            SendClientMessage(playerid, -1, "/gang alliance (gang id)");
		            return 1;
				}

				if(Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] == 2)
				{
				    SendClientMessage(playerid, -1, "{FFF000}>> You are already in the alliance!");
				    return 1;
				}

				new ac = 0, mc = 0;
				for( new i; i < 30; i++ )
				{
				    if(Clan[strval(name)][g_AllianceWith][i] == 2) ac++;
				    if(Clan[Player[playerid][pClan]][g_AllianceWith][i] == 2) mc++;
				}
				
				if(Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] == 1)
				{
				    for( new i; i < 30; i++ )
					{
					    if(Clan[strval(name)][g_AllianceWith][i] == 2 && Clan[Player[playerid][pClan]][g_EnemysWith][i] <= -1 && i > 0)
					    {
                            SendMessageFormatToAll(-1, "{ff0000}>> Impossible to make an alliance with a gang, they have your enemies in alliance (%s)", Clan[i][Full]);
					        return 1;
					    }
					}

					Clan[Player[playerid][pClan]][g_AllianceWith][strval(name)] = 2;
					Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] = 2;
					Clan[strval(name)][g_EnemysWith][Player[playerid][pClan]] = 0;
					Clan[Player[playerid][pClan]][g_EnemysWith][strval(name)] = 0;

					for( new i; i < 30; i++ ) if(Clan[strval(name)][g_EnemysWith][i] <= -1) Clan[Player[playerid][pClan]][g_EnemysWith][i] = -2;
					
					SendMessageFormatToAll(-1, "{ffcc99}>> %s made an alliance with %s", Clan[Player[playerid][pClan]][Full], Clan[strval(name)][Full]);
					foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan] || Player[i][pClan] == strval(name)) SendClientMessage(i, -1, "{b3ffb3}>> Use '+' to chat with alliance!");
				    return 1;
				}
				else
				{
					foreach(Player, i)
	  				{
		                if(Player[i][pClan] == strval(name) && Player[i][pClanRank] >= 6)
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s wants to make an alliance with you, use /gang alliance %d", Clan[Player[playerid][pClan]][Full], Player[playerid][pClan]);
		                }
		            }
		            SendMessageFormatToAll(-1, "{ffcc99}>> %s wants to make an alliance with %s", Clan[Player[playerid][pClan]][Full], Clan[strval(name)][Full]);
		            Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] = 1;
		            Clan[Player[playerid][pClan]][g_AllianceWith][strval(name)] = 1;
		            return 1;
				}
			}
			return 1;
	    }
	    if(!strcmp(command, "war"))
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) war");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
			{
			    if(Player[playerid][pClanRank] <= 5)
			    {
			        SendClientMessage(playerid, -1, "Only Leaders can declare wars");
		            return 1;
				}
				
		        if(strlen(name) <= 0 || strval(name) <= 0 || !Clan[strval(name)][__isActive] || strval(name) == Player[playerid][pClan])
		        {
		            SendClientMessage(playerid, -1, "/gang war (gang id)");
		            return 1;
				}

                if(Clan[strval(name)][g_EnemysWith][Player[playerid][pClan]] == -1)
				{
                    for( new i; i < 30; i++ ) if(Clan[strval(name)][g_AllianceWith][i] >= 2) Clan[Player[playerid][pClan]][g_EnemysWith][i] = -2;

					Clan[Player[playerid][pClan]][g_AllianceWith][strval(name)] = 0;
					Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] = 0;
					Clan[strval(name)][g_EnemysWith][Player[playerid][pClan]] = -2;
					Clan[Player[playerid][pClan]][g_EnemysWith][strval(name)] = -2;
					SendMessageFormatToAll(-1, "{ffcc99}>> %s took the war with with %s", Clan[Player[playerid][pClan]][Full], Clan[strval(name)][Full]);
					return 1;
				}
				else if(Clan[strval(name)][g_EnemysWith][Player[playerid][pClan]] == 0)
				{
                	Clan[Player[playerid][pClan]][g_EnemysWith][strval(name)] = -1;
					Clan[strval(name)][g_EnemysWith][Player[playerid][pClan]] = -1;
					Clan[Player[playerid][pClan]][g_AllianceWith][strval(name)] = 0;
					Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] = 0;

					if(Clan[strval(name)][g_AllianceWith][Player[playerid][pClan]] >= 2) SendMessageFormatToAll(-1, "{ffcc99}>> %s terminated the alliance with %s", Clan[Player[playerid][pClan]][Full], Clan[strval(name)][Full]);
					SendMessageFormatToAll(-1, "{ffcc99}>> %s wants to start a war with %s", Clan[Player[playerid][pClan]][Full], Clan[strval(name)][Full]);
                    foreach(Player, i)
	  				{
		                if(Player[i][pClan] == strval(name) && Player[i][pClanRank] >= 6)
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s wants to make a war with you, use /gang war %d", Clan[Player[playerid][pClan]][Full], Player[playerid][pClan]);
		                }
		            }
				 	return 1;
				}
				return 1;
			}
			return 1;
	    }
 	    if(strfind(command, "mot") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) mot");
		        }
			}
			if(Player[playerid][pClan] >= 1)
			{
				if(strlen(name) <= 0 || strlen(name) >= 1 && Player[playerid][pClanRank] < Clan[Player[playerid][pClan]][g_RankToMotd])
				{
				    SendClientMessageFormat(playerid, -1, "{C659B6}>> Gang mot: %s", Clan[Player[playerid][pClan]][g_Motd]);
	       			return 1;
				}
		        if(Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToMotd])
				{
			        if(strlen(name) > 128)
			        {
			            SendClientMessage(playerid, -1, "/gang mot (mot)");
			            return 1;
					}
					new fnm[128];
					strins(fnm, name, 0);
					if(strlen(amount) >= 1)
					{
						strins(fnm, " ", strlen(name));
						strins(fnm, amount, strlen(name)+1);
					}
					strmid(Clan[Player[playerid][pClan]][g_Motd], fnm, 0, 128, 129);
					foreach(Player, i)
	  				{
		                if(Player[i][pClan] == Player[playerid][pClan])
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s has changed the motd, /gang mot", Player[playerid][UserName]);
		                }
		            }
		            
		            if(Map[m_GangControll] == Player[playerid][pClan]) {
		            	new flag_str[356], gang_id = Map[m_GangControll];
						format(flag_str, sizeof(flag_str), "{FFF000}Controlled by{FFFFFF} %s (%s){FFF000}\n\n%s\n{FFFFFF}(/gang join %d)", Clan[gang_id][Full], Clan[gang_id][Short], Clan[gang_id][g_Motd], gang_id);
                        Update3DTextLabelText(Map[flagText], -1, flag_str);
					}
		            
		            #if debug_mode == 0
		            new __action[200], y, m, d, h, minutes, s;
					TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has changed the motd (%s)\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName], Clan[Player[playerid][pClan]][g_Motd]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
					
		            return 1;
				}
			}
	    }
 	
        if(strfind(command, "rules") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) rules");
		        }
			}
			if(Player[playerid][pClan] >= 1)
			{
				if(strlen(name) <= 0 || strlen(name) >= 1 && Player[playerid][pClanRank] < Clan[Player[playerid][pClan]][g_RankToChangeRules])
				{
				    SendClientMessageFormat(playerid, -1, "{C659B6}>> Gang rules: %s", Clan[Player[playerid][pClan]][g_Rules]);
	       			return 1;
				}
		        if(Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToChangeRules])
				{
			        if(strlen(name) > 128)
			        {
			            SendClientMessage(playerid, -1, "/gang rules (rules)");
			            return 1;
					}
					new fnm[128];
					strins(fnm, name, 0);
					if(strlen(amount) >= 1)
					{
						strins(fnm, " ", strlen(name));
						strins(fnm, amount, strlen(name)+1);
					}
					strmid(Clan[Player[playerid][pClan]][g_Rules], fnm, 0, 128, 129);
					/*printf("%s", name);
					printf("%s", amount);
					printf("%s", fnm);*/
					foreach(Player, i)
	  				{
		                if(Player[i][pClan] == Player[playerid][pClan])
		                {
		                    SendClientMessageFormat(i, -1, "{C659B6}>> %s has changed the rules, /gang rules", Player[playerid][UserName]);
		                }
		            }
		            
		            #if debug_mode == 0
		            new __action[200], y, m, d, h, minutes, s;
					TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has changed the rules (%s)\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName], Clan[Player[playerid][pClan]][g_Rules]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
					
		            return 1;
				}
			}
	    }

	    if(strfind(command, "destroy") == 0)
	    {
	        if(Player[playerid][pAccountID] == 1 || GetUnlockedSlot(Player[playerid][pSettings], 25) == 1)
	        {
		        foreach(Player, i)
			    {
			        if(Player[i][CanCheckCMD])
					{
			            SendClientMessage(i, -1, "{FFA500}>> parameter(s) destroy");
			        }
				}
		  		if(strlen(name) <= 0 || strval(name) == 0 || !Clan[strval(name)][__isActive])
		        {
		            SendClientMessage(playerid, -1, "/gang destroy (id)");
		            return 1;
		        }
		        new query[128];
		        mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan` = '0',`ClanRank` = '0' WHERE `Clan` = '%d' AND `build`='"SERVER_BUILD"'", strval(name));
		 		mysql_tquery(Base, query, "", "", "");
		 		mysql_format(Base, query, sizeof(query), "DELETE FROM `gangs` WHERE `ID` = '%d'", Clan[strval(name)][__RealID]);
		 		mysql_tquery(Base, query, "", "", "");
				
		 		foreach(Player, i)
			 	{
				 	if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][169], Player[playerid][RealName], strval(name));
                    SendClientMessageFormat(i, -1, "{FFF000}>> Gang %s(%d) has been deleted, it's all over %s!", Clan[strval(name)][Full], strval(name), Clan[strval(name)][Owner]);

					if(Player[i][pClan] == strval(name))
					{
					    Player[i][pClan] = 0;
					    Player[i][pClanRank] = 0;
					}
				}
                Clan[strval(name)][__isActive] = false;
                strmid(Clan[strval(name)][Owner], "", 0, 1, 1);
                if(Player[playerid][pAdmin] <= 5)
				{
					#if debug_mode == 0
			        new __action[128];
					DiscordChannel = DCC_FindChannelById("623193667628433438");
					format(__action, sizeof __action, "```\n%s used /gang destroy on gang #%d\n```",  Player[playerid][RealName], strval(name));
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
				}
				return 1;
			}
		}
				
	    if(strfind(command, "create") == 0)
	    {
	        if(Player[playerid][pAccountID] == 1 || GetUnlockedSlot(Player[playerid][pSettings], 25) == 1)
	        {
		        foreach(Player, i)
			    {
			        if(Player[i][CanCheckCMD])
					{
			            SendClientMessage(i, -1, "{FFA500}>> parameter(s) create");
			        }
				}

                if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang create (leader id) (tag)");
		            return 1;
		        }
		        
	         	if(!IsPlayerConnected(strval(name)))
				{
					SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
					return 1;
				}

				new kid;
				for( kid = 1; kid <= sizeof(Clan); kid++ )
				{
				    if(!Clan[kid][__isActive])
					{
				        break;
				    }
				}
		        if(kid >= sizeof(Clan))
		        {
		            SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][130]);
		            return 1;
		        }

	         	if(Player[strval(name)][pClan] <= 0)
		        {
					if(strlen(amount) > 0 && strlen(amount) < 5)
					{
			        	new query[300], Ranks[] = "Peon,Policeman,Scout,Agent,Senior Agent, Director";
						mysql_format(Base, query, sizeof(query), "INSERT INTO `gangs` (`Short`,`Full`,`EXP`,`Ranks`,`Wins`,`Loses`,`Owner`,`build`,`igID`) VALUES ('%e','%e',0,'%e',0,0,'%e','"SERVER_BUILD"','%d')", amount, amount, Ranks, Player[strval(name)][UserName], kid);
					 	mysql_tquery(Base, query, "CreateAGang", "iiis", playerid, kid, strval(name), amount);
						return 1;
					}
					else
					{
					    SendClientMessage(playerid, -1, "/gang create (leader id) (tag)");
					}
				}
				else SendClientMessage(playerid, -1, "The player is already in a gang");
		    }
		    else
		    {
		        SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][168], FORUM);
		    }
		}
		
		if(strfind(command, "gpolicy") == 0)
	    {
	        if(Player[playerid][pAccountID] == 1 || GetUnlockedSlot(Player[playerid][pSettings], 25) == 1)
	        {
		        foreach(Player, i)
			    {
			        if(Player[i][CanCheckCMD])
					{
			            SendClientMessage(i, -1, "{FFA500}>> parameter(s) setleader");
			        }
				}
		        if(strlen(name) <= 0 || (!Clan[strval(name)][__isActive] && strval(name) != 0))
		        {
		            SendClientMessage(playerid, -1, "/gang gpolicy (min. co-leader rank) (min. leader rank)");
		            return 1;
		        }
		        new co_leval = strval(name),
					leval = strval(amount);
						
				if(co_leval < 0 || co_leval >= sizeof(rank_names) || leval < 0 || leval >= sizeof(rank_names)) {
				    SendClientMessage(playerid, -1, "/gang gpolicy (min. co-leader rank) (min. leader rank)");
				    return 1;
				}
	            
	            SendMessageFormatToAll(-1, "{FF5733}>> Gang Manager %s has set new policy for the gangs!", Player[playerid][UserName]);
                SendMessageFormatToAll(-1, "{FF5733}>> Min. Co-Leader rank is %d and Min. Leader rank is %d!", co_leval, leval);
                GlobalGsPolicy[0] = co_leval;
				GlobalGsPolicy[1] = leval;
			}
			return 1;
		}
		
		if(strfind(command, "setfounder") == 0)
	    {
	        if(Player[playerid][pAccountID] == 1 || GetUnlockedSlot(Player[playerid][pSettings], 25) == 1)
	        {
		        foreach(Player, i)
			    {
			        if(Player[i][CanCheckCMD])
					{
			            SendClientMessage(i, -1, "{FFA500}>> parameter(s) setleader");
			        }
				}
		        if(strlen(name) <= 0 || (!Clan[strval(name)][__isActive] && strval(name) != 0))
		        {
		            SendClientMessage(playerid, -1, "/gang setfounder (gang id) (id)");
		        }
		        else
		        {
		            if(strlen(amount) > 0)
					{
					    if(!IsPlayerConnected(strval(amount)))
						{
							SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
							return 1;
						}
						if(strval(name) > 0)
						{
		            		Player[strval(amount)][pClan] = strval(name);
							Player[strval(amount)][pClanRank] = 6;
							Clan[strval(name)][g_OwnerID] = Player[strval(amount)][pAccountID];
							Clan[strval(name)][g_FoundedDate] = gettime();
							Player[strval(amount)][pClanRank] = 6;
							SendMessageFormatToAll(-1, "{FF5733}>> %s has been set as a founder of %s (%s)!", Player[strval(amount)][UserName], Clan[strval(name)][Full], Clan[strval(name)][Short]);
						}
						else
						{
						    Player[strval(amount)][pClan] = 0;
							Player[strval(amount)][pClanRank] = 0;
						}
			            if(Player[playerid][pAdmin] <= 5)
						{
						    #if debug_mode == 0
					        new __action[128];
							DiscordChannel = DCC_FindChannelById("623193667628433438");
							format(__action, sizeof __action, "```\n%s used /gang setfounder on player %s\n```", Player[playerid][RealName], Player[strval(amount)][UserName]);
							DCC_SendChannelMessageEx(DiscordChannel, __action);
							#endif
						}
						return 1;
					}
					else
					{
					    SendClientMessage(playerid, -1, "/gang setfounder (gang id) (id)");
					    return 1;
					}
		        }
			}
			else
			{
			    SendClientMessage(playerid, -1, "{FFF000}>> A gang can have only 1 founder, if you want to add one more, report it on the forum.");
			}
		 	return 1;
	    }
		
		if(strfind(command, "setleader") == 0)
	    {
	        if(Player[playerid][pAccountID] == 1 || GetUnlockedSlot(Player[playerid][pSettings], 25) == 1)
	        {
		        foreach(Player, i)
			    {
			        if(Player[i][CanCheckCMD])
					{
			            SendClientMessage(i, -1, "{FFA500}>> parameter(s) setleader");
			        }
				}
		        if(strlen(name) <= 0 || (!Clan[strval(name)][__isActive] && strval(name) != 0))
		        {
		            SendClientMessage(playerid, -1, "/gang setleader (gang id) (id)");
		        }
		        else
		        {
		            if(strlen(amount) > 0)
					{
					    if(!IsPlayerConnected(strval(amount)))
						{
							SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
							return 1;
						}
						
						if(Player[strval(amount)][pRank] < GlobalGsPolicy[1]) {
						    SendClientMessageFormat(playerid, -1, "{FF5733}>> According to the global gang policy, that was set by a gang manager, min leader rank is %d!", GlobalGsPolicy[1]);
						    return 1;
						}
						
						if(strval(name) > 0)
						{
		            		Player[strval(amount)][pClan] = strval(name);
							Player[strval(amount)][pClanRank] = 6;
							SendMessageFormatToAll(-1, "{FF5733}>> %s has been set as a leader of %s (%s)!", Player[strval(amount)][UserName], Clan[strval(name)][Full], Clan[strval(name)][Short]);
						}
						else
						{
						    Player[strval(amount)][pClan] = 0;
							Player[strval(amount)][pClanRank] = 0;
						}
			            if(Player[playerid][pAdmin] <= 5)
						{
						    #if debug_mode == 0
					        new __action[128];
							DiscordChannel = DCC_FindChannelById("623193667628433438");
							format(__action, sizeof __action, "```\n%s used /gang setleader on player %s\n```", Player[playerid][RealName], Player[strval(amount)][UserName]);
							DCC_SendChannelMessageEx(DiscordChannel, __action);
							#endif
						}
						return 1;
					}
					else
					{
					    SendClientMessage(playerid, -1, "/gang setleader (gang id) (id)");
					    return 1;
					}
		        }
			}
			return 1;
	    }
		
	    if(strfind(command, "info") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) info");
		        }
			}
	        if(strlen(name) <= 0 || strval(name) == 0 || !Clan[strval(name)][__isActive])
	        {
	            SendClientMessage(playerid, -1, "/gang info (id)");
	            return 1;
	        }
	        else
	        {
	            SendClientMessageFormat(playerid, -1, "{B2F558}+---------- %s (%d EXP){B2F558} ----------+", Clan[strval(name)][Full], Clan[strval(name)][EXP]);
                for( new i = 0; i < sizeof(Clan); i++ )
				{
					if(Clan[strval(name)][g_AllianceWith][i] >= 2 && Clan[strval(name)][g_EnemysWith][i] >= 0 && strlen(Clan[i][Full]) >= 1) SendClientMessageFormat(playerid, -1, "{B2F558}>> Alliance with %s", Clan[i][Full]);
                    if(Clan[strval(name)][g_EnemysWith][i] <= -2 && Clan[strval(name)][g_AllianceWith][i] <= 1 && strlen(Clan[i][Full]) >= 1) SendClientMessageFormat(playerid, -1, "{ff4d4d}>> War with %s", Clan[i][Full]);
				}
                
				foreach(Player, i)
	            {
             		if(Player[i][pClan] == strval(name) && FakeData[i][7] <= 0)
	                {
	                    SendClientMessageFormat(playerid, -1, "(Rank %d) >> %s (ID %d)", Player[i][pClanRank], Player[i][UserName], i);
	                }
	            }
	            return 1;
   			}
   			return 1;
	    }
	   
	    if(strfind(command, "tag") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) tag");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToEdit])
			{
		        if(strlen(name) <= 0 || strlen(name) > 4)
		        {
		            SendClientMessage(playerid, -1, "/gang tag (name)");
		            return 1;
				}
	            foreach(Player, i)
	            {
	                if(Player[i][pClan] == Player[playerid][pClan])
	                {
	                    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][140], Player[playerid][UserName], name);
	                }
				}
				strmid(Clan[Player[playerid][pClan]][Short], name, 0, 5, 6);
				
				#if debug_mode == 0
				new __action[200], y, m, d, h, minutes, s;
				TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
				DiscordChannel = DCC_FindChannelById("662009624110694440");
				format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has changed gang tag to %s\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName], name);
				DCC_SendChannelMessageEx(DiscordChannel, __action);
				#endif
				return 1;
			}
			return 1;
	    }
	    
	    if(strfind(command, "name") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) name");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToEdit])
			{
		        if(strlen(name) <= 0 || strlen(name) > 32)
		        {
		            SendClientMessage(playerid, -1, "/gang name (name)");
		            return 1;
				}

				new fnm[64];
				strins(fnm, name, 0);
				if(strlen(amount) >= 1)
				{
					strins(fnm, " ", strlen(name));
					strins(fnm, amount, strlen(name)+1);
				}
				foreach(Player, i)
				{
	                if(Player[i][pClan] == Player[playerid][pClan])
	                {
	                    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][141], Player[playerid][UserName], fnm);
	                }
				}
				strmid(Clan[Player[playerid][pClan]][Full], fnm, 0, 64, 65);
				
				#if debug_mode == 0
				new __action[200], y, m, d, h, minutes, s;
				TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
				DiscordChannel = DCC_FindChannelById("662009624110694440");
				format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has changed gang name to %s\n```", d, m, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName], fnm);
				DCC_SendChannelMessageEx(DiscordChannel, __action);
				#endif
				return 1;
			}
	    }
	    
	    if(strfind(command, "deposit") == 0)
	    {
	        if(IsUsingProxy{playerid})
			{
			    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
				return 1;
			}
			if(!CanPay) return 0;
            foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) deposit");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= 1)
			{
		        if(strlen(name) <= 0 || strval(name) < 100)
		        {
		            SendClientMessage(playerid, -1, "/gang deposit (amount)");
		            return 1;
				}
                if(Player[playerid][pXP] >= strval(name))
                {
                    if(Player[playerid][pXP] < 15000)
				    {
				        SendClientMessage(playerid, -1,"For security and YouTubers support, you must have atleast 15k experience to use this command!");
		        		return 1;
				    }
                    
	                Clan[Player[playerid][pClan]][EXP] += (strval(name)-floor(strval(name) * TAXES));
	                Player[playerid][pXP] -= strval(name);
		            foreach(Player, i)
		            {
		                if(Player[i][pClan] == Player[playerid][pClan])
		                {
		                    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][139], Player[playerid][UserName], strval(name), (strval(name)-floor(strval(name) * TAXES)));
		                }
		            }
		            new y, m, d, h, i, s, query[256], str[24], ip[16];
        			format(str, sizeof(str), "gang #%d", Player[playerid][pClan]);
				  	TimestampToDate(gettime(), y, m, d, h, i, s, 3);
                    GetPlayerIp(playerid, ip, 16);
					mysql_format(Base, query, sizeof(query), "INSERT INTO `payments` (`from`,`whom`,`amount`,`type`,`date`,`id`,`ip`) VALUES ('%e','%e','%d','%d','%d','%d','%e')", Player[playerid][UserName], str, strval(name), 1, gettime(), Player[playerid][pAccountID], ip);
				 	mysql_tquery(Base, query, "", "", "");
                    #if debug_mode == 0
					DiscordChannel = DCC_FindChannelById("622114307131572225");
					format(query, sizeof query, "```\n%s has deposited %d EXP to gang #%d [Date: %02d/%02d/%04d | Time: %02d:%02d]\n```", Player[playerid][UserName], strval(name), Player[playerid][pClan], d, m, y, h, i);
					DCC_SendChannelMessageEx(DiscordChannel, query);
					#endif
				}
				return 1;
			}
		}
	    
	    if(strfind(command, "pay") == 0)
	    {
	        if(IsUsingProxy{playerid})
			{
			    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][194]);
				return 1;
			}
			if(!CanPay) return 0;
            foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) pay");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankGivePayDay])
			{
		        if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang pay (id) (amount)");
		            return 1;
		        }
		        if(strlen(amount) <= 0 || strval(amount) < 100)
		        {
		            SendClientMessage(playerid, -1, "/gang pay (id) (amount)");
		            return 1;
		        }
		        else if(strlen(amount) > Clan[Player[playerid][pClan]][g_MaxPayAmt])
		        {
		            SendClientMessageFormat(playerid, -1, "{FFF000}>> Withdrawal limit: %d EXP", Clan[Player[playerid][pClan]][g_MaxPayAmt]);
		            return 1;
		        }
		        else
		        {
		            if(!IsPlayerConnected(strval(name)))
					{
						SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
						return 1;
					}
	                if(Clan[Player[playerid][pClan]][EXP] < strval(amount))
	                {
	                    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][131]);
	                    return 1;
	                }
	                if(Player[strval(name)][pClan] != Player[playerid][pClan])
	                {
	                    SendClientMessage(playerid, -1, "/gang pay (id) (amount)");
		            	return 1;
	                }
	                
	                if(Player[strval(name)][pXP] < 15000)
				    {
				        SendClientMessage(playerid, -1,"For security and YouTubers support, he/she must have atleast 15k experience to be paid!");
		        		return 1;
				    }

	                Clan[Player[playerid][pClan]][EXP] -= strval(amount);
	                Player[strval(name)][pXP] += (strval(amount) - floor(strval(amount) * TAXES));

	                GameTextForPlayer(strval(name), "~y~YOU ~g~GOT ~r~XP", 2000, 5);

		            foreach(Player, i)
		            {
		                if(Player[i][pClan] == Player[playerid][pClan] || (Player[i][pAdmin] > 0 && Player[i][pLogged] && i != playerid))
		                {
		                    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][132], Player[playerid][UserName], Player[strval(name)][UserName], strval(amount), (strval(amount) - floor(strval(amount) * TAXES)));
		                }
					}

					new y, m, d, h, i, s, query[256], ip[16];
				  	TimestampToDate(gettime(), y, m, d, h, i, s, 3);
					GetPlayerIp(playerid, ip, 16);
					mysql_format(Base, query, sizeof(query), "INSERT INTO `payments` (`from`,`whom`,`amount`,`type`,`date`,`id`,`ip`) VALUES ('%e','%e','%d','%d','%d','%d','%e')", Player[playerid][UserName], Player[strval(name)][UserName], strval(amount), 2, gettime(), Player[playerid][pAccountID], ip);
				 	mysql_tquery(Base, query, "", "", "");
                    #if debug_mode == 0
					DiscordChannel = DCC_FindChannelById("622114307131572225");
					format(query, sizeof query, "```\n%04d-%02d-%02d %02d:%02d %s has paid %d EXP to %s (/gang pay #%d)\n```", y, m, d, h, i, Player[playerid][UserName], strval(amount), Player[strval(name)][UserName], Player[playerid][pClan]);
					DCC_SendChannelMessageEx(DiscordChannel, query);
					#endif
                    return 1;
		        }
			}
		}
		
	    if(strfind(command, "members") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) members");
		        }
			}
	        if(strlen(name) <= 0 || strval(name) == 0 || !Clan[strval(name)][__isActive])
	        {
	            SendClientMessage(playerid, -1, "/gang members (id)");
	            return 1;
	        }
	        if(strval(name) == Player[playerid][pClan] && (Player[playerid][pClanRank] >= 6 || Player[playerid][pAccountID] == Clan[Player[playerid][pClan]][g_OwnerID]))
	        {
				new query[164];
			    mysql_format(Base, query, sizeof(query), "SELECT `Name`,`ID`,`ClanRank`,`lalog` FROM `users` WHERE `Clan` = '%d' AND `build`='"SERVER_BUILD"' ORDER BY `ClanRank` DESC", strval(name));
				mysql_tquery(Base, query, "LoadMembers", "ii", playerid, strval(name));
    		}
	        else
	        {
		        new query[128];
				mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Clan` = '%d' AND `build`='"SERVER_BUILD"'", strval(name));
			 	mysql_tquery(Base, query, "ShowGangActivity", "i", playerid);
			 	return 1;
			}
	    }
	    
	    if(strfind(command, "list") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) list");
		        }
			}

   			new qu[128];
		    mysql_format(Base, qu, sizeof(qu), "SELECT count(`controlled`), `controlled` FROM `maps` GROUP BY `controlled` ORDER BY count(`controlled`) DESC");
			mysql_tquery(Base, qu, "GetTopGangs", "i", playerid);
	        return 1;
	    }
	    
	    if(strfind(command, "join") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) join");
		        }
			}
	        if(Player[playerid][pClan] >= 1)
	        {
	            SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][122]);
	            return 1;
		 	}
		 	if(Player[playerid][pInGangMatch]) return 1;
		 	
	        if(strlen(name) <= 0 || strval(name) == 0 || !Clan[strval(name)][__isActive])
	        {
	            SendClientMessage(playerid, -1, "/gang join (id)");
	            return 1;
	        }
	        else
	        {
	            if(Clan[strval(name)][g_OwnerID] <= 0) {
	                SendClientMessage(playerid, -1, "{FFF000}>> This gang hasn't a founder");
	                return 1;
	            }
	            
	            if(Player[playerid][pAccountID] == Clan[strval(name)][g_OwnerID]) {
	                Player[playerid][pClan] = strval(name);
	                Player[playerid][pClanRank] = 6;
                    SendClientMessage(playerid, -1, "{FFF000}>> Founders can join without app, Welcome Back!");
                    if(canBeGangTaged(playerid)) AttachGangName(playerid);
	                return 1;
	            }
	            
	            if(GetUnlockedSlot(Player[playerid][GangBanned], strval(name)) >= 1)
	            {
             		SendClientMessage(playerid, -1, "{FFF000}>> You are blacklisted in this gang!");
               		return 1;
	            }
	            
	            if(Clan[strval(name)][g_isClosed]) {
	                SendClientMessage(playerid, -1, "{FFF000}>> This gang is not accepting applications at the moment");
               		return 1;
	            }
		            
                if(Clan[strval(name)][g_MaxMembers] >= 50)
	            {
	                SendClientMessage(playerid, -1, "{FFF000}>> The number of gang members has exceeded the limit!");
	                return 1;
	            }

				if(Player[playerid][pRank] < Clan[strval(name)][g_MinExp]) {
				    SendClientMessageFormat(playerid, -1, "{FFF000}>> You can't join this gang, you need rank %d!", Clan[strval(name)][g_MinExp]);
				    return 1;
				}

    			Player[playerid][GangRequest] = strval(name);
    			
    			foreach(Player, i)
    			{
	    			if(Player[i][pClan] == strval(name) && Player[i][pClanRank] >= 4)
	       			{
           				SendClientMessageFormat(i, -1, "{0099ff}------------------ %s's gang app {0099ff} ------------------", Player[playerid][UserName]);
          				SendClientMessageFormat(i, -1, "{0099ff}Use{FFF000} /gang accept %d{0099ff} to accept the player", playerid);
				   }
				}
	            return 1;
	        }
	    }

     	if(strfind(command, "chat") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) chat");
		        }
			}
			if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= 1)
			{
                if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang chat (message)");
		            return 1;
		        }
		        else
		        {
		            new fnm[128], rank[32], str[128];
					strins(fnm, name, 0);
					if(strlen(amount) >= 1)
					{
						strins(fnm, " ", strlen(name));
						strins(fnm, amount, strlen(name)+1);
					}
					switch(Player[playerid][pClanRank])
					{
						case 1: strmid(rank, Clan[Player[playerid][pClan]][Rank_0], 0, 32, 33);
						case 2: strmid(rank, Clan[Player[playerid][pClan]][Rank_1], 0, 32, 33);
						case 3: strmid(rank, Clan[Player[playerid][pClan]][Rank_2], 0, 32, 33);
						case 4: strmid(rank, Clan[Player[playerid][pClan]][Rank_3], 0, 32, 33);
						case 5: strmid(rank, Clan[Player[playerid][pClan]][Rank_4], 0, 32, 33);
						case 6: strmid(rank, Clan[Player[playerid][pClan]][Rank_5], 0, 32, 33);
					}
				    format(str, 128, "{C659B6}[%s] %s(%d): %s", rank, Player[playerid][UserName], playerid, fnm);
					SendGangMessage(playerid, str);
					
					#if debug_mode == 0
					new __action[200], y, ms, d, h, minutes, s;
					TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s: %s\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName], fnm);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
					
					return 1;
		        }
			}
		}
	    
	    if(strfind(command, "promote") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) promote");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToPromote])
			{
		        if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang promote (id)");
		            return 1;
		        }
		        else
		        {
		            if(!IsPlayerConnected(strval(name)))
					{
						SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
						return 1;
					}
					if(Player[strval(name)][pClan] != Player[playerid][pClan])
					{
					    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][134]);
					    return 1;
					}
					
					if(Player[strval(name)][pClanRank] < Player[playerid][pClanRank] && Player[strval(name)][pClanRank] <= 5)
					{
					    if(Player[strval(name)][pClanRank] + 1 >= 6) {
					        if(Player[strval(name)][pRank] < GlobalGsPolicy[1]) {
                                SendClientMessageFormat(playerid, -1, "{FF5733}>> According to the global gang policy, that was set by a gang manager, min leader rank is %d!", GlobalGsPolicy[1]);
						    	return 1;
					        }
					    }
					    if(Player[strval(name)][pClanRank] + 1 == 5) {
					        if(Player[strval(name)][pRank] < GlobalGsPolicy[0]) {
                                SendClientMessageFormat(playerid, -1, "{FF5733}>> According to the global gang policy, that was set by a gang manager, min co-leader rank is %d!", GlobalGsPolicy[0]);
						    	return 1;
					        }
					    }
					    
					    Player[strval(name)][pClanRank]++;
					    foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][133], Player[strval(name)][UserName], Player[playerid][UserName], Player[strval(name)][pClanRank]);
					}
		            new query[128];
					mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='%d',`ClanRank`='%d' WHERE `ID` = '%d'", Player[strval(name)][pClan], Player[strval(name)][pClanRank], Player[strval(name)][pAccountID]);
					mysql_tquery(Base, query, "", "", "");
		            
		            #if debug_mode == 0
		            new __action[200], y, ms, d, h, minutes, s;
					TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been promoted to rank %d by %s\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[strval(name)][pClanRank], Player[playerid][UserName]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
					
		            return 1;
				}
			}
		}
		
		if(strfind(command, "demote") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) demote");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToPromote])
			{
		        if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang demote (id)");
		            return 1;
		        }
		        else
		        {
		            if(!IsPlayerConnected(strval(name)))
					{
						SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
						return 1;
					}
					if(Player[strval(name)][pClan] != Player[playerid][pClan])
					{
					    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][134]);
					    return 1;
					}
					
					if(Player[strval(name)][pClanRank] >= Player[playerid][pClanRank])// && Clan[Player[playerid][pClan]][g_OwnerID] != Player[playerid][pAccountID])
					{
					    if(strval(name) != playerid && Player[strval(name)][pAccountID] != Clan[Player[strval(name)][pClan]][g_OwnerID])
					    {
						    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][135]);
						    return 1;
						}
						else
						{
						    if(Player[strval(name)][pAccountID] == Clan[Player[strval(name)][pClan]][g_OwnerID])
						    {
						        SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][135]);
						    	return 1;
						    }
						}
					}
					
					new y, ms, d, h, minutes, s;
					if(Player[strval(name)][pClanRank] >= 1)
					{
					    Player[strval(name)][pClanRank]--;
					    
					    new query[128];
						mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='%d',`ClanRank`='%d' WHERE `ID` = '%d'", Player[strval(name)][pClan], Player[strval(name)][pClanRank], Player[strval(name)][pAccountID]);
						mysql_tquery(Base, query, "", "", "");
					    
						TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
      					#if debug_mode == 0
      					new  __action[200];
						DiscordChannel = DCC_FindChannelById("662009624110694440");
						format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been demoted to rank %d by %s\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[strval(name)][pClanRank], Player[playerid][UserName]);
						DCC_SendChannelMessageEx(DiscordChannel, __action);
					    #endif
					    
					    foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][136], Player[strval(name)][UserName], Player[playerid][UserName], Player[strval(name)][pClanRank]);
						if(Player[strval(name)][pClanRank] <= 0)
						{
						    foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][137], Player[strval(name)][UserName], Player[playerid][UserName]);
                            Clan[Player[playerid][pClan]][g_MaxMembers]--;
							Player[strval(name)][pClan] = 0;
							
							#if debug_mode == 0
							TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
							DiscordChannel = DCC_FindChannelById("662009624110694440");
							format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been fired by %s (demoted)\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName]);
							DCC_SendChannelMessageEx(DiscordChannel, __action);
							#endif
							
							mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='0',`ClanRank`='0' WHERE `ID` = '%d'", Player[strval(name)][pAccountID]);
							mysql_tquery(Base, query, "", "", "");
							
						}
					}
					return 1;
				}
			}
		}
	    
	    if(strfind(command, "rank") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) rank");
		        }
			}
	        if(strlen(name) <= 0 || strval(name) <= 0 || strval(name) > 6)
	        {
	            SendClientMessage(playerid, -1, "/gang rank (1-6) (name)");
	            return 1;
	        }
	        if(strlen(amount) <= 0 || strlen(amount) > 32)
	        {
	            SendClientMessage(playerid, -1, "/gang rank (1-6) (name)");
	            return 1;
	        }
	        else
	        {
	            if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToEdit])
	            {
				 	switch(strval(name))
					{
						case 1: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_0], amount); strmid(Clan[Player[playerid][pClan]][Rank_0], amount, 0, 32, 33); }
						case 2: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_1], amount); strmid(Clan[Player[playerid][pClan]][Rank_1], amount, 0, 32, 33); }
						case 3: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_2], amount); strmid(Clan[Player[playerid][pClan]][Rank_2], amount, 0, 32, 33); }
						case 4: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_3], amount); strmid(Clan[Player[playerid][pClan]][Rank_3], amount, 0, 32, 33); }
						case 5: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_4], amount); strmid(Clan[Player[playerid][pClan]][Rank_4], amount, 0, 32, 33); }
						case 6: foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) { SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][138], Player[playerid][UserName], Clan[Player[playerid][pClan]][Rank_5], amount); strmid(Clan[Player[playerid][pClan]][Rank_5], amount, 0, 32, 33); }
					}
				}
				return 1;
	        }
		}
	    
	    if(strfind(command, "accept") == 0)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) accept");
		        }
			}
	        if(Player[playerid][pClan] >= 1 && Player[playerid][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToAccept])
			{
		        if(strlen(name) <= 0)
		        {
		            SendClientMessage(playerid, -1, "/gang accept (id)");
		            return 1;
		        }
		        else
		        {
		            if(!IsPlayerConnected(strval(name)))
					{
						SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
						return 1;
					}
					if(Player[strval(name)][GangRequest] != Player[playerid][pClan])
					{
					    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][127]);
					    return 1;
					}
					if(Player[strval(name)][pClan] > 0)
					{
					    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][128]);
					    return 1;
					}
					Player[strval(name)][pClan] = Player[playerid][pClan];
					Player[strval(name)][pClanRank] = 1;
					Player[playerid][pClanWarns] = 0;
					Player[strval(name)][pLastGangJoin] = (gettime() + (86400*8));
					
					Clan[Player[playerid][pClan]][g_MaxMembers]++;
					if(canBeGangTaged(strval(name))) AttachGangName(strval(name));
					
					new query[400];
					mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='%d',`ClanRank`='%d' WHERE `ID` = '%d'", Player[strval(name)][pClan], Player[strval(name)][pClanRank], Player[strval(name)][pAccountID]);
					mysql_tquery(Base, query, "", "", "");
					
					mysql_format(Base, query, sizeof(query), "DELETE FROM `applications` WHERE `ID` = '%d'", Player[strval(name)][pAccountID]);
					mysql_tquery(Base, query);
					
					foreach(Player, i)
		            {
		                if(Player[i][pClan] == Player[playerid][pClan] && Player[i][pClanRank] >= Clan[Player[playerid][pClan]][g_RankToAccept])
		                {
		                    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][129], Player[strval(name)][UserName], Player[playerid][UserName]);
		                }
		            }
		            Player[strval(name)][GangRequest] = 0;
		            #if debug_mode == 0
		            new __action[200], y, ms, d, h, minutes, s;
					TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009624110694440");
					format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has been accepted in gang by %s\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[strval(name)][UserName], Player[playerid][UserName]);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
					
		            return 1;
		        }
			}
	    }
	    if(strfind(command, "leave") == 0 && Player[playerid][pClan] >= 1)
	    {
	        foreach(Player, i)
		    {
		        if(Player[i][CanCheckCMD])
				{
		            SendClientMessage(i, -1, "{FFA500}>> parameter(s) leave");
		        }
			}
	        if(Player[playerid][pClanRank] >= 6)
	        {
	            SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][123]);
	            return 1;
	        }
	        AttachGangName(playerid);
	        
	        #if debug_mode == 0
	        new __action[200], y, ms, d, h, minutes, s;
			TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
			DiscordChannel = DCC_FindChannelById("662009624110694440");
			format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d | (GANG ID %d) %s has left the gang\n```", d, ms, y, h, minutes, Player[playerid][pClan], Player[playerid][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
			
			new query[400];
			mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='0',`ClanRank`='0' WHERE `ID` = '%d'", Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
			
			mysql_format(Base, query, sizeof(query), "DELETE FROM `applications` WHERE `ID` = '%d'", Player[playerid][pAccountID]);
			mysql_tquery(Base, query);
			
	        Clan[Player[playerid][pClan]][g_MaxMembers]--;
	        Player[playerid][pClan] = 0;
	        Player[playerid][pClanRank] = 0;
	        SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][124]);

            if(GangName[playerid]>Text3D:-1) {
   				Delete3DTextLabel(GangName[playerid]);
	   			GangName[playerid]=Text3D:-1;
			}

            if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) setHumanColor(playerid);
	        return 1;
	    }
	}
	return 1;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
    if(restartTimes >= 1 && restartTimes <= 30) return 0;
    if(!Player[playerid][pLogged]) return 0;
    if(!SelectReward[playerid]) return 0;
	return 0;
}

public OnPlayerCommandReceived(playerid, cmdtext[])
{
    if(restartTimes >= 1 && restartTimes <= 30)
    {
        return 0;
    }
    
    if(strfind(cmdtext, "/verify", true) != -1 || strfind(cmdtext, "/email", true) != -1)
    {
		return 1;
    }
	
    if(!Player[playerid][pLogged]) return 0;
    
    if(GetPVarInt(playerid,"cmdflood") > gettime())
	{
		GameTextForPlayer(playerid, "~r~Wait", 1000, 5);
		return 0;
	}
	
    if(Player[playerid][pAdmin] < 1) SetPVarInt(playerid,"cmdflood",gettime() + 2);

	if(strfind(cmdtext, "verify", true) == -1
	&& strfind(cmdtext, "sword", true) == -1
	&& strfind(cmdtext, "changepass", true) == -1
	&& strfind(cmdtext, "givezaps", true) == -1
	&& strfind(cmdtext, "changesword", true) == -1)
	{
	    new st[24];
	   	foreach(Player, i)
	    {
	        if(Player[i][CanCheckCMD])
	        {
				strmid(st, cmdtext, 0, strfind(cmdtext, " ") > -1 ? strfind(cmdtext, " ") : strlen(cmdtext), 24);
	            SendClientMessageFormat(i, -1, "{FFA500}>> [CMD CHECK]: %s(%d) uses {FFFFFF}%s", Player[playerid][UserName], playerid, st);
	        }
		}
	}
	return 1;
}

public OnPlayerCommandPerformed(playerid, cmdtext[], success)
{
    if(strlen(cmdtext) >= 2 && success != 1) {
		new a = CallRemoteFunction("OnServerRegisterCommand", "is", playerid, cmdtext);
		if(a > 0) return 1;
	}
	
	if(success != 1)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][1]);
		return 0;
	}

    if(strfind(cmdtext, "verify", true) == -1
	&& strfind(cmdtext, "sword", true) == -1
	&& strfind(cmdtext, "changepass", true) == -1
	&& strfind(cmdtext, "givezaps", true) == -1
	&& strfind(cmdtext, "changesword", true) == -1)
    {
		new query[900], serial[41];
	    gpci(playerid, serial, sizeof(serial));
	    mysql_format(Base, query, sizeof(query), "INSERT INTO `pactions` (`acc`,`type`,`date`,`text`,`sign`,`reg_sign`,`ip`) VALUES ('%d','0','%d','%e','%e', '%e', '%e')", Player[playerid][pAccountID], gettime(), cmdtext, serial, Player[playerid][pGPCI], Player[playerid][pIP]);
		mysql_tquery(Base, query, "", "", "");
	}
	
	return 1;
}

CMD:votekick(playerid,params[])
{
    if(Player[playerid][pXP] >= 5000)
	{
	    if(AdminOnline()) return SendClientMessage(playerid,-1,"/report (playerid) (reason)");
	    if(sscanf(params,"us[128]",params[0],params[1])) return SendClientMessage(playerid,-1,"/votekick [playerid] [reason]");
    	if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(votekick == true)
		{
			SendClientMessage(playerid,-1, serverLang[Player[playerid][pLang]][77]);
			return 1;
		}
		
		votekick_max_voices = floor(playerOnline / 2);
 		if(playerOnline >= 12) votekick_max_voices = floor(playerOnline / 3);
		
		foreach(Player, i) SendClientMessageFormat(i, -1,  serverLang[Player[i][pLang]][78], Player[playerid][UserName], Player[params[0]][UserName], params[1], votekick_max_voices);
	    votekick = true;
	    voites = 0;
	    kick_player[params[0]] = true;
	    already_vote[playerid] = true;
	    VoteKickTimer = SetTimer("CloseVotekick", 180000, 0);
	    return 1;
	}
	else return ShowExpError(playerid, 5000);
}

fun CloseVotekick()
{
    foreach(Player, i)
    {
        kick_player[i] = false;
      	already_vote[i] = false;
      	SendClientMessage(i, -1,  serverLang[Player[i][pLang]][76]);
    }
    votekick_max_voices = 0;
    voites = 0;
}

CMD:yes(playerid)
{
	if(!votekick) return 0;
	if(already_vote[playerid] == true)
	{
 		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][83]);
		return 1;
	}
	voites++;
	foreach(Player, i) SendClientMessageFormat(i, -1,  serverLang[Player[i][pLang]][81], Player[playerid][UserName], voites, votekick_max_voices);

 	if(voites >= votekick_max_voices)
 	{
 	    foreach(Player, i)
 	    {
            SendClientMessage(i, -1,  serverLang[Player[i][pLang]][82]);
            if(kick_player[i])
			{
			    new IP[16];
			    GetPlayerIp(i, IP, 16);
                BlockIpAddress(IP, 900000);
                PlayerKick(i);
			}
            kick_player[i] = false;
            already_vote[i] = false;
 	    }
 	    votekick_max_voices = 0;
 	    KillTimer(VoteKickTimer);
 	    votekick = false;
 	    return 1;
 	}
 	already_vote[playerid] = true;
 	return 1;
}

fun ReturnToDefaultName(playerid)
{
    if(cache_num_rows() > 0)
	{
	    new nm[MAX_PLAYER_NAME+1];
	    cache_get_value_name(0, "Name", nm);
	    //foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, -1, "{6A8EE2}[HIDE] >> %s(%d) has changed name to %s", Player[playerid][UserName], playerid, nm);
	    SetPlayerName(playerid, nm);
	    GetPlayerName(playerid, Player[playerid][UserName], 25);
		FakeData[playerid][0] = 0;
		FakeData[playerid][1] = 0;
		FakeData[playerid][2] = 0;
		FakeData[playerid][3] = 0;
		FakeData[playerid][4] = 0;
		FakeData[playerid][5] = 0;
		FakeData[playerid][6] = 0;
		FakeData[playerid][7] = 0;
		FakeData[playerid][8] = 0;
	}
	return 1;
}

fun TryToGiveFakeName(playerid, const newname[], e, k, r, v)
{
    if(cache_num_rows() > 0)
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][155]);
	}
	else
	{
	    //foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, -1, "{6A8EE2}[HIDE] >> %s(%d) has changed name to %s", Player[playerid][UserName], playerid, newname);
        SetPlayerName(playerid, newname);
        GetPlayerName(playerid, Player[playerid][UserName], 25);
        FakeData[playerid][0] = ((k <= 0) ? 1+random(19999) : k); // Kills

		FakeData[playerid][1] = 3000+random(48000); // Account ID

		if(v < 0) v = 0;
  		if(v > 3) v = 3;
  		FakeData[playerid][2] = v;
            
		if(FakeData[playerid][2] > 0) FakeData[playerid][3] = gettime() + (random(31)*86400);
		else FakeData[playerid][3] = 0;
		FakeData[playerid][4] = random(50);
		FakeData[playerid][5] = random(150);
		FakeData[playerid][6] = ((r <= 0) ? 1+random(19) : r); // Rank
		
		FakeData[playerid][7] = 1;
		FakeData[playerid][8] = ((e <= 0) ? 0+random(5000) : e); // Exp
		
   		if(Player[playerid][pAdmin] <= 5)
	    {
	        #if debug_mode == 0
    	 	new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /name [Name: %s]\n```", Player[playerid][RealName], newname);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	return 1;
}

CMD:name(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
    {
        new newname[MAX_PLAYER_NAME+1], e = 0, k = 0, r = 0, v = 0;
        sscanf(params,"s[24]iiii", newname, e, k, r, v);
        
        if(strlen(newname) <= 2 || strlen(newname) >= 20)
		{
		    if(Player[playerid][pAdmin] < 5) SendClientMessage(playerid, -1, "/name (name|off)");
		    else SendClientMessage(playerid, -1, "/name (name|off) [...exp, kills, rank, vip]");
		    
			return 1;
		}
        
        if(!strcmp(newname, "off", true))
		{
		    new query[128];
			mysql_format(Base, query, sizeof(query), "SELECT `Name` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "ReturnToDefaultName", "i", playerid);
			return 1;
        }
		
		for( new i; i < 25; i++ )
		{
		    if(newname[i] == ' ' || newname[i] == '_')
		    {
		        SendClientMessage(playerid, -1, "{FFF000}>> 'Space' and '_' are not allowed!");
				return 1;
		    }
		}

		new query[128];
	 	mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", newname);
	 	
	 	if(Player[playerid][pAdmin] < 5) mysql_tquery(Base, query, "TryToGiveFakeName", "isiiii", playerid, newname, 0, 0, 0, random(3));
		else mysql_tquery(Base, query, "TryToGiveFakeName", "isiiii", playerid, newname, e, k, r, v);
		
		return 1;
    }
    return 0;
}

CMD:unjail(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
    {
        if(sscanf(params, "i", params[0]))
        {
            SendClientMessage(playerid, -1, "/unjail (id)");
            return 1;
        }
        if(IsPlayerConnected(params[0]))
		{
		    new i = params[0];
		    Player[i][Jailed] = -1;
	    	SetSpawnInfo(i,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		    SetPlayerSpecialAction(i, SPECIAL_ACTION_NONE);
		    SetPlayerTeamEx(i, TEAM_ZOMBIE);
		    SpawnPlayer(i);
			foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged] || j == i) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s has been unjailed by %s", Player[i][UserName], Player[playerid][UserName]);
		}
        return 1;
    }
    return 0;
}

CMD:jail(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
    {
        new time, targets[15] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, reason[64] = "";
        sscanf(params, "iis[64]", targets[0], time, reason);
        sscanf(params, "iiis[64]", targets[0], targets[1], time, reason);
		sscanf(params, "iiiis[64]", targets[0], targets[1], targets[2], time, reason);
		sscanf(params, "iiiiis[64]", targets[0], targets[1], targets[2], targets[3], time, reason);
		sscanf(params, "iiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], time, reason);
		sscanf(params, "iiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], time, reason);
		sscanf(params, "iiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], time, reason);
		sscanf(params, "iiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], time, reason);
		sscanf(params, "iiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], time, reason);
		sscanf(params, "iiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], time, reason);
        sscanf(params, "iiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], time, reason);
        sscanf(params, "iiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], time, reason);
        sscanf(params, "iiiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], time, reason);
        sscanf(params, "iiiiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], targets[13], time, reason);
	    sscanf(params, "iiiiiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], targets[13], targets[14], time, reason);
		
		//SendClientMessageFormat(playerid, -1, "/jail (id...) (%d) (%s)", time, reason);
		
        if(time <= 0 || time > 5)
        {
            SendClientMessage(playerid, -1, "/jail (id...) (time) (reason)");
       		return 1;
        }
        
        if(strlen(reason) <= 0)
        {
       		SendClientMessage(playerid, -1, "/jail (id...) (time) (reason)");
       		return 1;
        }
        
        for( new j; j < sizeof(targets); j++ )
		{
			if(j <= sizeof(targets) - 1)
			{
				if(targets[j] != -1 && targets[j+1] == -1) targets[j] = -1;
			}
			else targets[sizeof(targets)-1] = -1;
		}
        
        for( new j; j < sizeof(targets); j++ )
	    {
			if(IsPlayerConnected(targets[j]) && Player[targets[j]][pLogged])
			{
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == targets[j]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[targets[j]][UserName], Player[playerid][RealName], time, MakeReasonFromShort(reason));
				SetPlayerSkinAC(targets[j], 62, 1);
				SetPlayerSpecialAction(targets[j], SPECIAL_ACTION_CUFFED);
				SetPlayerPosAC(targets[j],264.1425,77.4712,1001.0391);
    			SetPlayerFacingAngle(targets[j], 263.0160);
    			SetPlayerInterior(targets[j], 6);
    			SetPlayerColor(targets[j], 0x000000FF);
    			Player[targets[j]][Jailed] = time * 60;
    			SetPlayerTeamEx(targets[j], TEAM_ZOMBIE);
    			ResetWeapons(targets[j]);
    			SetPlayerArmourAC(targets[j], 0.0);
   				SetPlayerHealthAC(targets[j], 100.0);
   				Player[targets[j]][Accelerated] = -1;
   				if(IsPlayerAcceleratedText[targets[j]]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[targets[j]]),IsPlayerAcceleratedText[targets[j]]=Text3D:-1;
				if(Player[playerid][pAdmin] <= 5)
				{
				    #if debug_mode == 0
			        new __action[128];
					DiscordChannel = DCC_FindChannelById("623193667628433438");
					format(__action, sizeof __action, "```\n%s used /jail on player %s (Time: %d) [Reason: %s]\n```",  Player[playerid][RealName], Player[targets[j]][UserName], time, MakeReasonFromShort(reason));
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
				}
			}
		}
		return 1;
	}
	return 0;
}

CMD:unwarn(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
    {
        if(sscanf(params, "i", params[0]))
		{
		    SendClientMessage(playerid, -1, ">> /unwarn (id)");
			return 1;
		}
		
		if(IsPlayerConnected(params[0]))
		{
		    if(Player[params[0]][Warnings] > 0)
			{
				Player[params[0]][Warnings]--;
				SendClientMessage(playerid, -1, "{99ffff}>> Appealed");
		    }
		    else
		    {
		        SendClientMessage(playerid, -1, "{FF0000}>> The player does not have warns");
		    }
		}
		
        return 1;
    }
    return 0;
}

CMD:warn(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
    {
        new targets[15] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, reason[64] = "";
		sscanf(params, "is[64]", targets[0], reason);
		sscanf(params, "iis[64]", targets[0], targets[1], reason);
		sscanf(params, "iiis[64]", targets[0], targets[1], targets[2], reason);
		sscanf(params, "iiiis[64]", targets[0], targets[1], targets[2], targets[3], reason);
		sscanf(params, "iiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], reason);
		sscanf(params, "iiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], reason);
		sscanf(params, "iiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], reason);
		sscanf(params, "iiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], reason);
		sscanf(params, "iiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], reason);
		sscanf(params, "iiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], reason);
        sscanf(params, "iiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], reason);
        sscanf(params, "iiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], reason);
        sscanf(params, "iiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], reason);
        sscanf(params, "iiiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], targets[13], reason);
	    sscanf(params, "iiiiiiiiiiiiiiis[64]", targets[0], targets[1], targets[2], targets[3], targets[4], targets[5], targets[6], targets[7], targets[8], targets[9], targets[10], targets[11], targets[12], targets[13], targets[14], reason);
	    
	    if(strlen(reason) <= 0)
        {
       		SendClientMessage(playerid, -1, "/warn (id...) (reason)");
       		return 1;
        }
	    
	    for( new j; j < sizeof(targets); j++ )
	    {
			if(IsPlayerConnected(targets[j]) && Player[targets[j]][pLogged])
			{
			    Player[targets[j]][Warnings]++;
			    if(Player[targets[j]][IsDefender] > 0)
				{
				    SendClientMessage(targets[j], -1, "{99ffff}[EVENT] Defender, you have breaks the rules, atone for your guilt!");
					Player[targets[j]][DefenderSorryTime] = gettime()+86400;
				}
			    
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == targets[j]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][145], Player[targets[j]][UserName], Player[playerid][RealName], Player[targets[j]][Warnings], MakeReasonFromShort(reason));
				ShowPlayerDialog(targets[j], DIALOG_WARNED, DIALOG_STYLE_MSGBOX, "Warning", MakeReasonFromShort(reason), "Ok", "");

				if(ItsNewbie(targets[j]) && Player[targets[j]][Warnings] >= 3)
				{
				    Player[targets[j]][Warnings]--;
	                foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == targets[j]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[targets[j]][UserName], Player[playerid][RealName], 3, MakeReasonFromShort(reason));
					SetPlayerSkinAC(targets[j], 62, 1);
					SetPlayerSpecialAction(targets[j], SPECIAL_ACTION_CUFFED);
					SetPlayerPosAC(targets[j],264.1425,77.4712,1001.0391);
	    			SetPlayerFacingAngle(targets[j], 263.0160);
	    			SetPlayerInterior(targets[j], 6);
	    			SetPlayerColor(targets[j], 0x000000FF);
	    			Player[targets[j]][Jailed] = 180;
	    			SetPlayerTeamEx(targets[j], TEAM_ZOMBIE);
	    			ResetWeapons(targets[j]);
	    			SetPlayerArmourAC(targets[j], 0.0);
	   				SetPlayerHealthAC(targets[j], 100.0);
	   				Player[targets[j]][Accelerated] = -1;
	   				if(IsPlayerAcceleratedText[targets[j]]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[targets[j]]),IsPlayerAcceleratedText[targets[j]]=Text3D:-1;
					if(Player[playerid][pAdmin] <= 5)
					{
					    #if debug_mode == 0
				        new __action[128];
						DiscordChannel = DCC_FindChannelById("623193667628433438");
						format(__action, sizeof __action, "```\n%s used /jail on player %s (Time: %d) [Reason: %s]\n```",  Player[playerid][RealName], Player[targets[j]][UserName], 3, MakeReasonFromShort(reason));
						DCC_SendChannelMessageEx(DiscordChannel, __action);
						#endif
					}
				}
                else
                {
					if(Player[targets[j]][Warnings] >= 3)
					{
						foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == targets[j]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][146], Player[targets[j]][UserName]);
						PlayerKick(targets[j]);
					}
				}
				if(Player[playerid][pAdmin] <= 5)
				{
				    #if debug_mode == 0
			        new __action[128];
					DiscordChannel = DCC_FindChannelById("623193667628433438");
					format(__action, sizeof __action, "```\n%s used /warn on player %s [Reason: %s]\n```",  Player[playerid][RealName], Player[targets[j]][UserName], MakeReasonFromShort(reason));
					DCC_SendChannelMessageEx(DiscordChannel, __action);
					#endif
				}
			}
		}
		
		return 1;
	}
	return 0;
}

CMD:no(playerid)
{
	if(!votekick) return 0;
	if(already_vote[playerid] == true)
	{
 		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][83]);
		return 1;
	}
	voites--;
    foreach(Player, i) SendClientMessageFormat(i, -1,  serverLang[Player[i][pLang]][80], Player[playerid][UserName], voites < 0 ? 0 : voites, votekick_max_voices);
 	if(voites < 0)
 	{
 	    foreach(Player, i)
 	    {
 	        kick_player[i] = false;
          	already_vote[i] = false;
          	SendClientMessage(i, -1,  serverLang[Player[i][pLang]][76]);
 	    }
 	    votekick = false;
		voites = 0;
		votekick_max_voices = 0;
		KillTimer(VoteKickTimer);
		return 1;
 	}
 	already_vote[playerid] = true;
 	return 1;
}

CMD:skin(playerid, params[])
{
	if(Player[playerid][pVip] > 0)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1,"/skin (id)");
	    if(params[0] == 0 || params[0] == 99 || params[0] == 92 || params[0] == 74 || params[0] == 217 || params[0] == 211)
		{
			SendClientMessage(playerid, -1,"/skin (id)");
			return 1;
		}
	    if(params[0] <= -2 || params[0] > 311)
	    {
	        SendClientMessage(playerid, -1,"/skin (id)");
			return 1;
	    }
	    
	    if(params[0] == -1)
		{
			Player[playerid][pVipSkin] = 0;
			SendClientMessage(playerid, -1,"{FF0000}>> Skin auto-change is off!");
			return 1;
		}
		SendClientMessage(playerid, -1,"{cdcdcd}Use {FF0000}/skin -1{cdcdcd} to switch auto-change off!");
		Player[playerid][pVipSkin] = params[0];
	    SetPlayerSkinAC(playerid, params[0]);
	    ClearAnimations(playerid);
	    
	    return 1;
	}
	return 0;
}

CMD:ss(playerid)
{
	SaveUserData(playerid);
	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][160]);
	return 1;
}

CMD:acmds(playerid)
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
    {
		SendClientMessage(playerid, -1,"{33CCFF}------------------------ ADMIN COMMANDS ------------------------ ");
		if(Player[playerid][pAdmin] >= 1 )
		{
			SendClientMessage(playerid, -1,"{33CCFF}LVL 1: /aduty /atext /getip /slap /getinfo /sync /(un)jail");
			SendClientMessage(playerid, -1,"{33CCFF}LVL 1: /ex /cc /tban(only 3 hours) /checkip /kick /(un)warn /muwa /waja /spec /(un)mute");
		}
		if(Player[playerid][pAdmin] >= 2 ) SendClientMessage(playerid, -1,"{33CCFF}LVL 2: /jetpack /evader /tban(only 72 hours) /goto /bslap /reconnect ");
		if(Player[playerid][pAdmin] >= 3 ) {
			SendClientMessage(playerid, -1,"{33CCFF}LVL 3: /skip /tban(999 hours) /ban /explode /time /weather");
            SendClientMessage(playerid, -1,"{33CCFF}LVL 3: /get /makezombie /veh /delveh /adva /name");
		}
		if(Player[playerid][pAdmin] >= 4 )
		{
			SendClientMessage(playerid, -1,"{33CCFF}LVL 4: /makehuman /unbanip /setmap /banip /makeinv (Make an Investigator)");
            SendClientMessage(playerid, -1,"{33CCFF}LVL 4: /(un)banport /offban(banname) /offtban /freeze /unfreeze /cmdcheck");
		}
		if(Player[playerid][pAdmin] >= 5 )
		{
			SendClientMessage(playerid, -1,"{33CCFF}LVL 5: /makeadmin /fire /demote /offmakeadmin /makegm /makeem /xp /pmspy /restart");
            //SendClientMessage(playerid, -1,"{33CCFF}LVL 5: /(un)bankey (Can block up to 10k and more accounts at a time, use with caution) /banmachine (The same as /bankey, but by In-Game Slot ID)");
		}
		return 1;
	}
	return 0;
}

CMD:freeze(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0]))
	    {
	        SendClientMessage(playerid, -1, "/freeze (id)");
	        return 1;
		}
		TogglePlayerControllable(params[0], 0);
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been frozen up by %s", Player[params[0]][UserName], Player[playerid][UserName]);
	    return 1;
	}
	return 0;
}

CMD:unfreeze(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0]))
	    {
	        SendClientMessage(playerid, -1, "/unfreeze (id)");
	        return 1;
		}
		TogglePlayerControllable(params[0], 1);
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been thawed by %s", Player[params[0]][UserName], Player[playerid][UserName]);
	    return 1;
	}
	return 0;
}

CMD:sync(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0]))
	    {
	        SendClientMessage(playerid, -1, "/sync (id)");
	        return 1;
		}
	 	SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	    ClearAnimations(params[0]);
		TogglePlayerControllable(params[0], 0);
		TogglePlayerControllable(params[0], 1);
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been synced by %s", Player[params[0]][UserName], Player[playerid][UserName]);
	    return 1;
	}
	return 0;
}

ALTX:music("/m");
CMD:music(playerid, params[])
{
	if(Player[playerid][pAdmin] > 2 || Player[playerid][pVip] >= 3)
	{
	    if(sscanf(params, "s[128]", params[0]))
	    {
	        SendClientMessage(playerid, -1, "/music (direct link)");
	        return 1;
		}
		if(gettime() < MusicPlayTime)
		{
		    SendClientMessage(playerid, -1, "You can't set music too often");
		    return 1;
		}
		foreach(Player, i)
		{
		    if(GetUnlockedSlot(Player[i][pSettings], PS_MUSIC) == 0)
		    {
		    	SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][158], Player[playerid][UserName]);
				PlayAudioStreamForPlayer(i, params[0]);
			}
		}
		MusicPlayTime = gettime() + 180;
		return 1;
	}
	return 0;
}

CMD:off(playerid)
{
    StopAudioStreamForPlayer(playerid);
    PlayerPlaySound(playerid, 0, 0.0, 0.0, 0.0);
	return 1;
}

CMD:settings(playerid)
{
	new str[664], mask[6][40];
	for( new i = 0; i < sizeof(mask); i++ )
	{
		if(i != 9 && i != 11 && i!= 13) if(GetUnlockedSlot(Player[playerid][pSettings], i) == 1) mask[i] = "\t \t \t{FFFFFF}[{00FF00}YES{FFFFFF}]"; else mask[i] = "\t \t \t{FFFFFF}[{FF0000}NO{FFFFFF}]";
		else if(GetUnlockedSlot(Player[playerid][pSettings], i) == 0) mask[i] = "\t \t \t{FFFFFF}[{00FF00}YES{FFFFFF}]"; else mask[i] = "\t \t \t{FFFFFF}[{FF0000}NO{FFFFFF}]";
	}
	format(str, sizeof(str), "Block PMs%s\nDing%s\nBlock Duel Request%s\n\"Ability Is Ready\" sound%s\nAuto-Login%s\nUnhiden%s", mask[0], mask[1], mask[2], mask[3], mask[4], mask[5]);

	ShowPlayerDialog(playerid, DIALOG_SETTINGS, DIALOG_STYLE_TABLIST, serverLang[Player[playerid][pLang]][65], str, serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);
    return 1;
}

CMD:giveammo(playerid, params[])
{
    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == HEAVYSUPPORT)
    {
        if(Time >= 281)
        {
            GameTextForPlayer(playerid,"~w~Wait",2000,5);
            return 1;
        }
        
        if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
        if(sscanf(params, "i", params[0]))
        {
            SendClientMessage(playerid, -1, "/giveammo (playerid)");
			return 1;
        }
        
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		
		if(GetPlayerTeamEx(params[0]) == TEAM_HUMAN)
		{
			if(Abilitys[playerid][CanGiveAmmo] >= 1)
			{
				new slot, randomammo, weap, ammo, weapname[32];
			    for ( slot = 0; slot < 14; slot++ )
			    {
			        GetPlayerWeaponData(params[0],slot,weap,ammo);
			        if(IsValidWeapon(weap))
			        {
						if(weap != 24) randomammo = min(15, floor(float(ammo) * 0.25));
						else randomammo = min(8, floor(float(ammo) * 0.10));
						
		            	GetWeaponName(weap, weapname, sizeof(weapname));
		            	SetPVarInt(params[0], weapname, GetPVarInt(params[0], weapname) + randomammo);
		            	SetPlayerAmmoAC(params[0], weap, GetPVarInt(params[0], weapname));
					}
				}

				SendClientMessageFormat(params[0], -1, serverLang[Player[params[0]][pLang]][68], Player[playerid][UserName]);
                SendClientMessageFormat(playerid, -1, "{E68687}>> You've sent ammo to %s", Player[params[0]][UserName]);
                
		        Abilitys[playerid][CanGiveAmmo]--;
		        return 1;
	        }
	        else
	        {
	            GameTextForPlayer(playerid, "~r~Empty", 2000, 5);
	            return 0;
	        }
		}
        return 1;
    }
    return 1;
}

fun CanUseCureCommand(playerid)
{
	switch(Player[playerid][pClass][TEAM_HUMAN])
	{
    	case MEDIC, HEAVYMEDIC, ADVANCEDMEDIC, SENIORMEDIC, NURSE: return 1;
	}
	return 0;
}

fun CanCureByRifleShot(playerid)
{
	switch(Player[playerid][pClass][TEAM_HUMAN])
	{
    	case ADVANCEDMEDIC, SENIORMEDIC: return 1;
	}
	return 0;
}

fun CanCureAll(playerid)
{
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
    	case SENIORMEDIC, NURSE: return 1;
	}
	return 0;
}

CMD:cureall(playerid)
{
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && CanCureAll(playerid))
	{
	    if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
	    if(Time <= 0)
		{
		    switch(Player[playerid][pLang])
		    {
				case 0: GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
				case 1: GameTextForPlayer(playerid,RusToGame("~r~УЖЕ КОНЕЦ"), 4000, 5);
				case 2: GameTextForPlayer(playerid,"~r~El tiempo ha terminado", 4000, 5);
			}
			return 1;
		}
	    if(gettime() - 10 < Abilitys[playerid][CureAbility])
		{
		    switch(Player[playerid][pLang])
		    {
				case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
		        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
		        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
			}
			return 1;
		}

     	new Float: pos[3], count;
  		GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
  		
	 	new Float:radius = 10.0;
		foreach(Player, i)
		{
			if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2]) && Player[i][IsPlayerInfected])
			{
		    	if(CurePlayer(i, playerid))
		    	{
					count++;
			    	switch(Player[i][pLang])
			    	{
			    		case 0: GameTextForPlayer(i,"~g~ANTIDOTE TAKEN", 2000, 5);
			    		case 1: GameTextForPlayer(i,RusToGame("~g~ВЫЛЕЧЕН"), 2000, 5);
			    		case 2: GameTextForPlayer(i,"~g~ANTIDOTO TOMADO", 2000, 5);
					}
				}
			}
		}

		if(count > 0)
		{
		    ApplyAnimation(playerid, "MEDIC", "CPR", 4.1, 0, 1, 1, 1, 6000);

		    Abilitys[playerid][CureAbility] = gettime();
			GivePlayerXP(playerid, 5);
			foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][95], Player[playerid][UserName], count);
		}
		return 1;
	}
	else
	{
	    SendClientMessage(playerid, -1, "{FF0000}>> You must be a Senior Medic or a Nurse!");
	}
	return 0;
}

CMD:cure(playerid, params[])
{
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    if(CanUseCureCommand(playerid))
	    {
		    if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
		    if(Time <= 0)
			{
			    switch(Player[playerid][pLang])
			    {
					case 0: GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
					case 1: GameTextForPlayer(playerid,RusToGame("~r~УЖЕ КОНЕЦ"), 4000, 5);
					case 2: GameTextForPlayer(playerid,"~r~El tiempo ha terminado", 4000, 5);
				}
				return 1;
			}
	        if(gettime() - 8 < Abilitys[playerid][CureAbility])
	        {
				switch(Player[playerid][pLang])
			    {
					case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
			        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
			        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
				}
				return 1;
			}
			if(sscanf(params, "i", params[0]))
			{
				SendClientMessage(playerid, -1, "/cure (playerid)");
				return 1;
			}
			if(!IsPlayerConnected(params[0]))
			{
				SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
				return 1;
			}
	     	new Float: pos[3];
	  		GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	  		
	  		new Float:radius = 5.0;
	    	if(IsPlayerInRangeOfPoint(params[0], radius, pos[0], pos[1], pos[2]) && Player[params[0]][IsPlayerInfected])
			{
				if(CurePlayer(params[0], playerid))
			    {
			    	foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][61], Player[params[0]][UserName], Player[playerid][UserName]);
					if(params[0] != playerid) GivePlayerXP(playerid, 5);
					ApplyAnimation(playerid, "MEDIC", "CPR", 4.1, 0, 1, 1, 1, 6000);
			    	Abilitys[playerid][CureAbility] = gettime();
				}
				
                return 1;
			}
		}
		else
		{
		    SendClientMessage(playerid, -1, "{FFF000}>> You need to be a Medic!");
		    return 1;
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, "{FFF000}>> You need to be a Human!");
	    return 1;
	}
	return 1;
}

fun ShowVPNActions(id)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
     	new a, aid, date, country[64], ip[16], Name[MAX_PLAYER_NAME], str[300], query[164], kie[64], y, m, d, h, i, s;
	    for( a = 0; a < cache_num_rows(); a++ )
		{
		   	cache_get_value_name_int(a, "acc", aid);
 	    	cache_get_value_name_int(a, "login", date);
 	    	cache_get_value_name(a, "kie", kie, 64);
 	    	cache_get_value_name(a, "country", country, 64);
 	    	cache_get_value_name(a, "ip", ip, 16);
 	    	cache_get_value_name(a, "Name", Name, MAX_PLAYER_NAME);

			TimestampToDate(date, y, m, d, h, i, s, 3);
			format(str, sizeof str, "```diff\n- %02d/%02d/%04d %02d:%02d:%02d %s(%d) has connected from %s (IP %s)\n```", d, m, y, h, i, s, Name, aid, country, ip);
			DCC_SendChannelMessageEx(DiscordChannel, str);
			
 			mysql_format(Base, query, sizeof(query), "SELECT `Name`, `lalog`, `ID` FROM `users` WHERE `kie` = '%e' AND `build`='"SERVER_BUILD"' LIMIT 30", kie);
			mysql_tquery(Base, query, "ShowSecurityErrorMessage", "i", 3);
			
		}
	}
	else
	{
		DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nNo matches found\n```");
	}
	DCC_SendChannelMessageEx(DiscordChannel, "```yaml\n-- END\n```");
	#endif
	return 1;
}

fun ShowAccActions(id)
{
    if(cache_num_rows() > 0)
	{
	    #if debug_mode == 0
	    DiscordChannel = DCC_FindChannelById("674323910648397894");
    	DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Information gathering process initiated\n```");
    
	    new a, text[164], aid, type, sign[41], reg_sign[41], ip[16], date, str[256], Name[MAX_PLAYER_NAME];
	    for( a = 0; a < cache_num_rows(); a++ )
		{
		   	cache_get_value_name_int(a, "acc", aid);
 	    	cache_get_value_name_int(a, "type", type);
 	    	cache_get_value_name(a, "text", text, 164);
 	    	cache_get_value_name(a, "sign", sign, 42);
 	    	cache_get_value_name_int(a, "date", date);
 	    	cache_get_value_name(a, "reg_sign", reg_sign, 42);
 	    	cache_get_value_name(a, "ip", ip, 16);
 	    	cache_get_value_name(a, "Name", Name, MAX_PLAYER_NAME);
 	    	
 	    	new y, m, d, h, i, s;
			TimestampToDate(date, y, m, d, h, i, s, 3);
 	    	
 	    	if(type == 0)
 	    	{
 	    	    if(strfind(reg_sign, sign, true) == -1) format(str, sizeof str, "```css\n[MISMATCH] %04d-%02d-%02d %02d:%02d:%02d %s(%d) used %s\n```", y, d, m, h, i, s, Name, aid, text);
 	    	    else format(str, sizeof str, "```css\n%04d-%02d-%02d %02d:%02d:%02d %s(%d) used %s\n```", y, d, m, h, i, s, Name, aid, text);
				DCC_SendChannelMessageEx(DiscordChannel, str);
 	    	}
 	    	if(type == 2)
 	    	{
 	    	    if(strfind(reg_sign, sign, true) == -1) format(str, sizeof str, "```css\n[MISMATCH] %04d-%02d-%02d %02d:%02d:%02d %s(%d) said %s\n```", y, d, m, h, i, s, Name, aid, text);
 	    	    else format(str, sizeof str, "```css\n%04d-%02d-%02d %02d:%02d:%02d %s(%d) said %s\n```", y, d, m, h, i, s, Name, aid, text);
				DCC_SendChannelMessageEx(DiscordChannel, str);
 	    	}
		}
		#endif
	}
	return 1;
}

fun ShowSecurityErrorMessage(type)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
	if(cache_num_rows())
	{
	    switch(type)
	    {
		    case 0:
		    {
			    DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Connection:  The following accounts are being processed for suspicion\n```");
			    new  id, name[MAX_PLAYER_NAME], lalog[15], str[256];
				for( new a; a < cache_num_rows(); a++ )
				{
		     	    cache_get_value_name(a, "Name", name, MAX_PLAYER_NAME+1);
		     	    cache_get_value_name(a, "lalog", lalog, 15);
					cache_get_value_name_int(a, "ID", id);
		 	    	format(str, sizeof str, "```\n#Connection: %s(%d) - Last login: %s\n```", name, id, lalog);
					DCC_SendChannelMessageEx(DiscordChannel, str);
				}
				DCC_SendChannelMessageEx(DiscordChannel, "```\n-------------------------------------------------------------------\n```");
			}
			case 1:
		    {
			    DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Password: The following accounts are being processed for suspicion\n```");
			    new  id, name[MAX_PLAYER_NAME], lalog[15], str[256];
				for( new a; a < cache_num_rows(); a++ )
				{
		     	    cache_get_value_name(a, "Name", name, MAX_PLAYER_NAME+1);
		     	    cache_get_value_name(a, "lalog", lalog, 15);
					cache_get_value_name_int(a, "ID", id);
		 	    	format(str, sizeof str, "```\n#Password: %s(%d) - Last login: %s\n```", name, id, lalog);
					DCC_SendChannelMessageEx(DiscordChannel, str);
				}
				DCC_SendChannelMessageEx(DiscordChannel, "```\n-------------------------------------------------------------------\n```");
			}
			case 3:
		    {
			    DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Login: The following accounts are being processed for suspicion\n```");
			    new  id, name[MAX_PLAYER_NAME], lalog[15], str[256];
				for( new a; a < cache_num_rows(); a++ )
				{
		     	    cache_get_value_name(a, "Name", name, MAX_PLAYER_NAME+1);
		     	    cache_get_value_name(a, "lalog", lalog, 15);
					cache_get_value_name_int(a, "ID", id);
		 	    	format(str, sizeof str, "```\n#Login: %s(%d) - Last login: %s\n```", name, id, lalog);
					DCC_SendChannelMessageEx(DiscordChannel, str);
				}
				DCC_SendChannelMessageEx(DiscordChannel, "```\n--------------------------------------------------------------------\n```");
			}
		}
	}
	else
	{
 		if(type == 0) DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Connection: No account match found\n```");
 		if(type == 1) DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Password: No account match found\n```");
 		if(type == 3) DCC_SendChannelMessageEx(DiscordChannel, "```diff\n- Login: No account match found\n```");
	}
	#endif
	return 1;
}

fun ShowSecurityErrors(p)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
	    new acc, ip[16], date, reg[16], sign[64], type, lsign[4][64], lp[4], str[256], j;
 		format(str, sizeof str, "```css\nSecurity detected %d messages\n```", cache_num_rows());
 		DCC_SendChannelMessageEx(DiscordChannel, str);
 		
		for( j = 0; j < cache_num_rows(); j++ )
		{
            cache_get_value_name_int(j, "acc", acc);
		    cache_get_value_name(j, "ip", ip, 17);
		    cache_get_value_name(j, "reg", reg, 17);
		    cache_get_value_name_int(j, "date", date);
		    cache_get_value_name(j, "sign", sign, 64);
		    cache_get_value_name_int(j, "type", type);
		   	new y, m, d, h, i, s;
      		TimestampToDate(date, y, m, d, h, i, s, 3);
		    format(str, sizeof str, "```diff\n- %04d-%02d-%02d %02d:%02d [IP MISMATCH] - IP: %s - Reg: %s\n```", y,m,d, h,i, ip, reg);
   			DCC_SendChannelMessageEx(DiscordChannel, str);

   			if(strlen(sign) >= 1 && type == 0)
			{
				if(strfind(lsign[type], sign, true) != -1 && j >= 1)
			    {
			        format(str, sizeof str, "```\n[IP] Proto(%d) - Same as Proto(%d), no action required\n```", j+1, lp[type]+1);
			        DCC_SendChannelMessageEx(DiscordChannel, str);
			    }
			    else
			    {
			        new query[164];
		    		mysql_format(Base, query, sizeof(query), "SELECT `Name`, `lalog`, `ID` FROM `users` WHERE `kie` = '%e' AND `build`='"SERVER_BUILD"' LIMIT 5", sign);
					mysql_tquery(Base, query, "ShowSecurityErrorMessage", "i", type);
					strmid(lsign[type], sign, 0, 65, 65);
		        	lp[type] = j;
				}
   			}

   			if(type == 1)
   			{
   			    format(str, sizeof str, "```diff\n- %04d-%02d-%02d %02d:%02d [PASSWORD CHANGED] - IP: %s - Reg: %s\n```", y, m, d, h, i, ip, reg);
   				DCC_SendChannelMessageEx(DiscordChannel, str);
				if(strfind(lsign[type], sign, true) != -1 && j >= 1)
			    {
			        format(str, sizeof str, "```\n[PASSWORD] Proto(%d) - Same as Proto(%d), no action required\n```", j+1, lp[type]+1);
			        DCC_SendChannelMessageEx(DiscordChannel, str);
			    }
			    else
			    {
			        new query[164];
		    		mysql_format(Base, query, sizeof(query), "SELECT `Name`, `lalog`, `ID` FROM `users` WHERE `kie` = '%e' AND `build`='"SERVER_BUILD"' LIMIT 5", sign);
					mysql_tquery(Base, query, "ShowSecurityErrorMessage", "i", type);
					strmid(lsign[type], sign, 0, 65, 65);
		        	lp[type] = j;
				}
   			}

            if(type == 3)
   			{
   			    format(str, sizeof str, "```diff\n- %04d-%02d-%02d %02d:%02d [LOGIN ERROR] - IP: %s - Reg: %s\n```", y, m, d, h, i, ip, reg);
   				DCC_SendChannelMessageEx(DiscordChannel, str);
				if(strfind(lsign[type], sign, true) != -1 && j >= 1)
			    {
			        format(str, sizeof str, "```\n[LOGIN] Proto(%d) - Same as Proto(%d), no action required\n```", j+1, lp[type]+1);
			        DCC_SendChannelMessageEx(DiscordChannel, str);
			    }
			    else
			    {
			        new query[164];
		    		mysql_format(Base, query, sizeof(query), "SELECT `Name`, `lalog`, `ID` FROM `users` WHERE `kie` = '%e' AND `build`='"SERVER_BUILD"' LIMIT 5", sign);
					mysql_tquery(Base, query, "ShowSecurityErrorMessage", "i", type);
					strmid(lsign[type], sign, 0, 65, 65);
		        	lp[type] = j;
				}
   			}
		}
		DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nSearch for changes in the username - [PROCESSING]:\n```");
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nStabilized, no suspicion identified\nSearch for changes in the username\n```");
	}
	new query[128];
 	mysql_format(Base, query, sizeof(query), "SELECT * FROM `namechanger` WHERE `account` = '%d' AND `build`='"SERVER_BUILD"'", p);
	mysql_tquery(Base, query, "ProtocolShowNames", "ii", p, 1);
	#endif
	return 1;
}
	
fun ShowNameChanges(p)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
	    new j, str[256];
  		format(str, sizeof(str), "```css\nFound: %d results\n```", cache_num_rows());
		DCC_SendChannelMessageEx(DiscordChannel, str);
		
	    for( j = 0; j < cache_num_rows(); j++ )
		{
		    new NN[24], ON[24], date, y, m, d, h, i, s, op[16];
			cache_get_value_name(j, "newName", NN);
   			cache_get_value_name(j, "oldName", ON);
      		cache_get_value_name_int(j, "Date", date);
        	cache_get_value_name(j, "IP", op);
            TimestampToDate(date, y, m, d, h, i, s, 3);
   			format(str, sizeof(str), "```\n%04d-%02d-%02d %02d:%02d %s renamed to %s (%s)\n```", y, m, d, h, i, ON, NN, op);
			DCC_SendChannelMessageEx(DiscordChannel, str);
		}
	}
	else
	{
        DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo name changes were detected\n```");
	}
	#endif
	return 1;
}

fun ProtocolCheckISP() {
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
	    new str[128], name[64], id;
	    for( new j; j < cache_num_rows(); j++ )
		{
   			cache_get_value_name(j, "Name", name);
   			cache_get_value_name_int(j, "ID", id);
   			format(str, sizeof(str), "```\n-> %s (%d)\n```", name, id);
			DCC_SendChannelMessageEx(DiscordChannel, str);
		}
	}
 	else
	{
        DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo results\n```");
	}
	#endif
}

fun ProtocolShowISP(p, b) {
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
	    new str[128], name[64];
	    for( new j; j < cache_num_rows(); j++ )
		{
   			cache_get_value_name(j, "name", name);
   			format(str, sizeof(str), "```diff\n- ISP founded: %s\n```", name);
			DCC_SendChannelMessageEx(DiscordChannel, str);
		}
	}
 	else
	{
        DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nNo ISP founded\n```");
	}
	if(b) {
		DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nSwitching to VPN detections\n```");
		new query[256];
	 	mysql_format(Base, query, sizeof(query), "SELECT vpns.*, users.Name FROM `vpns` JOIN `users` WHERE users.ID = '%d' AND vpns.acc = '%d' ORDER BY vpns.login DESC LIMIT 5", p, p);
		mysql_tquery(Base, query, "ShowVPNActions", "i", p);
	}
	#endif
}

fun ProtocolShowNames(p, b)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
	{
	    new value = cache_num_rows(), str[256];
	    if(value > 15) {
			value = 15;
			format(str, sizeof(str), "```fix\n[PERFORMANCE WARNING]: Most of name changes will not be shown, LIMIT 15, but found %d\n```", cache_num_rows());
	    	DCC_SendChannelMessageEx(DiscordChannel, str);
	    }
	    
	    for( new j; j < value; j++ )
		{
		    new NN[24], ON[24], date, y, m, d, h, i, s, op[16];
			cache_get_value_name(j, "newName", NN);
   			cache_get_value_name(j, "oldName", ON);
      		cache_get_value_name_int(j, "Date", date);
        	cache_get_value_name(j, "IP", op);
            TimestampToDate(date, y, m, d, h, i, s, 3);
   			format(str, sizeof(str), "```diff\n- %04d-%02d-%02d %02d:%02d %s renamed to %s - (%s)\n```", y, m, d, h, i, ON, NN, op);
			DCC_SendChannelMessageEx(DiscordChannel, str);
		}
		DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nSwitching to bans\n```");
	}
	else
	{
        DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nNo name changes were detected, switching to bans\n```");
	}
	if(b) {
		new query[128];
		mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlog` WHERE `acc` = '%d' AND `build`='"SERVER_BUILD"'", p);
		mysql_tquery(Base, query, "ShowBanLog", "ii", p, b);
	}
	#endif
	return 1;
}

fun ITGetKey()
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new i, id, name[MAX_PLAYER_NAME], str[256], sign[41], reg_sign[41];
   	    for( i = 0; i < cache_num_rows(); i++)
   	    {
   	        cache_get_value_name_int(i, "acc", id);
		    cache_get_value_name(i, "Name", name, MAX_PLAYER_NAME);
		    
		    cache_get_value_name(i, "sign", sign, 41);
		    cache_get_value_name(i, "reg_sign", reg_sign, 41);
		    
			format(str, sizeof(str), "```yaml\n************ %s (Account ID %d) ************\n```", name, id);
            DCC_SendChannelMessageEx(DiscordChannel, str);
            
            if(!strcmp(sign, reg_sign, false)) format(str, sizeof(str), "```\nREG: %s\nCUR: %s\n\n$IDENTICAL```", reg_sign, sign);
            else format(str, sizeof(str), "```\nREG: %s\nCUR: %s\n\n$MISMATCH - Security system added error```", reg_sign, sign);
			
	  		DCC_SendChannelMessageEx(DiscordChannel, str);
   	    }
   	}
   	else
   	{
   	    DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
   	}
   	#endif
   	return 1;
}

fun ITGetPort()
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new i, id, name[MAX_PLAYER_NAME], str[256], port;

   	    new bool:f=false;

   	    for( i = 0; i < cache_num_rows(); i++)
   	    {
   	        cache_get_value_name_int(i, "aid", id);
		    cache_get_value_name(i, "uname", name, MAX_PLAYER_NAME);
            cache_get_value_name_int(i, "port", port);
			if(port <= 0 || !strlen(name)) continue;

			format(str, sizeof(str), "```%d. %s(%d) > %04d-%02d-%02d %02d:%02d:%02d```", i+1, name, id);
	  		DCC_SendChannelMessageEx(DiscordChannel, str);
	  		f = true;
   	    }
   	    if(!f)
   	    {
            DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
   	    }
   	}
   	else
   	{
   	    DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
   	}
   	#endif
   	return 1;
}

fun ITComparePorts()
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new i, id, name[MAX_PLAYER_NAME], ll, str[256];

   	    new y, m, d, h, o, s;

   	    for( i = 0; i < cache_num_rows(); i++)
   	    {
   	        cache_get_value_name_int(i, "aid", id);
		    cache_get_value_name(i, "uname", name, MAX_PLAYER_NAME);
		    cache_get_value_name_int(i, "la_log", ll);
		    if(ll <= 0 || !strlen(name)) continue;

            TimestampToDate(ll, y, m, d, h, o, s, 3);

			if( i == 0 ) format(str, sizeof(str), "```LATEST: %s(%d) > %04d-%02d-%02d %02d:%02d:%02d```", name, id, y, m, d, h, o, s);
	  		else format(str, sizeof(str), "```RECENT: %s(%d) > %04d-%02d-%02d %02d:%02d:%02d```", name, id, y, m, d, h, o, s);
	  		DCC_SendChannelMessageEx(DiscordChannel, str);
   	    }
   	}
   	else
   	{
   	    DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
   	}
   	#endif
   	return 1;
}

fun ITCompareKeys()
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new i, id, name[MAX_PLAYER_NAME], ll, str[256];
   	    
   	    new y, m, d, h, o, s;
   	    
   	    for( i = 0; i < cache_num_rows(); i++)
   	    {
   	        cache_get_value_name_int(i, "aid", id);
		    cache_get_value_name(i, "uname", name, MAX_PLAYER_NAME);
		    cache_get_value_name_int(i, "la_log", ll);
		    if(ll <= 0 || !strlen(name)) continue;

            TimestampToDate(ll, y, m, d, h, o, s, 3);

			if( i == 0 ) format(str, sizeof(str), "```LATEST: %s(%d) > %04d-%02d-%02d %02d:%02d:%02d```", name, id, y, m, d, h, o, s);
	  		else format(str, sizeof(str), "```RECENT: %s(%d) > %04d-%02d-%02d %02d:%02d:%02d```", name, id, y, m, d, h, o, s);
	  		DCC_SendChannelMessageEx(DiscordChannel, str);
   	    }
   	}
   	else
   	{
   	    DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
   	}
   	#endif
   	return 1;
}

fun ITCompareAccunts(id, id2)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new fk[41], sk[41], str[90];
		cache_get_value_name(0, "fk", fk, 41);
		cache_get_value_name(1, "sk", sk, 41);
		if(strlen(fk) <= 0 || strlen(sk) <= 0) DCC_SendChannelMessageEx(DiscordChannel, "```css\nUnable to compare, signs are corrupted\n```");
		else
		{
	  		if(strfind(fk, sk, true) != -1)
  			{
  			    format(str, sizeof(str), "```css\n[Total percentage calculation of Account ID %d and Account ID %d]\n```", id, id2);
			  	DCC_SendChannelMessageEx(DiscordChannel, str);
			  	
			  	new query[128], Cache:Data, Float:percent = 0.0;
				mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `kie` = '%e' AND `build`='"SERVER_BUILD"'", sk);
				Data = mysql_query(Base, query);
				if(cache_is_valid(Data))
			  	{
			  	    if(cache_num_rows() >= 3) percent = (100.0 / float(cache_num_rows()));
			  	    else percent = 100.0;
					cache_delete(Data);
				}
			  	
			  	format(str, sizeof(str), "```Matches on %.2f percents```", percent);
			  	DCC_SendChannelMessageEx(DiscordChannel, str);
			  	
			}
	  		else DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
		}
	}
	else DCC_SendChannelMessageEx(DiscordChannel, "```css\nNo matches\n```");
	#endif
	return 1;
}

fun ShowBanLog(p, b)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
   	{
   	    new admin[24], reason[64], perm, initiated, time, name[24], version[64];
    	new j, y, m, d, h, i, se, whounban[100], port = 0, await, awmes[24];
        new s[456], unban, untime, unadmin[24],acc, query[400];
        
		for( j = 0; j < cache_num_rows(); j++ )
		{
		    cache_get_value_name_int(j, "acc", acc);
		    cache_get_value_name(j, "admin", admin, 25);
		    cache_get_value_name(j, "reason", reason, 65);
		    cache_get_value_name_int(j, "time", time);
		    cache_get_value_name_int(j, "perm", perm);
		    cache_get_value_name_int(j, "initiated", initiated);
		    cache_get_value_name(j, "name", name, 25);
		    cache_get_value_name_int(j, "unbanned", unban);
		    cache_get_value_name_int(j, "untime", untime);
		    cache_get_value_name(j, "unadmin", unadmin, 25);
		    cache_get_value_name(j, "version", version, 64);
		    cache_get_value_name_int(j, "port", port);
		    cache_get_value_name_int(j, "await", await);
		    
		    if( perm > 0 )
		    {
		        TimestampToDate(untime, y, m, d, h, i, se, 3);

				// OLD
				//if(unban > 0) format(whounban, sizeof(whounban), "[Status: Unbanned by %s (Date: %02d/%02d/%04d Time: %02d:%02d)]", unadmin, d,m,y,h,i);
				//else format(whounban, sizeof(whounban), "[Status: Banned]");

				// NEW
                if(unban > 0) format(whounban, sizeof(whounban), "(UNBANNED)");
				else format(whounban, sizeof(whounban), "(BANNED)");

				TimestampToDate(initiated, y, m, d, h, i, se, 3);
				// NEW
                format(s, sizeof s, "```diff\n- %04d-%02d-%02d %02d:%02d %s has been banned by %s (%s) - (PERMANENT) - %s - (%s)\n```", y,m,d,h,i, name, admin, reason, whounban, version);

				// OLD
				//format(s, sizeof s, "```\n%s has been banned by %s [Reason: %s] - [Date: %02d/%02d/%04d Time: %02d:%02d] - [PERMANENT] - %s - [Version: %s]\n```", name, admin, reason, d,m,y,h,i, whounban, version);
	   			DCC_SendChannelMessageEx(DiscordChannel, s);
		    }
		    else if( time > 0 )
		    {
                TimestampToDate(untime, y, m, d, h, i, se, 3);
                if(await > 0) format(awmes, sizeof(awmes), " - (AWAITING)");
				if(unban > 0) format(whounban, sizeof(whounban), "(UNBANNED)");
				else
				{
				    if(gettime() > time && await <= 0)
				    {
				        mysql_format(Base, query, sizeof(query), "UPDATE `banlog` SET `unbanned` = '1',`untime` = '%d',`unadmin` = 'the System' WHERE `acc` = '%d' AND `perm` < '1'", time, acc);
						mysql_tquery(Base, query, "", "", "");
                        TimestampToDate(time, y, m, d, h, i, se, 3);
				    	format(whounban, sizeof(whounban), "(UNBANNED)");
				    }
				    else format(whounban, sizeof(whounban), "(BANNED)");
				}
				TimestampToDate(initiated, y, m, d, h, i, se, 3);

				format(s, sizeof s, "```diff\n- %04d-%02d-%02d %02d:%02d %s has been banned by %s (%s) - (TEMPORARLY) - %s - (%s)%s\n```", y,m,d,h,i, name, admin, reason, whounban, version, awmes);
				
	   			DCC_SendChannelMessageEx(DiscordChannel, s);
		    }
		}
   	}
   	else
   	{
   	    DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nNo bans were detected\n```");
   	}
   	if(b) {
	   	DCC_SendChannelMessageEx(DiscordChannel, "```yaml\nSwitching to ISP\n```");
		new query[128];
		mysql_format(Base, query, sizeof(query), "SELECT `name` FROM `isp` WHERE `ID` = '%d' GROUP BY `name`", p);
		mysql_tquery(Base, query, "ProtocolShowISP", "ii", p, b);
	}
   	#endif
	return 1;
}

fun UpdateBanLog(playerid)
{
    if(cache_num_rows() > 0)
   	{
   	    new id, query[256];
   	    cache_get_value_name_int(0, "ID", id);
   	    mysql_format(Base, query, sizeof(query), "UPDATE `banlog` SET `unbanned` = '1',`untime` = '%d',`unadmin` = '%e' WHERE `acc` = '%d'", gettime(), Player[playerid][RealName], id);
		mysql_tquery(Base, query, "", "", "");
   	}
   	return 1;
}

fun TryToUnbanPlayerFromAGame(playerid, const name[])
{
    if(cache_num_rows() > 0)
 	{
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][47], name, Player[playerid][UserName]);

        new query[144];
        mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "UpdateBanLog", "i", playerid);

		mysql_format(Base, query, sizeof(query), "DELETE FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "", "", "");
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /unban on player %s\n```", Player[playerid][RealName], name);
			DCC_SendChannelMessageEx(DiscordChannel, __action);

			DiscordChannel = DCC_FindChannelById("624580613697175582");
			format(__action, sizeof __action, "```\n%s has been unbanned by %s (IG)\n```", name, Player[playerid][RealName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif

		}
	}
	else
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][48]);
	}
	return 1;
}

CMD:unban(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	    new query[144], name[24];
		if(sscanf(params, "s[24]", name)) return SendClientMessage(playerid, -1, "/unban (name)");
		mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
	 	mysql_tquery(Base, query, "TryToUnbanPlayerFromAGame", "is", playerid, name);
	    return 1;
	}
	return 0;
}

stock BanPlayer(playerid, const reason[], const conn[] = "")
{
    IsBanned{playerid} = true;
	new query[456], IP[16], serial[41], version[64];
    gpci(playerid, serial, sizeof(serial));
	GetPlayerIp(playerid, IP, 16);
	GetPlayerVersion(playerid, version, 64);
    mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`gpci`,`ip`,`build`) VALUES ('%e','Anti-Cheat','%e',1,0,'%e','%e','"SERVER_BUILD"')", Player[playerid][UserName],reason,serial,IP);
	mysql_tquery(Base, query, "", "", "");

	mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`version`,`build`,`port`) VALUES ('%d','%e','%e','%d','%d','%d','%e','%e','"SERVER_BUILD"','%d')", Player[playerid][pAccountID], "Anti-Cheat", reason, 0, 1, gettime(), Player[playerid][UserName], version, Player[playerid][pPort]);
	mysql_tquery(Base, query, "", "", "");

	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][51]);
    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][52]);
    foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][100], Player[playerid][UserName], reason);

    new y, m, d, h, i, s;
	TimestampToDate(gettime(), y, m, d, h, i, s, 3);

    #if debug_mode == 0
    new str[200];
    DiscordChannel = DCC_FindChannelById("612998988609880076");
    if(DiscordChannel != DCC_INVALID_CHANNEL)
	{
		format(str, sizeof(str), "```yaml\n%04d-%02d-%02d %02d:%02d %s(%d) has been banned by Anti-Cheat (%s)\n```", y, m, d, h, i, Player[playerid][UserName], playerid, reason);
		DCC_SendChannelMessageEx(DiscordChannel, str);
	}
	
	DiscordChannel = DCC_FindChannelById("619186196718944256");
    if(DiscordChannel != DCC_INVALID_CHANNEL)
    {
		format(str, sizeof str, "```\n%04d-%02d-%02d %02d:%02d %s has been banned by Anti-Cheat (%s)\n```", y, m, d, h, i, Player[playerid][UserName], reason);
		DCC_SendChannelMessageEx(DiscordChannel, str);
	}
	#endif
	
 	PlayerKick(playerid, conn);
}

CMD:veh(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2 && Player[playerid][aDuty])
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/veh (carid)");
	    if(AdminVeh[playerid] > -1)
		{
			DestroyVehicle(AdminVeh[playerid]);
			AdminVeh[playerid] = -1;
		}
	    new Float: pos[4];
	    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	    GetPlayerFacingAngle(playerid, pos[3]);
	    AdminVeh[playerid] = CreateVehicle(params[0], pos[0], pos[1], pos[2], pos[3], 1, 1, -1);
	    LinkVehicleToInterior(AdminVeh[playerid], GetPlayerInterior(playerid));
		SetVehicleVirtualWorld(AdminVeh[playerid], GetPlayerVirtualWorld(playerid));
		PutPlayerInVehicle(playerid, AdminVeh[playerid], 0);
		//SendClientMessage(playerid, -1, "{FF0000}>> Currently disabled due to abuse...");
		return 1;
	}
	return 0;
}

CMD:delveh(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
	{
	    if(AdminVeh[playerid] > -1)
		{
			DestroyVehicle(AdminVeh[playerid]);
			AdminVeh[playerid] = -1;
		}
		return 1;
	}
	return 0;
}

/*CMD:leave(playerid, params[])
{
    if(Player[playerid][pAdmin] > 1)
	{
		if(sscanf(params, "s[24]", params[0])) return SendClientMessage(playerid, -1, "/leave (name)");
 		foreach(Player, i)
	 	{
			SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][12], Name(playerid), serverLang[Player[i][pLang]][9 + random(3)]);
			SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][0], params[0], playerid);
		}
	 	SetPlayerName(playerid, params[0]);
 		SpawnPlayer(playerid);
	    return 1;
	}
	return 0;
}*/

CMD:kick(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "is[128]", params[0], params[1])) return SendClientMessage(playerid, -1, "/kick (playerid) (reason)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAdmin] > 0 && Player[playerid][pAccountID] != 1) return 1;
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][106], Player[params[0]][UserName], Player[playerid][RealName], MakeReasonFromShort(params[1]));
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /kick on player %s [Reason: %s]\n```",  Player[playerid][RealName], Player[params[0]][UserName], params[1]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		PlayerKick(params[0]);
	    return 1;
	}
	return 0;
}

CMD:atext(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged] || GetUnlockedSlot(Player[playerid][pSettings], 29) == 1)
	{
	    new text[128];
    	if(sscanf(params, "s[128]", text))
		{
	 		SendClientMessage(playerid, -1, "/atext (text)");
	 		return 1;
		}
		//if(GetUnlockedSlot(Player[playerid][pSettings], PS_IAP) == 1 && !ProccessPay(playerid)) return 1;
		if(CheckForWebsite(text)) return 1;
        if(strfind(text, ".", true) != -1)
		{
	        new i_numcount, i_period, i_pos;
	        while(text[i_pos])
			{
	            if('0' <= text[i_pos] <= '9') i_numcount ++;
	            else if(text[i_pos] == '.') i_period ++;
	            i_pos++;
	        }
	        if(i_numcount >= 8 && i_period >= 3)
		 	{
	            return 1;
	        }
		}
    	foreach(Player, i)
		{
		    if(Player[i][pAdmin] <= 0) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][110], text);
		    else SendClientMessageFormat(i, -1, "{FFA500}>> Announcement{FFFFFF} %s {FFA500}(by %s)", text, Player[playerid][UserName]);
		}
    	if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /atext (%s)\n```", Player[playerid][RealName], text);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:unmute(playerid, params[])
{
	if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0]))
		{
			SendClientMessage(playerid, -1, "/unmute (playerid)");
            return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(Player[params[0]][Muted] == 0)
		{
		    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][115]);
			return 1;
		}
	    Player[params[0]][Muted] = 0;
     	foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][114], Player[params[0]][UserName], Player[playerid][RealName]);
     	if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /unmute on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	    return 1;
	}
	return 0;
}

CMD:waja(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    new reason[64];
	    if(sscanf(params, "iis[128]", params[0], params[1], reason))
		{
			SendClientMessage(playerid, -1, "/waja (playerid) (time) (reason)");
            return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] <= 0)
		{
			SendClientMessage(playerid, -1, "/waja (playerid) (time) (reason)");
            return 1;
		}
		
		new player = params[0], time = params[1];
		
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == player) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[player][UserName], Player[playerid][RealName], time, MakeReasonFromShort(reason));
		SetPlayerSkinAC(player, 62, 1);
		SetPlayerSpecialAction(player, SPECIAL_ACTION_CUFFED);
		SetPlayerPosAC(player,264.1425,77.4712,1001.0391);
		SetPlayerFacingAngle(player, 263.0160);
		SetPlayerInterior(player, 6);
		SetPlayerColor(player, 0x000000FF);
		Player[player][Jailed] = time * 60;
		SetPlayerTeamEx(player, TEAM_ZOMBIE);
		ResetWeapons(player);
		SetPlayerArmourAC(player, 0.0);
		SetPlayerHealthAC(player, 100.0);
		Player[player][Accelerated] = -1;
		if(IsPlayerAcceleratedText[player]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[player]),IsPlayerAcceleratedText[player]=Text3D:-1;

        Player[params[0]][Warnings]++;

     	foreach(Player, i)
	 	{
       		if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][145], Player[params[0]][UserName], Player[playerid][RealName], Player[params[0]][Warnings], MakeReasonFromShort(reason));
		}
		ShowPlayerDialog(params[0], DIALOG_WARNED, DIALOG_STYLE_MSGBOX, "Warning", MakeReasonFromShort(params[2]), "Ok", "");

		if(Player[params[0]][Warnings] >= 3)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][146], Player[params[0]][UserName]);
			PlayerKick(params[0]);
		}
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /muja on player %s [Reason: %s]\n```",  Player[playerid][RealName], Player[params[0]][UserName], MakeReasonFromShort(params[2]));
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:muwa(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "iis[128]", params[0], params[1], params[2]))
		{
			SendClientMessage(playerid, -1, "/muwa (playerid) (time) (reason)");
            return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] <= 0)
		{
			SendClientMessage(playerid, -1, "/muwa (playerid) (time) (reason)");
            return 1;
		}
		Player[params[0]][Muted] = params[1]*60;
		Player[params[0]][Warnings]++;
		
     	foreach(Player, i)
	 	{
		 	SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][111], Player[params[0]][UserName], Player[playerid][RealName], params[1], params[2]);
       		if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][145], Player[params[0]][UserName], Player[playerid][RealName], Player[params[0]][Warnings], MakeReasonFromShort(params[2]));
		}
		ShowPlayerDialog(params[0], DIALOG_WARNED, DIALOG_STYLE_MSGBOX, "Warning", MakeReasonFromShort(params[2]), "Ok", "");

		if(Player[params[0]][Warnings] >= 3)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][146], Player[params[0]][UserName]);
			PlayerKick(params[0]);
		}
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /muwa on player %s [Reason: %s]\n```",  Player[playerid][RealName], Player[params[0]][UserName], MakeReasonFromShort(params[2]));
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:mute(playerid, params[])
{
	if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "iis[128]", params[0], params[1], params[2]))
		{
			SendClientMessage(playerid, -1, "/mute (playerid) (time) (reason)");
            return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] <= 0)
		{
			SendClientMessage(playerid, -1, "/mute (playerid) (time) (reason)");
            return 1;
		}
	    Player[params[0]][Muted] = params[1]*60;
     	foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][111], Player[params[0]][UserName], Player[playerid][RealName], params[1], params[2]);

	    if(Player[params[0]][IsDefender] > 0)
		{
		    SendClientMessage(params[0], -1, "{99ffff}[EVENT] Defender, you have breaks the rules, atone for your guilt!");
			Player[params[0]][DefenderSorryTime] = gettime()+86400;
		}
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s has been muted by %s for %d minutes [Reason: %s]\n```", Player[params[0]][UserName], Player[playerid][RealName], params[1], params[2]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:getip(playerid, params[])
{
	if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/getip (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		new IP[16];
		GetPlayerIp(params[0], IP, 16);
		SendClientMessage(playerid, -1, IP);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /getip on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

fun CheckForBanEvader(playerid)
{
    new size = cache_num_rows();
	if(size > 0)
 	{
 	    SendClientMessage(playerid, -1, "{B2F558}+------------- IP Check -------------+");

        new User[MAX_PLAYER_NAME], id, i, query[144];
     	for( i = 0; i < size; i++ )
	 	{
	 	    cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
	 	    cache_get_value_name_int(i, "ID", id);
	 		mysql_format(Base, query, sizeof(query), "SELECT `Name` FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", User);
			mysql_tquery(Base, query, "CheckForBan", "isiii", id, User, 0, playerid, 0);
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, "No results found!");
	}
	return 1;
}

CMD:evader(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/evader (id)");
	    if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
	    
	    new query[144], IP[16];
	    GetPlayerIp(params[0], IP, sizeof(IP));
		mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `IP` LIKE '%e%%' AND `build`='"SERVER_BUILD"' LIMIT 10", IP);
	 	mysql_tquery(Base, query, "CheckForBanEvader", "i", playerid);
	 	
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /evader (IP: %s)\n```", Player[playerid][RealName], params[0]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:checkip(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "s[24]", params[0])) return SendClientMessage(playerid, -1, "/checkip (ip)");
	    new query[128];
		mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `IP` LIKE '%e%%' AND `build`='"SERVER_BUILD"' LIMIT 10", params[0]);
	 	mysql_tquery(Base, query, "CheckForBanEvader", "i", playerid);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /checkip (IP: %s)\n```", Player[playerid][RealName], params[0]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:slap(playerid, params[])
{
	if(Player[playerid][pAdmin] > 0 && Player[playerid][pLogged])
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/slap (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
	    new Float:pos[4];
	    SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	    GetPlayerPos(params[0], pos[0], pos[1], pos[2]);
	    SetPlayerPosAC(params[0], pos[0], pos[1], pos[2] + 10.0);
	    GetPlayerHealth(params[0], pos[3]);

     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][108], Player[playerid][RealName], Player[params[0]][UserName], pos[3]);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /slap on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:bslap(playerid, params[])
{
	if(Player[playerid][pAdmin] > 1)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/bslap (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	    new Float:pos[4];
	    GetPlayerPos(params[0], pos[0], pos[1], pos[2]);
	    SetPlayerPosAC(params[0], pos[0], pos[1], pos[2] + 20.0);
	    GetPlayerHealth(params[0], pos[3]);
	    
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][108], Player[playerid][RealName], Player[params[0]][UserName], pos[3]);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /bslap on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:explode(playerid, params[])
{
	if(Player[playerid][pAdmin] > 2)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/explode (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
	    new Float:pos[4];
	    SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	    GetPlayerPos(params[0], pos[0], pos[1], pos[2]);
        GetPlayerHealthEx(params[0], pos[3]);
        
        if(!Player[params[0]][aDuty])
        {
	        AntiCheat[params[0]][ex_OldHP] = pos[3];
		    SetTimerEx("AC_CheckForAntiExplosions", 2500, 0, "i", params[0]);
		}
		
		CreateExplosion(pos[0], pos[1], pos[2], 0, 7.0);
	    
     	GetPlayerHealth(params[0], pos[3]);
     	
     	
     	AntiSlap(params[0], 3);
     	AntiSpeedHack(params[0], 3);
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][109], Player[params[0]][UserName], Player[playerid][RealName], pos[3]);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /explode on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:goto(playerid, params[])
{
	if(Player[playerid][pAdmin] > 1)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/goto (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
	    new Float:pos[3];
	    SetPlayerInterior(playerid, GetPlayerInterior(params[0]));
	    SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(params[0]));
	    GetPlayerPos(params[0], pos[0], pos[1], pos[2]);
	    SetPlayerPosAC(playerid, pos[0]+1.5, pos[1]+1.5, pos[2]+0.5);
	    if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /goto on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
     	return 1;
	}
	return 0;
}

CMD:get(playerid, params[])
{
	if(Player[playerid][pAdmin] > 2)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/get (playerid)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
	    new Float:pos[3];
	    SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	    SetPlayerInterior(params[0], GetPlayerInterior(playerid));
	    SetPlayerVirtualWorld(params[0], GetPlayerVirtualWorld(playerid));
	    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	    SetPlayerPosAC(params[0], pos[0]+1.5, pos[1]+1.5, pos[2]+0.5);
	    if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /get on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
     	return 1;
	}
	return 0;
}

CMD:specoff(playerid)
{
    if(Player[playerid][pAdmin] <= 0) return 0;
	if(!IsSpecing[playerid]) return 0;
	AntiTPTimerEx(playerid, 4);
	AntiSlap(playerid, 2);
	AntiSpeedHack(playerid, 3);
	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][117], Player[playerid][RealName], Player[spectatorid[playerid]][UserName], spectatorid[playerid]);

	TogglePlayerSpectating(playerid, 0);
	IsSpecing[playerid] = false;
	SuspectForAIM[spectatorid[playerid]] = false;
	IsBeingSpeced[spectatorid[playerid]] = false;
	
	//SpawnPlayer(playerid);
	foreach(Player, i)
   	{
        if(Player[i][pAdmin] < 1)
		{
			ShowPlayerNameTagForPlayer(i, playerid, 0);
			SetPlayerMarkerForPlayer(i, playerid, 0xFFFFFF00);
		}
 	}
	if(Player[playerid][pAdmin] <= 5)
	{
	    #if debug_mode == 0
        new __action[128];
		DiscordChannel = DCC_FindChannelById("623193667628433438");
		format(__action, sizeof __action, "```\n%s used /specoff (Player %s)\n```",  Player[playerid][RealName], Player[spectatorid[playerid]][UserName]);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		#endif
	}
	
	spectatorid[playerid] = -1;
	
	return 1;
}

CMD:spec(playerid,params[])
{
	if(!Player[playerid][pLogged]) return 0;
	if(Player[playerid][pAdmin] < 1) return 0;
	if(!Player[playerid][aDuty]) return 0;
	if(sscanf(params,"u", params[0]))return SendClientMessage(playerid, -1, " /spec (id)");
	if(params[0] == playerid) return SendClientMessage(playerid, -1, " /spec (id)");
	if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(GetPlayerState(params[0]) == PLAYER_STATE_SPECTATING)
	{
	    SendClientMessage(playerid, -1, " /spec (id)");
	    return 1;
	}

	SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
	SetPlayerVirtualWorld(playerid,GetPlayerVirtualWorld(params[0]));
	SetPlayerInterior(playerid,GetPlayerInterior(params[0]));
    TogglePlayerSpectating(playerid, 1);
	PlayerSpectatePlayer(playerid,params[0]);
	IsSpecing[playerid] = true;
	IsBeingSpeced[params[0]] = true;
	spectatorid[playerid] = params[0];
	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][116], Player[playerid][RealName], Player[params[0]][UserName], params[0]);
 	SendClientMessage(playerid, -1, "/specoff");
 	AntiTPTimerEx(playerid, 4);
	AntiSlap(playerid, 2);
	AntiSpeedHack(playerid, 3);
	
	SuspectForAIM[params[0]] = true;
	
 	GetPlayerPos(playerid, OldPos[playerid][0], OldPos[playerid][1], OldPos[playerid][2]);
 	if(Player[playerid][pAdmin] <= 5)
	{
	    #if debug_mode == 0
        new __action[128];
		DiscordChannel = DCC_FindChannelById("623193667628433438");
		format(__action, sizeof __action, "```\n%s used /spec (Player %s)\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		#endif
	}
	if(reportsCount > 0) reportsCount--;
	return 1;
}

CMD:ex(playerid)
{
	if(Player[playerid][pAdmin] > 0 && Player[playerid][aDuty])
	{
	    ResetWeapons(playerid);
		new gunname[32];
    	GetWeaponName(42, gunname, sizeof(gunname));
		SetPVarInt(playerid, gunname, 999999);
		GivePlayerWeaponAC(playerid, 42, 999999);
	    return 1;
	}
	return 0;
}

CMD:cc(playerid)
{
	if(Player[playerid][pAdmin] > 0)
	{
	    foreach(Player, j)
	    {
	        if(Player[j][pAdmin] < 1)
	        {
			    for( new i; i < 100; i++ )
			    {
			        SendClientMessage(j, -1, " ");
			    }
			    SendClientMessage(j, -1, serverLang[Player[j][pLang]][107]);
			}
			else if(Player[j][pLogged])
			{
			    SendClientMessageFormat(j, -1, "{FFF000}>> Chat has been cleared by %s", Player[playerid][UserName]);
			}
		}
	    //foreach(Player, i) SendClientMessage(i, -1, serverLang[Player[i][pLang]][107]);
	    if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /cc\n```",  Player[playerid][RealName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	    return 1;
	}
	return 0;
}

CMD:bankey(playerid, params[])
{
	if(Player[playerid][pAdmin] > 4)
	{
	    new key[64], serial[41];
	    
    	if(sscanf(params, "s[64]", key))
		{
			SendClientMessage(playerid, -1, "/bankey (key)");
			return 1;
		}
		
		if(strlen(key) <= 38)
		{
		    SendClientMessage(playerid, -1, "/bankey (key)");
			return 1;
		}
		
        foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has blocked the key {FFFFFF}%s!", Player[playerid][UserName], key);
            gpci(i, serial, sizeof(serial));
            if(!strcmp(serial, key, false)) PlayerKick(i);
		}
		
		new query[128];
		mysql_format(Base, query, sizeof(query), "INSERT INTO `machines` (`ID`) VALUE ('%e')", key);
		mysql_tquery(Base, query, "", "", "");
		
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /bankey (Key: %s)\n```",  Player[playerid][RealName], key);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:unbankey(playerid, params[])
{
	if(Player[playerid][pAdmin] > 4)
	{
	    new key[64];
	    
    	if(sscanf(params, "s[64]", key))
		{
			SendClientMessage(playerid, -1, "/unbankey (key)");
			return 1;
		}

		if(strlen(key) <= 38)
		{
		    SendClientMessage(playerid, -1, "/unbankey (key)");
			return 1;
		}

        foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has unbankey the key {FFFFFF}%s!", Player[playerid][UserName], key);
		}

		new query[128];
		mysql_format(Base, query, sizeof(query), "DELETE FROM `machines` WHERE `ID` = '%e'", key);
		mysql_tquery(Base, query, "", "", "");

		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /unbankey (Key: %s)\n```",  Player[playerid][RealName], key);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:banmachine(playerid, params[])
{
	if(Player[playerid][pAdmin] > 4)
	{
    	if(sscanf(params, "i", params[0]))
		{
			SendClientMessage(playerid, -1, "/banmachine (id)");
			return 1;
		}
    	if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAccountID] == 1) return 1;
		if(Player[params[0]][pAdmin] >= Player[playerid][pAdmin] && Player[playerid][pAccountID] != 1) return 1;

        foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s blocked {FFFFFF}%s’s Network card!", Player[playerid][UserName], Player[params[0]][UserName]);

		new query[128], serial[41], IP[16];
		GetPlayerIp(params[0], IP, sizeof(IP));
		gpci(params[0], serial, sizeof(serial));
		BlockIpAddress(IP, 900000);
		
		mysql_format(Base, query, sizeof(query), "INSERT INTO `machines` (`ID`) VALUE ('%e')", serial);
		mysql_tquery(Base, query, "", "", "");
		
		format(serial, sizeof(serial), "banip %s", IP);
        SendRconCommand(serial);
        SendRconCommand("reloadbans");
        
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /banmachine (Key: %s)\n```",  Player[playerid][RealName], serial);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:banip(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
    	if(sscanf(params, "s[24]", params[0])) return SendClientMessage(playerid, -1, "/banip (ip)");

        new query[128];
        format(query, sizeof(query), "banip %s", params[0]);
        SendRconCommand(query);
        SendRconCommand("reloadbans");

    	mysql_format(Base, query, sizeof(query), "INSERT INTO `banip` (`IP`,`build`) VALUE ('%e','"SERVER_BUILD"')", params[0]);
		mysql_tquery(Base, query, "", "", "");

		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][142], Player[playerid][RealName],params[0]);

        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /banip (IP: %s)\n```",  Player[playerid][RealName], params[0]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}

		return 1;
	}
    return 0;
}

fun TryToUnbanIP(playerid, const ip[])
{
    if(cache_num_rows() > 0)
 	{
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][143], Player[playerid][RealName], ip);

        new query[128];
        format(query, 64, "unbanip %s", ip);
		SendRconCommand(query);
		SendRconCommand("reloadbans");

		mysql_format(Base, query, sizeof(query), "DELETE FROM `banip` WHERE `IP` = '%e'", ip);
		mysql_tquery(Base, query, "", "", "");

		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /unbanip (IP: %s)\n```", Player[playerid][RealName], ip);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, "{FF0000}>> This ip address is not blocked");
	}
	return 1;
}

CMD:unbanip(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	    new query[128], ip[16];
    	if(sscanf(params, "s[16]", ip)) return SendClientMessage(playerid, -1, "/unbanip (ip)");
		mysql_format(Base, query, sizeof(query), "SELECT * FROM `banip` WHERE `IP` = '%e'", ip);
	 	mysql_tquery(Base, query, "TryToUnbanIP", "is", playerid, ip);
		return 1;
	}
    return 0;
}

fun TeamBan(playerid, admin, reason[])
{
    if(admin == playerid) return 1;
	if(Player[playerid][pAdmin] >= Player[admin][pAdmin]) return 1;
	new y, reas[64];
	sscanf(reason, "is[64]", y, reas);
    new query[456], serial[64], IP[16], version[64];
	gpci(playerid, serial, sizeof(serial));
	GetPlayerIp(playerid, IP, 16);
	GetPlayerVersion(playerid, version, 64);
	mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`gpci`,`ip`,`build`) VALUES ('%e','%e','%e',1,0,'%e','%e','"SERVER_BUILD"')", Player[playerid][UserName], Player[admin][RealName], MakeReasonFromShort(reas), serial, IP);
	mysql_tquery(Base, query, "", "", "");
	
	mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`version`,`build`,`port`) VALUES ('%d','%e','%e','%d','%d','%d','%e','%e','"SERVER_BUILD"','%d')", Player[playerid][pAccountID], Player[admin][RealName], MakeReasonFromShort(reas), 0, 1, gettime(), Player[playerid][UserName], version, Player[playerid][pPort]);
	mysql_tquery(Base, query, "", "", "");
	
	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == playerid) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][50], Player[playerid][UserName], Player[admin][RealName], MakeReasonFromShort(reas));
    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][51]);
    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][52]);

    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("619186196718944256");
	format(query, sizeof query, "```\n%s has been banned by %s [Reason: %s]\n```", Player[playerid][UserName], Player[admin][RealName], MakeReasonFromShort(reas));
	DCC_SendChannelMessageEx(DiscordChannel, query);
	#endif

    IsBanned{playerid} = true;
    PlayerKick(playerid);
	GivePlayerXP(admin, 10 * Map[m_XPType]);
	//GivePlayerXP(y, 10 * Map[m_XPType]);
	
 	BlockIpAddress(IP, 900000);
	
	foreach(Player, i)
	{
	    BanRequest[i] = -1;
		if(isReported[i][playerid])
		{
			SendClientMessage(i, -1, serverLang[Player[i][pLang]][164]);
			GivePlayerXP(i, 10);
			isReported[i][playerid] = false;
			AchievementAddProgress(i, ach_REPORTED_TIMES);
		}
	}
	return 1;
}

CMD:ban(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
	{
		if(sscanf(params, "is[128]", params[0], params[1])) return SendClientMessage(playerid, -1, "/ban (playerid) (reason)");
        if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}

		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAdmin] >= Player[playerid][pAdmin] && Player[playerid][pAccountID] != 1) return 1;
		
		new query[456], serial[64], IP[16], version[64];
		gpci(params[0], serial, sizeof(serial));
		GetPlayerIp(params[0], IP, 16);
		GetPlayerVersion(params[0], version, 64);
		mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`gpci`,`ip`,`build`) VALUES ('%e','%e','%e',1,0,'%e','%e','"SERVER_BUILD"')", Player[params[0]][UserName],Player[playerid][RealName],MakeReasonFromShort(params[1]), serial, IP);
		mysql_tquery(Base, query, "", "", "");
		
		mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`version`,`build`,`port`) VALUES ('%d','%e','%e','%d','%d','%d','%e','%e','"SERVER_BUILD"','%d')", Player[params[0]][pAccountID], Player[playerid][RealName], MakeReasonFromShort(params[1]), 0, 1, gettime(), Player[params[0]][UserName], version, Player[params[0]][pPort]);
  		mysql_tquery(Base, query, "", "", "");
		
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == params[0]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][50], Player[params[0]][UserName], Player[playerid][RealName], MakeReasonFromShort(params[1]));
  	    SendClientMessage(params[0], -1, serverLang[Player[params[0]][pLang]][51]);
  	    SendClientMessage(params[0], -1, serverLang[Player[params[0]][pLang]][52]);
  	    
  	    #if debug_mode == 0
  	    DiscordChannel = DCC_FindChannelById("619186196718944256");
  		format(query, sizeof query, "```\n%s has been banned by %s [Reason: %s]\n```", Player[params[0]][UserName], Player[playerid][RealName], MakeReasonFromShort(params[1]));
   		DCC_SendChannelMessageEx(DiscordChannel, query);
   		#endif
  	    
  	    IsBanned{params[0]} = true;
  	    PlayerKick(params[0]);
		GivePlayerXP(playerid, 10 * Map[m_XPType]);
	    BlockIpAddress(IP, 900000);
	    
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /ban on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		
		foreach(Player, i)
		{
		    BanRequest[i] = -1;
			if(isReported[i][params[0]])
			{
				SendClientMessage(i, -1, serverLang[Player[i][pLang]][164]);
				GivePlayerXP(i, 10);
				isReported[i][params[0]] = false;
				AchievementAddProgress(i, ach_REPORTED_TIMES);
			}
		}
 		return 1;
	}
	return 0;
}

CMD:tban(playerid, params[])
{
    if(Player[playerid][pAdmin] > 0)
	{
	    if(HighAdminOnline() && Player[playerid][pAdmin] <= 2)
		{
		    SendClientMessage(playerid, -1, "{FF0000}>> This command is not available at the moment, there is an administrator, type this:{FFFFFF} @ban ID reason");
			return 1;
		}
	    new timing[] = { 3, 72 };
        if(sscanf(params, "iis[128]", params[0], params[1], params[2]))
		{
			SendClientMessageFormat(playerid, -1, "/tban (playerid) (1-%d) (reason)", Player[playerid][pAdmin] < 3 ? timing[Player[playerid][pAdmin]-1] : 999);
			return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAdmin] >= Player[playerid][pAdmin]) return 1;
		if(params[1] > ((Player[playerid][pAdmin] < 3) ? timing[Player[playerid][pAdmin]-1] : 999))
		{
		    SendClientMessageFormat(playerid, -1, "/tban (playerid) (1-%d) (reason)", ((Player[playerid][pAdmin] < 3) ? timing[Player[playerid][pAdmin]-1] : 999));
			return 1;
		}
		new query[456], serial[41], IP[16], version[64];
		gpci(params[0], serial, sizeof(serial));
		GetPlayerIp(params[0], IP, 16);
		GetPlayerVersion(params[0], version, 64);
		mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`gpci`,`ip`,`build`) VALUES ('%e','%e','%e',0,'%d','%e','%e','"SERVER_BUILD"')", Player[params[0]][UserName],Player[playerid][RealName],MakeReasonFromShort(params[2]),(params[1]*3600)+gettime(), serial, IP);
		mysql_tquery(Base, query, "", "", "");
		
		mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`version`,`build`,`port`) VALUES ('%d','%e','%e','%d','%d','%d','%e','%e','"SERVER_BUILD"','%d')", Player[params[0]][pAccountID], Player[playerid][RealName], MakeReasonFromShort(params[2]), (params[1]*3600)+gettime(), 0, gettime(), Player[params[0]][UserName], version, Player[params[0]][pPort]);
  		mysql_tquery(Base, query, "", "", "");
		
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || params[0] == i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][49], Player[params[0]][UserName], Player[playerid][RealName], params[1], MakeReasonFromShort(params[2]));
  	    SendClientMessage(params[0], -1, serverLang[Player[params[0]][pLang]][51]);
  	    SendClientMessage(params[0], -1, serverLang[Player[params[0]][pLang]][52]);

        #if debug_mode == 0
        DiscordChannel = DCC_FindChannelById("619186196718944256");
  		format(query, sizeof query, "```\n%s has been banned by %s for %d hour(s) [Reason: %s]\n```", Player[params[0]][UserName], Player[playerid][RealName], params[1], MakeReasonFromShort(params[2]));
   		DCC_SendChannelMessageEx(DiscordChannel, query);
		#endif

		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /tban on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}

        foreach(Player, i)
		{
		    BanRequest[i] = -1;
			if(isReported[i][params[0]])
			{
				SendClientMessage(i, -1, serverLang[Player[i][pLang]][164]);
				GivePlayerXP(i, 10);
				isReported[i][params[0]] = false;
				AchievementAddProgress(i, ach_REPORTED_TIMES);
			}
		}
		IsBanned{params[0]} = true;
		PlayerKick(params[0]);
		BlockIpAddress(IP, 900000);
 		return 1;
	}
	return 0;
}

fun TryToOffTimeBan(playerid, const name[], time, const reason[])
{
    if(cache_num_rows() > 0)
	{
	    new ime, id;
	   	cache_get_value_name_int(0, "Admin", ime);
	   	cache_get_value_name_int(0, "ID", id);
	   	if(Player[playerid][pAdmin] <= ime)
  		{
		  	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][162]);
	    	return 1;
		}
		
		new query[256];
        mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"')", name, Player[playerid][RealName], MakeReasonFromShort(reason), (time*3600)+gettime());
		mysql_tquery(Base, query, "", "", "");

        mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`build`) VALUES ('%d','%e','%e','%d','%d','%d','%e','"SERVER_BUILD"')", id, Player[playerid][RealName], MakeReasonFromShort(reason), (time*3600)+gettime(), 0, gettime(), name);
		mysql_tquery(Base, query, "", "", "");

        #if debug_mode == 0
		DiscordChannel = DCC_FindChannelById("619186196718944256");
  		format(query, sizeof query, "```\n%s has been banned by %s for %d hour(s) [Reason: %s]\n```", name, Player[playerid][RealName], time, MakeReasonFromShort(reason));
   		DCC_SendChannelMessageEx(DiscordChannel, query);
   		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][149], name, Player[playerid][RealName], time, MakeReasonFromShort(reason));
        if(Player[playerid][pAdmin] <= 5)
		{
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /offtban on player %s\n```",  Player[playerid][RealName], name);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
		}
		#endif
	}
	else
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][161]);
	    return 1;
	}
	return 1;
}

CMD:offtban(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
		new name[24], time = 1, reason[128];
        if(sscanf(params, "s[24]is[128]", name, time, reason))
		{
			SendClientMessage(playerid, -1, "/offtban (name) (1-999) (reason)");
			return 1;
		}
		new query[256];
        mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Admin` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "TryToOffTimeBan", "isis", playerid, name, time, reason);
 		return 1;
	}
	return 0;
}

fun TryToOffBan(playerid, const name[], const reason[])
{
    if(cache_num_rows() > 0)
	{
	    new id, query[256];
	    cache_get_value_name_int(0, "ID", id);

	    mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',1,0,'"SERVER_BUILD"')", name, Player[playerid][RealName], MakeReasonFromShort(reason));
		mysql_tquery(Base, query, "", "", "");

		mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`build`) VALUES ('%d','%e','%e','%d','%d','%d','%e','"SERVER_BUILD"')", id, Player[playerid][RealName], MakeReasonFromShort(reason), 0, 0, gettime(), name);
		mysql_tquery(Base, query, "", "", "");

        #if debug_mode == 0
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][148], name, Player[playerid][RealName], MakeReasonFromShort(reason));
        DiscordChannel = DCC_FindChannelById("619186196718944256");
  		format(query, sizeof query, "```\n%s has been banned by %s [Reason: %s]\n```", name, Player[playerid][RealName], MakeReasonFromShort(reason));
   		DCC_SendChannelMessageEx(DiscordChannel, query);
        if(Player[playerid][pAdmin] <= 5)
		{
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /offban on player %s\n```",  Player[playerid][RealName], name);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
		}
		#endif
	}
	else
	{
	    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][161]);
	}
	return 1;
}

ALTX:offban("/banname");
CMD:offban(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	    new name[24], reason[128], query[256];
	    if(sscanf(params, "s[24]s[128]", name, reason)) return SendClientMessage(playerid, -1, "/offban (name) (reason)");
	    mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "TryToOffBan", "iss", playerid, name, reason);
		return 1;
	}
	return 0;
}

ALTX:reconnect("/timeout");
CMD:reconnect(playerid, params[])
{
	if(Player[playerid][pAdmin] <= 1) return 0;
	if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/reconnect (id)");
	if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
    
	new string[32],ip[16];
	GetPlayerIp(params[0], ip, sizeof(ip));
    format(string, sizeof(string), "banip %s", ip);
    SetPVarString(params[0],"reconnect",ip);
    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has reconnected %s", Player[playerid][RealName], Player[params[0]][UserName]);
    reconnect[params[0]] = true;
    
    SendRconCommand(string);
    if(Player[playerid][pAdmin] <= 5)
	{
	    #if debug_mode == 0
        new __action[128];
		DiscordChannel = DCC_FindChannelById("623193667628433438");
		format(__action, sizeof __action, "```\n%s used /reconnect on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		#endif
	}
	return 1;
}

CMD:jetpack(playerid)
{
    if(GetPlayerTeamEx(playerid) == 254)
    {
        SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USEJETPACK);
        return 1;
    }
	if(Player[playerid][pAdmin] > 1)
	{
	    if(Player[playerid][aDuty])
	    {
			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USEJETPACK);
			return 1;
		}
		return 0;
	}
	return 0;
}

/*CMD:makevip(playerid, params[])
{
    if(Player[playerid][pAdmin] > 5)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
		{
			SendClientMessage(playerid, -1, "/makevip (playerid) (level)");
			return 1;
		}
    	if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] < 0 || params[1] > 3)
		{
			SendClientMessage(playerid, -1, "/makevip (playerid) (level)");
			return 1;
		}
		if(params[1] >= 1)
		{
			Player[params[0]][pVip] = params[1];
			Player[params[0]][pVipTime] = gettime() + 2592000;
		}
		else
		{
		    Player[params[0]][pVipTime] = 0;
			Player[params[0]][pVip] = 0;
			new query[128];
			mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `VIP` = '0',`VipTime` = '0' WHERE `ID` = '%d'", Player[params[0]][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
		}
	    return 1;
	}
	return 0;
}*/

fun TechRestart()
{
    --restartTimes;
    if(restartTimes > 0) SetTimer("TechRestart", 1000, 0);

	if(restartTimes == 10)
	{
		SendMessageFormatToAll(-1, "{C0C0C0}>> Preparation for Technical Work, the server will shutdown after %d seconds", restartTimes);
	}
	
	if(restartTimes <= 5 && restartTimes >= 1)
	{
	    SendMessageFormatToAll(-1, "{C0C0C0}>> Preparation for Technical Work, the server will shutdown after %d seconds", restartTimes);
	    foreach(Player, i)
		{
			PlayerPlaySound(i, 0, 0.0, 0.0, 0.0);
			PlayerPlaySound(i, 1056, 0.0, 0.0, 0.0);
		}
	}

	if(restartTimes <= 0)
	{
	    foreach(Player, i) PlayerPlaySound(i, 1039, 0.0, 0.0, 0.0);
		SendClientMessageToAll(-1, "{C0C0C0}>> Expect completion of Technical Work");
		SetGameModeText("Tech. work");
   		SendRconCommand("language Tech. work");
		SendRconCommand("exit");
	}
}

fun Restart()
{
    --restartTimes;
    if(restartTimes > 0) SetTimer("Restart", 1000, 0);

	if(restartTimes == 45)
	{
	    foreach(Player, i)
		{
			switch(Player[i][pLang])
		    {
				case 0:
				{
					GameTextForPlayer(i, "~b~Server will restart after 45 seconds", 5000, 5);
	    			SendClientMessage(i, -1, "{C0C0C0}>> Preparing updates...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Configuration changes in progress...");
	    			
	            }
		        case 1:
				{
     				GameTextForPlayer(i, RusToGame("~b~Сервер будет перезапущен через 45 секунд"), 5000, 5);
	    			SendClientMessage(i, -1, "{C0C0C0}>> Подготовка к перезапуску...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Выполняется изменение конфигураций...");
	            }
		        case 2:
		        {
					GameTextForPlayer(i, "~b~El servidor se reiniciara despues de 45 segundos", 5000, 5);
	    			SendClientMessage(i, -1, "{C0C0C0}>> Preparandose para reiniciar...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Configuration changes in progress...");
	            }
			}
	    }
	}
	
	if(restartTimes == 30)
	{
	    foreach(Player, i)
		{
			switch(Player[i][pLang])
		    {
				case 0:
				{
					GameTextForPlayer(i, "~b~Server will restart after 30 seconds", 5000, 5);
					SendClientMessage(i, -1, "{C0C0C0}>> Shutdown all systems");
	            }
		        case 1:
				{
					GameTextForPlayer(i, RusToGame("~b~Сервер будет перезапущен через 30 секунд"), 5000, 5);
				 	SendClientMessage(i, -1, "{C0C0C0}>> Отключение всех систем");
	            }
		        case 2:
		        {
					GameTextForPlayer(i, "~b~El servidor se reiniciara despues de 30 segundos", 5000, 5);
				 	SendClientMessage(i, -1, "{C0C0C0}>> Shutdown all systems");
	            }
			}
	    }
	}
	
	if(restartTimes == 10)
	{
		SendMessageFormatToAll(-1, "{C0C0C0}>> The server will restart after %d seconds", restartTimes);
	}
	
	if(restartTimes <= 5 && restartTimes >= 1)
	{
	    SendMessageFormatToAll(-1, "{C0C0C0}>> The server will restart after %d seconds", restartTimes);
	    foreach(Player, i)
		{
			PlayerPlaySound(i, 0, 0.0, 0.0, 0.0);
			PlayerPlaySound(i, 1056, 0.0, 0.0, 0.0);
		}
	}
	
	if(restartTimes <= 0)
	{
	    foreach(Player, i) PlayerPlaySound(i, 1039, 0.0, 0.0, 0.0);
		SendClientMessageToAll(-1, "{C0C0C0}>> Reconfiguration...");
		SendRconCommand("gmx");
	}
	return 1;
}

CMD:restart(playerid)
{
    if(Player[playerid][pAdmin] >= 5)
	{
	    CanPay = false;
	    foreach(Player, i) SaveUserData(i);
	    restartTimes = 60;
	    SetTimer("Restart", 1000, 0);
		SaveGangs(true);
		SaveRulesPolicy();
	    foreach(Player, i)
		{
			switch(Player[i][pLang])
		    {
				case 0:
				{
					GameTextForPlayer(i, "~b~Server will restart after 60 seconds", 5000, 5);
				 	SendClientMessage(i, -1, "{C0C0C0}>> Forced restart initiated");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Preparing updates...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Disable Payment Systems...");
	    			
	            }
		        case 1:
				{
					GameTextForPlayer(i, RusToGame("~b~Сервер будет перезапущен через 60 секунд"), 5000, 5);
				 	SendClientMessage(i, -1, "{C0C0C0}>> Инициирован принудительный перезапуск");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Подготовка к перезапуску...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Disable Payment Systems...");
	            }
		        case 2:
		        {
					GameTextForPlayer(i, "~b~El servidor se reiniciara despues de 60 segundos", 5000, 5);
				 	SendClientMessage(i, -1, "{C0C0C0}>> Reinicio forzado iniciado");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Preparandose para reiniciar...");
	    			SendClientMessage(i, -1, "{C0C0C0}>> Disable Payment Systems...");
	            }
			}
	    }
	    return 1;
	}
	return 0;
}

CMD:xp(playerid, params[])
{
    if(Player[playerid][pAdmin] >= 5)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
		{
			SendClientMessage(playerid, -1, "/xp (playerid) (amount)");
			return 1;
		}
    	if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] < 0 )
		{
			SendClientMessage(playerid, -1, "/xp (playerid) (amount)");
			return 1;
		}
		
		/*if(Player[params[0]][IsDefender] > 1 && Player[playerid][pAdmin] <= 5)
		{
		    SendClientMessage(playerid, -1, "SYSTEM: This account cannot get experience.");
			return 1;
		}*/
		
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```css\n%s(%d) used /xp on %s(%d) EXP: %d (Given: %d)\n```", Player[playerid][RealName], Player[playerid][pAccountID], Player[params[0]][RealName], Player[params[0]][pAccountID], Player[params[0]][pXP], params[1]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		Player[params[0]][pXP] += params[1];
		SendClientMessageFormat(playerid, -1, "{FFF000}[XP]>> You're set %s's exp to %d", Player[params[0]][RealName],  Player[params[0]][pXP]);
	    return 1;
	}
	return 0;
}

CMD:aduty(playerid)
{
    if(IsPlayerOnDuel[playerid]) return 0;
    if(IsPlayerInAnyVehicle(playerid)) return 0;
    //if(UserTankInWarState[playerid] >= 1) return 0;
    
	if(Player[playerid][pAdmin] > 0)
	{
	    if(IsSpecing[playerid])
	    {
	    	TogglePlayerSpectating(playerid, 0);
			//SpawnPlayer(playerid);
	    }
	    
	    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
	    Player[playerid][aDuty] =! Player[playerid][aDuty];
		if(Player[playerid][aDuty])
		{
		    ResetWeapons(playerid);
		    if(Player[playerid][pAccountID] == 17) SetPlayerSkinAC(playerid, 211);
		    else SetPlayerSkinAC(playerid, 217);
		    
		    CurePlayer(playerid);
		    setupZombie(playerid);
		    SetPlayerArmour(playerid, 0.0);
	   	    Player[playerid][IsBurned][0] = 0;
    		Player[playerid][IsBurned][1] = 0;
	   	    Player[playerid][Poisioned] = false;
	   	    Player[playerid][IsPlayerAdvancedInfected] = false;
		 	Player[playerid][AntiSeeker] = false;
			Player[playerid][AntiFreeze] = false;
			Player[playerid][AntiRadioctive] = false;
			Player[playerid][AntiBuring] = false;
			Player[playerid][AntiLegBreaks] = false;
			Player[playerid][AntiSpider] = false;
			Player[playerid][AntiScreamer] = false;
			Player[playerid][SlowWalk] = 0;
			Player[playerid][Helmet] = false;
			Player[playerid][Fearlessness] = false;
			Player[playerid][Cursed] = false;
			Player[playerid][hasBleedEffect] = false;
			RemovePlayerAttachedObject(playerid, 4);
		   	RemovePlayerAttachedObject(playerid, 5);
		   	RemovePlayerAttachedObject(playerid, 6);
		    RemovePlayerAttachedObject(playerid, 7);
		   	RemovePlayerAttachedObject(playerid, 8);
		   	RemovePlayerAttachedObject(playerid, 9);
		   	KillTimer(Player[playerid][PoisionTimer]);
			KillTimer(Player[playerid][InfectedTimer]);
			KillTimer(Player[playerid][BleedingTimer]);
		
		    SetPlayerColor(playerid, COLOR_ZOMBIE);
		}
		else
		{
		    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged])  SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][119], Player[playerid][UserName]);
		    ResetWeapons(playerid);
		    SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
            SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
			SpawnPlayer(playerid);
		}
		return 1;
	}
	return 0;
}

CMD:time(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/time (time)");
	    SetWorldTime(params[0]);
	    Map[m_Time] = params[0];
	    return 1;
	}
	return 0;
}

CMD:weather(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
	{
	    if(sscanf(params, "i", params[0])) return SendClientMessage(playerid, -1, "/weather (weather)");
	    SetWeather(params[0]);
	    Map[m_Weather] = params[0];
	    return 1;
	}
	return 0;
}

CMD:v(playerid, params[])
{
    if(Player[playerid][pVip] > 0 || FakeData[playerid][2] > 0)
    {
        new text[128];
        if(sscanf(params, "s[128]", text)) return SendClientMessage(playerid, -1, "/v (text)");

		new i_pos;
		while(text[i_pos])
		{
			if(text[i_pos] == '%') text[i_pos] = '#';
			i_pos++;
		}
		
		if(strfind(text, LastMessage[playerid]) != -1)
	    {
	        if(gettime() > LastMessageTime[playerid])
			{
				LastMessagesTryed[playerid] = 0;
			}
	        else
	        {
	            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
	            ++LastMessagesTryed[playerid];
	            if(LastMessagesTryed[playerid] >= 5)
	            {
	                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
	                PlayerKick(playerid);
	                LastMessagesTryed[playerid] = 0;
	            }
	            return 1;
	        }
	    }
	    strmid(LastMessage[playerid], text, 0, 144, 145);
	    LastMessageTime[playerid] = gettime() + 5;
	
	    //if(GetUnlockedSlot(Player[playerid][pSettings], PS_IAP) == 1 && !ProccessPay(playerid)) return 1;
 		if(CheckForWebsite(text) && PlayerTextType[playerid] <= 999)
	 	{
	 	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s in /v, use /adva %d to send a message", Player[playerid][UserName], text, playerid);
			SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
            strmid(PlayerText[playerid], text, 0, 128, 128);
			PlayerTextType[playerid] = 3;
			return 1;
	 	}
	 	
       	new i_numcount, i_period;
       	i_pos = 0;
        while(text[i_pos])
		{
            if('0' <= text[i_pos] <= '9') i_numcount ++;
            else if(text[i_pos] == '.') i_period ++;
            i_pos++;
        }
        if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
	 	{
	 	    //foreach(Player, i) SendClientMessageFormat(i, -1, "{33CCFF}>> %s has been muted by Server-Bot [Reason: Nice try, stay muted]", Name(playerid));
            //Player[playerid][Muted] = 300;
            foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s in /v, use /adva %d to send a message", Player[playerid][UserName], text, playerid);
			SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
            strmid(PlayerText[playerid], text, 0, 128, 128);
			PlayerTextType[playerid] = 3;
            return 1;
        }
	 	foreach(Player, i) if(Player[i][pVip] > 0) SendClientMessageFormat(i, -1, "{FFA500}[VIP CHAT]: %s(%d): %s", Player[playerid][UserName], playerid, text);
        #if debug_mode == 0
		new msg[200];
	    format(msg, 200, "```[VIP SPY]: %s(%d): %s```", Player[playerid][UserName], playerid, text);
	    DiscordChannel = DCC_FindChannelById("662021492225212447");
	    DCC_SendChannelMessageEx(DiscordChannel, msg);
	    #endif
		return 1;
	}
	return 0;
}

CMD:a(playerid, params[])
{
    if(!Player[playerid][pLogged]) return 0;
	if(Player[playerid][pAdmin] > 0)
	{
	    new message[128];
		if(sscanf(params, "s[128]", message)) return SendClientMessage(playerid, -1, "/a (message)");
        new i_pos;
		while(message[i_pos])
		{
			if(message[i_pos] == '%') message[i_pos] = '#';
			i_pos++;
		}
		if(EmptyMessage(message)) return 1;
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][29], Player[playerid][UserName], playerid, message);
		return 1;
	}
	return 0;
}

CMD:makehuman(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	    if(sscanf(params, "i", params[0]))
	    {
			SendClientMessage(playerid, -1, "/makehuman (playerid)");
			return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(Player[params[0]][aDuty]) return 0;
		SetSpawnInfo(params[0],TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
		ZombieMoveTime[params[0]] = 0;
		Player[params[0]][Jailed] = -1;
		Player[params[0]][eventMember] = -1;
		SetPlayerGravity(params[0], 0.008);
		configureClass(params[0]);
		setupHuman(params[0]);
		SpawnPlayer(params[0]);
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /makehuman on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:makezombie(playerid, params[])
{
    if(Player[playerid][pAdmin] > 2)
	{
	    if(sscanf(params, "i", params[0]))
	    {
			SendClientMessage(playerid, -1, "/makezombie (playerid)");
			return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
		Player[params[0]][Jailed] = -1;
		Player[params[0]][eventMember] = -1;
		SetPlayerGravity(params[0], 0.008);
		configureClass(params[0]);
		setupZombie(params[0]);
		
        SetSpawnInfo(params[0],TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(params[0]);
			
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /makezombie on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:makeem(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
	    {
			SendClientMessage(playerid, -1, "/makeem (playerid) (1-0)");
			return 1;
		}
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] >= 1 && GetUnlockedSlot(Player[params[0]][pSettings], 29) == 0) SetUnlockedSlot(Player[params[0]][pSettings], 29, params[1] < 0 ? 0 : params[1] > 1 ? 1 : params[1]);
		if(params[1] <= 0 && GetUnlockedSlot(Player[params[0]][pSettings], 29) == 1) SetUnlockedSlot(Player[params[0]][pSettings], 29, 0);
	}
	return 1;
}

CMD:zombie(playerid)
{
     if(GetUnlockedSlot(Player[playerid][pSettings], 17) >= 1)
     {
        SendClientMessage(playerid, -1, "{FF0000}>> Always zombie");
		Player[playerid][pYouTuber] = 1;
        return 1;
     }
     return 0;
}

CMD:human(playerid)
{
     if(GetUnlockedSlot(Player[playerid][pSettings], 17) >= 1)
     {
        SendClientMessage(playerid, -1, "{FF0000}>> Always human");
        Player[playerid][pYouTuber] = 2;
        return 1;
     }
     return 0;
}

CMD:makegm(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
	    {
			SendClientMessage(playerid, -1, "/makecm (playerid) (1-0)");
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] >= 1 && GetUnlockedSlot(Player[params[0]][pSettings], 25) == 0)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s appointed a new Gang Manager %s", Player[playerid][RealName], Player[params[0]][UserName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 25, params[1] < 0 ? 0 : params[1] > 1 ? 1 : params[1]);
		}
		if(params[1] <= 0 && GetUnlockedSlot(Player[params[0]][pSettings], 25) == 1)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been fired from Gang Manager by %s", Player[params[0]][UserName], Player[playerid][RealName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 25, 0);
		}
	}
	return 1;
}

CMD:makeinv(playerid, params[])
{
    if(Player[playerid][pAdmin] > 3)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
	    {
			SendClientMessage(playerid, -1, "/makeinv (playerid) (1-0)");
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(Player[params[0]][pAdmin] > 3 || Player[params[0]][pAdmin] <= 2) return 1;
		if(params[1] >= 1 && GetUnlockedSlot(Player[params[0]][pSettings], 30) == 0)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s appointed a new Investigator %s", Player[playerid][RealName], Player[params[0]][UserName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 30, params[1] < 0 ? 0 : params[1] > 1 ? 1 : params[1]);
		}
		if(params[1] <= 0 && GetUnlockedSlot(Player[params[0]][pSettings], 30) == 1)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been fired from Investigators Team by %s", Player[params[0]][UserName], Player[playerid][RealName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 30, 0);
		}
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /makeinv on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	}
	return 1;
}

CMD:makeadmin(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    if(sscanf(params, "ii", params[0], params[1]))
	    {
			SendClientMessage(playerid, -1, "/makeadmin (playerid) (1-4)");
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAdmin] > 4) return 1;
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(params[1] < 1 || params[1] > 4)
		{
			SendClientMessage(playerid, -1, "/makeadmin (playerid) (1-4)");
			return 1;
		}
		
		if(params[1] == 4 && GetUnlockedSlot(Player[params[0]][pSettings], 30) == 1)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been fired from Investigators Team by %s", Player[params[0]][UserName], Player[playerid][RealName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 30, 0);
		}
		
		Player[params[0]][pAdmin] = params[1];
        foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][31], Player[playerid][RealName], AdminRanks[Player[i][pLang]][Player[params[0]][pAdmin]-1], Player[params[0]][UserName]);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /makeadmin on player %s\n```",  Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:getinfo(playerid,params[])
{
    if(Player[playerid][pAdmin] <= 0) return 0;
	if(sscanf(params,"i", params[0]))
	{
		SendClientMessage(playerid,-1,"/getinfo (id)");
		return 1;
	}
	if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(!Player[params[0]][pLogged])
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	new Float: info[2], ip[16], vip[18];
	switch(Player[params[0]][pVip])
	{
	    case 0: vip = "No";
	    case 1: vip = "Bronze(1)";
	    case 2: vip = "Silver(2)";
	    case 3: vip = "Gold(3)";
	}
	new GunName[47][20] =
	{
	    "Fist","Brass Knuckles","Golf Club","Nightstick","Knife","Basebal Bat","Shovel","Pool Cue","Katana","Chainsaw","Double-ended Dildo","Dildo","Vibrator",
	    "Silver Vibrator","Flowers","Cane","Grenade","Tear Gas","Molotv Cocktail","?","?","?","9mm","Silenced 9mm","Desert Eagle","Shotgun","Sawnoff-Shotgun",
	    "Combat Shotgun","Micro-SMG","MP5","Ak-47","M4","Tec9","Country Rifle","Sniper Rifle","RPG","HS-RPG","Flame-Thrower","Minigun","Satchel Charge","Detonator",
	    "Spray Can","Fire Extinguisher","Camera","Night Goggles","Thermal Goggles","Parachute"
	};
	
	new y, m, d, h, i, s;
	TimestampToDate(Player[params[0]][pRegDate], y, m, d, h, i, s, 3);
	
	GetPlayerIp(params[0],ip,sizeof(ip));
	SendClientMessageFormat(playerid, -1, "{33CCFF}>> %s's Information (IP %s) (Last IP: %s)", Player[params[0]][UserName], ip, Player[params[0]][pLastIP]);
	SendClientMessageFormat(playerid, -1,"{cdcdcd}>> Registered IP (%s) (Date: %02dD/%02dM/%04dY)", Player[params[0]][pIP], d, m, y);
    SendClientMessageFormat(playerid, -1, "{FFF000}>> VPN: %s {FFFFFF}| ISP: %s", (IsUsingProxy{params[0]}) ? ("{99ff99}Yes") : ("{FF0000}No"), Player[params[0]][p_ISP]);
	//new ph, pd, pm;
	//TimestampToDate(gettime(), y, pm, pd, ph, i, s, 3);
	//SendClientMessageFormat(playerid, -1,"{cdcdcd}>> Playing %d Hours - %d Days - %d Months", ph-h > 0 ? ph-h : 0, pd - d > 0 ? pd-d : 0, pm - m > 0 ? pm-m : 0);
	GetPlayerHealth(params[0],info[0]);
	GetPlayerArmour(params[0],info[1]);
	new vtl[64], ghbs[64], gabs[64], gmbs[64];
	vtl = "";
	gmbs = "";
	ghbs = "";
	gabs = "";
	
	SendClientMessageFormat(playerid, -1, ">> Health: %.2f%s%s - Armour: %.2f%s", info[0], vtl, ghbs, info[1], gabs);
 	SendClientMessageFormat(playerid, -1, ">> EXP: %d - Money: %d", Player[params[0]][pXP], GetPlayerMoney(params[0]));
  	SendClientMessageFormat(playerid, -1, ">> Spawned: %s - S0beit: %s", Player[params[0]][pLogged] == false ? ("No") : ("Yes"), S0beitSuspecting[params[0]] >= 2 ? ("{FF0000}Yes") : S0beitSuspecting[params[0]] == 1 ? ("{FFF000}Suspected") : ("No"));
	new version[24];
	GetPlayerVersion(params[0], version, 24);
	SendClientMessageFormat(playerid, -1, ">> Country: %s - Version: %s", GetPlayerCountry(params[0]), version);
	if(GetPlayerTeamEx(params[0]) == TEAM_ZOMBIE && Player[params[0]][pClass][TEAM_ZOMBIE+1] < sizeof(zombieClassesListNames[])) SendClientMessageFormat(playerid, -1, ">> Team: Zombie - Class: %s", zombieClassesListNames[Player[playerid][pLang]][Player[params[0]][pClass][TEAM_ZOMBIE+1]]);
    if(GetPlayerTeamEx(params[0]) == TEAM_ZOMBIE && Player[params[0]][pClass][TEAM_ZOMBIE+1] > sizeof(zombieClassesListNames[])) SendClientMessageFormat(playerid, -1, ">> Team: Zombie - Class: %s", zombieVIPCl[Player[playerid][pLang]][Player[params[0]][pClass][TEAM_ZOMBIE+1]-5000]);
	if(GetPlayerTeamEx(params[0]) == TEAM_HUMAN && Player[params[0]][pClass][TEAM_HUMAN] < sizeof(humanClassesListNames[])) SendClientMessageFormat(playerid, -1, ">> Team: Human - Class: %s %s", humanClassesListNames[Player[playerid][pLang]][Player[params[0]][pClass][TEAM_HUMAN]], (HumanHumanBoss[params[0]]) ? ("{FFF000}(Human Hero)") : (" "));
    if(GetPlayerTeamEx(params[0]) == TEAM_HUMAN && Player[params[0]][pClass][TEAM_HUMAN] > sizeof(humanClassesListNames[])) SendClientMessageFormat(playerid, -1, ">> Team: Human - Class: %s %s", humanVIPCl[Player[playerid][pLang]][Player[params[0]][pClass][TEAM_HUMAN]-5000], (HumanHumanBoss[params[0]]) ? ("{FFF000}(Human Hero)") : (" "));

	if(Player[params[0]][pAdmin] > 0 && Player[params[0]][pLogged]) SendClientMessageFormat(playerid, -1, ">> V.I.P: %s - Admin: %s", vip, AdminRanks[0][Player[params[0]][pAdmin]-1]);
	else SendClientMessageFormat(playerid, -1, ">> V.I.P: %s - Admin: No", vip);
	
	new slot, weap[14], ammo[14];
    for ( slot = 0; slot < 14; slot++ )
    {
        GetPlayerWeaponData(params[0],slot,weap[slot],ammo[slot]);
        if(ammo[slot] >= 1)
        {
			SendClientMessageFormat(playerid, -1, ">> Weapon: %s - Ammo: %d%s", GunName[weap[slot]], ammo[slot], gmbs);
		}
	}
	if(Player[params[0]][pClan] > 0)
	{
		SendClientMessageFormat(playerid, -1, ">> Clan: (ID %d)(Rank: %d)", Player[params[0]][pClan],Player[params[0]][pClanRank]);
	}
	SendClientMessageFormat(playerid, -1, "{cdcdcd}>> Packets lost: %.2f", NetStats_PacketLossPercent(params[0]));
	if(Player[playerid][pAdmin] <= 5)
	{
	    #if debug_mode == 0
        new __action[128];
		DiscordChannel = DCC_FindChannelById("623193667628433438");
		format(__action, sizeof __action, "```\n%s used /getinfo on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
		DCC_SendChannelMessageEx(DiscordChannel, __action);
		#endif
	}
	return 1;
}

CMD:report(playerid, params[])
{
	new message[64];
	if(sscanf(params, "is[64]", params[0], message))
 	{
 	    SendClientMessage(playerid, -1, "/report (id) (reason)");
		return 1;
	}
	if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(strlen(message) >= 16)
	{
	    SendClientMessage(playerid, -1, "{FF0000}>> The report's text is too long!");
		return 1;
	}
	new i_pos;
	while(message[i_pos])
	{
		if(message[i_pos] == '%') message[i_pos] = '#';
		i_pos++;
	}
	if(strfind(message, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 0;
        }
    }
    strmid(LastMessage[playerid], message, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;
    
    if(!isReported[playerid][params[0]])
	{
	    if(AntiCheatAlertMode) AC_CompareScales(playerid, params[0], message);
		reportsCount++;
	}
    
	foreach(Player, i)
	{
		if(Player[i][pAdmin] > 0 && Player[i][pLogged])
		{
			SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][144], Player[playerid][UserName], playerid, Player[params[0]][UserName], params[0], message, reportsCount);
			GameTextForPlayer(i, "REPORT++", 3000, 1);
		}
	}
	
    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][147]);
    if(reportsCount > 1)
    {
	    switch(Player[playerid][pLang])
	    {
	        case 0: SendClientMessageFormat(playerid, -1, "{33CCFF}You are %d in line, Wait for other reports to be processed!", reportsCount);
	        case 1: SendClientMessageFormat(playerid, -1, "{33CCFF}Вы %d в очереди, Подождите пока другие жалобы будут обработаны!", reportsCount);
	        case 2: SendClientMessageFormat(playerid, -1, "{33CCFF}Eres %d en linea, Espere a que se procesen otras quejas!", reportsCount);
		}
    }
    isReported[playerid][params[0]] = true;
    
    if(!AdminOnline())
    {
        #if debug_mode == 0
	    DiscordChannel = DCC_FindChannelById("614695417635930115");
		new str[200];
		format(str, sizeof(str), "```yaml\nHEY, WAKE UP!\n%s(%d) has reported %s(%d) [Reason: %s]\n```", Player[playerid][UserName], playerid, Player[params[0]][UserName], params[0], message);
		DCC_SendChannelMessageEx(DiscordChannel, str);

		DiscordChannel = DCC_FindChannelById("613185790683513003");
	    format(str, sizeof(str), "```yaml\nHEY, WAKE UP!\n%s(%d) has reported %s(%d) [Reason: %s]\n```", Player[playerid][UserName], playerid, Player[params[0]][UserName], params[0], message);
		DCC_SendChannelMessageEx(DiscordChannel, str);
		#endif
	}
	return 1;
}

fun TryToDemoteAdmin(playerid, const name[])
{
    if(cache_num_rows() > 0)
	{
	    new time;
	   	cache_get_value_name_int(0, "Admin", time);
	   	if(Player[playerid][pAdmin] <= time)
  		{
		  	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][162]);
	    	return 1;
		}
		else
		{
		    new query[256];
		    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Admin`='0' WHERE `Name`='%e' AND `build`='"SERVER_BUILD"'", name);
			mysql_tquery(Base, query, "", "", "");
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][150], Player[playerid][RealName], name);
		}
	}
	else
	{
        SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][161]);
	    return 1;
	}
	return 1;
}

CMD:demote(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    new name[24];
        if(sscanf(params, "s[24]", name))
		{
			SendClientMessage(playerid, -1, "/demote (name)");
			return 1;
		}
		if(!strcmp(name, Player[playerid][UserName]))
		{
		    SendClientMessage(playerid, -1, "/demote (name)");
			return 1;
		}
		new query[256];
		mysql_format(Base, query, sizeof(query), "SELECT `Admin` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "TryToDemoteAdmin", "is", playerid, name);
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /demote on player %s\n```", Player[playerid][RealName], name);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	 	return 1;
	}
	return 0;
}

fun TryToMakeAdminOffline(playerid, const name[], level)
{
    if(cache_num_rows() > 0)
	{
	    new time;
	   	cache_get_value_name_int(0, "Admin", time);
	   	if(Player[playerid][pAdmin] <= time)
  		{
		  	SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][162]);
	    	return 1;
		}
		else
		{
 			new query[256];
 			mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Admin`='%d' WHERE `Name`='%e' AND `build`='"SERVER_BUILD"'", level, name);
			mysql_tquery(Base, query, "", "", "");
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][163], Player[playerid][RealName], AdminRanks[Player[i][pLang]][level-1], name);
		}
	}
	else
	{
        SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][161]);
	}
	return 1;
}

CMD:offmakeadmin(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    new name[25];
        if(sscanf(params, "s[25]i", name, params[0]))
		{
			SendClientMessage(playerid, -1, "/offmakeadmin (name) (1-4)");
			return 1;
		}
		if(params[0] < 1 || params[0] > 4)
		{
			SendClientMessage(playerid, -1, "/offmakeadmin (name) (1-4)");
			return 1;
		}
		if(!strcmp(name, Player[playerid][UserName]))
		{
		    SendClientMessage(playerid, -1, "/offmakeadmin (name) (1-4)");
			return 1;
		}

		new query[256];
		mysql_format(Base, query, sizeof(query), "SELECT `Admin` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
		mysql_tquery(Base, query, "TryToMakeAdminOffline", "isi", playerid, name, params[0]);
		
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /offmakeadmin on player %s\n```", Player[playerid][RealName], name);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	 	return 1;
	}
	return 0;
}

CMD:fire(playerid, params[])
{
    if(Player[playerid][pAdmin] > 4)
	{
	    if(sscanf(params, "is[128]", params[0], params[1]))
	    {
			SendClientMessage(playerid, -1, "/fire (playerid) (reason)");
			return 1;
		}
		if(params[0] == playerid) return 1;
		if(Player[params[0]][pAdmin] > 4) return 1;
		if(!IsPlayerConnected(params[0]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		if(Player[params[0]][pAdmin] < 1)
		{
			SendClientMessage(playerid, -1, "/fire (playerid) (reason)");
			return 1;
		}
		if(params[1] == 4 && GetUnlockedSlot(Player[params[0]][pSettings], 30) == 1)
		{
			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has been fired from Investigators Team by %s", Player[params[0]][UserName], Player[playerid][RealName]);
            SetUnlockedSlot(Player[params[0]][pSettings], 30, 0);
		}
		SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][32], Player[playerid][RealName], AdminRanks[Player[i][pLang]][Player[params[0]][pAdmin]-1], Player[params[0]][UserName], params[1]);
        Player[params[0]][pAdmin] = 0;
        if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /fire on player %s\n```", Player[playerid][RealName], Player[params[0]][UserName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
        return 1;
	}
	return 0;
}

CMD:ignore(playerid, params[])
{
    if(sscanf(params, "i", params[0]))
	{
		SendClientMessage(playerid, -1, "/ignore (playerid)");
		return 1;
	}
	if(params[0] == playerid) return 1;
    if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(Player[playerid][pIgnore][params[0]])
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][16]);
		return 1;
	}
	Player[playerid][pIgnore][params[0]] = true;
	SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][17], Player[params[0]][UserName]);
	return 1;
}

CMD:unignore(playerid, params[])
{
    if(sscanf(params, "i", params[0]))
	{
		SendClientMessage(playerid, -1, "/unignore (playerid)");
		return 1;
	}
	if(params[0] == playerid) return 1;
    if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(!Player[playerid][pIgnore][params[0]]) return 1;
	Player[playerid][pIgnore][params[0]] = false;
	return 1;
}

stock datetime_to_unix(year, month, day, hour, minute, second)
{
	new jday = 367 * year - 7 * (year + (month + 9) / 12) / 4 - 3 * ((year + (month - 9) / 7) / 100 + 1) / 4 + 275 * month / 9 + day + 1721029 - 2440588;
	return jday * 86400 + hour * 3600 + minute * 60 + second;
}

CMD:trade(playerid, params[])
{
    if(Player[playerid][Muted] > 0)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][112]);
		return 0;
	}
	new message[128];
	if(sscanf(params, "s[128]", message)) return SendClientMessage(playerid, -1, "/trade (text)");

 	new i_pos;
	while(message[i_pos])
	{
		if(message[i_pos] == '%') message[i_pos] = '#';
		i_pos++;
	}

	if(strfind(message, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 1;
        }
    }
    strmid(LastMessage[playerid], message, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;

	if(CheckForWebsite(message))
	{
		SendClientMessage(playerid, -1, "{FFF000}>> Error while sending a message");
		return 1;
 	}

	new i_numcount, i_period;
	i_pos = 0;
    while(message[i_pos])
	{
        if('0' <= message[i_pos] <= '9') i_numcount ++;
        else if(message[i_pos] == '.') i_period ++;
        i_pos++;
    }
    if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
 	{
		SendClientMessage(playerid, -1, "{FFF000}>> Too much numbers, use words instead");
        return 1;
    }
	SendMessageFormatToAll(-1, "{ff4dc4}[TRADE]: %s: %s", Player[playerid][UserName], message);
	return 1;
}

CMD:ask(playerid, params[])
{
    if(Player[playerid][Muted] > 0)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][112]);
		return 0;
	}
	new message[128];
	if(sscanf(params, "s[128]", message)) return SendClientMessage(playerid, -1, "/ask (question)");

 	new i_pos;
	while(message[i_pos])
	{
		if(message[i_pos] == '%') message[i_pos] = '#';
		i_pos++;
	}

	if(strfind(message, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 1;
        }
    }
    strmid(LastMessage[playerid], message, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;

	if(CheckForWebsite(message))
	{
		SendClientMessage(playerid, -1, "{FFF000}>> Error while sending a message");
		return 1;
 	}

	new i_numcount, i_period;
	i_pos = 0;
    while(message[i_pos])
	{
        if('0' <= message[i_pos] <= '9') i_numcount ++;
        else if(message[i_pos] == '.') i_period ++;
        i_pos++;
    }
    if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
 	{
		SendClientMessage(playerid, -1, "{FFF000}>> Too much numbers, use words instead");
        return 1;
    }

	SendMessageFormatToAll(-1, "{ff80ff}>> %s(%d) asked a Question: %s", Player[playerid][UserName], playerid, message);
	return 1;
}

CMD:r(playerid, params[])
{
    if(lmrf[playerid] == INVALID_PLAYER_ID || lmrf[playerid] >= MAX_PLAYERS || !IsPlayerConnected(lmrf[playerid])) return 1;

    if(Player[playerid][Muted] > 0)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][112]);
		return 0;
	}
	new message[128];
	if(sscanf(params, "s[128]", message)) return SendClientMessage(playerid, -1, "/r (message)");

	new i_pos;
	while(message[i_pos])
	{
		if(message[i_pos] == '%') message[i_pos] = '#';
		i_pos++;
	}

	if(strfind(message, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 1;
        }
    }
    strmid(LastMessage[playerid], message, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;

	if(!IsPlayerConnected(lmrf[playerid]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}

	if(!Player[lmrf[playerid]][pLogged]) return 1;
	if(Player[lmrf[playerid]][pIgnore][playerid] || GetUnlockedSlot(Player[lmrf[playerid]][pSettings], PS_BLOCK_PMS) == 1)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][18]);
		return 1;
	}
	
	if(CheckForWebsite(message))
	{
	    if(lmrf[playerid] == INVALID_PLAYER_ID || lmrf[playerid] >= MAX_PLAYERS)
	    {
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}

		if(!IsPlayerConnected(lmrf[playerid]))
		{
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
			return 1;
		}
		SendClientMessage(playerid, -1, "{FFF000}>> Message cannot be sent, error");
		return 1;
 	}

	new i_numcount, i_period;
	i_pos = 0;
    while(message[i_pos])
	{
        if('0' <= message[i_pos] <= '9') i_numcount ++;
        else if(message[i_pos] == '.') i_period ++;
        i_pos++;
    }
    
    if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
 	{
		SendClientMessage(playerid, -1, "{FFF000}>> Too much numbers, use words instead");
        return 1;
    }

    SendClientMessageFormat(lmrf[playerid], -1, serverLang[Player[lmrf[playerid]][pLang]][19], Player[playerid][UserName], playerid, message);
	SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][20], Player[lmrf[playerid]][UserName], lmrf[playerid], message);

	foreach(Player, i)
    {
        if(Player[i][CanSpyPM] && i != lmrf[playerid] && i!= playerid)
        {
            SendClientMessageFormat(i, -1, "{B8CFDB}>> [PM SPY]: %s(%d) to %s(%d):{FFFFFF} %s", Player[playerid][UserName], playerid, Player[lmrf[playerid]][UserName], lmrf[playerid], message);
        }
	}
	PlayerPlaySound(lmrf[playerid], 1056, 0.0, 0.0, 0.0);

	#if debug_mode == 0
	new __action[200], y, m, d, h, minutes, s;
	TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
	DiscordChannel = DCC_FindChannelById("662009556817149962");
	format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d %s(%d) reply to %s(%d) (Message: %s)\n```", d, m, y, h, minutes, Player[playerid][RealName], Player[playerid][pAccountID], Player[lmrf[playerid]][UserName], Player[lmrf[playerid]][pAccountID], message);
	DCC_SendChannelMessageEx(DiscordChannel, __action);
	#endif
	return 1;
}

ALTX:r("/reply");

CMD:pm(playerid, params[])
{
    if(Player[playerid][Muted] > 0)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][112]);
		return 0;
	}
	new message[128];
	if(sscanf(params, "is[128]", params[0], message)) return SendClientMessage(playerid, -1, "/pm (playerid) (message)");
    
	new i_pos;
	while(message[i_pos])
	{
		if(message[i_pos] == '%') message[i_pos] = '#';
		i_pos++;
	}
	
	if(strfind(message, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 1;
        }
    }
    strmid(LastMessage[playerid], message, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;
	
	if(!IsPlayerConnected(params[0]))
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][15]);
		return 1;
	}
	if(!Player[params[0]][pLogged]) return 1;
	if(Player[params[0]][pIgnore][playerid] || GetUnlockedSlot(Player[params[0]][pSettings], PS_BLOCK_PMS) == 1)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][18]);
		return 1;
	}
	
	//if(GetUnlockedSlot(Player[playerid][pSettings], PS_IAP) == 1 && !ProccessPay(playerid)) return 1;
	if((CheckForWebsite(message)) && PlayerTextType[playerid] <= 999)
	{
 	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s in /pm, use /adva %d to send a message", Player[playerid][UserName], message, playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
		new st[6];
		format(st, 6, "%d ", params[0]);
		strins(message, st, 0);
        strmid(PlayerText[playerid], message, 0, 128, 128);
		PlayerTextType[playerid] = 2;
		return 1;
 	}
	
	new i_numcount, i_period;
	i_pos = 0;
    while(message[i_pos])
	{
        if('0' <= message[i_pos] <= '9') i_numcount ++;
        else if(message[i_pos] == '.') i_period ++;
        i_pos++;
    }
    if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
 	{
 	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s in /pm, use /adva %d to send a message", Player[playerid][UserName], message, playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
		new st[6];
		format(st, 6, "%d ", params[0]);
		strins(message, st, 0);
        strmid(PlayerText[playerid], message, 0, 128, 128);
		PlayerTextType[playerid] = 2;
        return 1;
    }
	
	SendClientMessageFormat(params[0], -1, serverLang[Player[params[0]][pLang]][19], Player[playerid][UserName], playerid, message);
	SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][20], Player[params[0]][UserName], params[0], message);
	lmrf[params[0]] = playerid;
	
	SetTimerEx("CreateDisplayInfo", 30, 0, "iffifffi", params[0], 1024.0, 354.9375, 12, 480.000, 354.9375, 10.0, 2000);
	
 	foreach(Player, i)
    {
        if(Player[i][CanSpyPM] && i != params[0] && i!= playerid)
        {
            SendClientMessageFormat(i, -1, "{B8CFDB}>> [PM SPY]: %s(%d) to %s(%d):{FFFFFF} %s", Player[playerid][UserName], playerid, Player[params[0]][UserName], params[0], message);
        }
	}
	
	#if debug_mode == 0
	new __action[200], y, m, d, h, minutes, s;
	TimestampToDate(gettime(), y, m, d, h, minutes, s, 3);
	DiscordChannel = DCC_FindChannelById("662009556817149962");
	format(__action, sizeof __action, "```\n%02d/%02d/%04d %02d:%02d %s(%d) to %s(%d) (Message: %s)\n```", d, m, y, h, minutes, Player[playerid][RealName], Player[playerid][pAccountID], Player[params[0]][UserName], Player[params[0]][pAccountID], message);
	DCC_SendChannelMessageEx(DiscordChannel, __action);
	#endif
	
	PlayerPlaySound(params[0], 1056, 0.0, 0.0, 0.0);
	return 1;
}

CMD:pmspy(playerid)
{
	if(Player[playerid][pAdmin] > 4)
	{
	    Player[playerid][CanSpyPM] =! Player[playerid][CanSpyPM];
	    if(Player[playerid][CanSpyPM]) SendClientMessage(playerid, -1, "{FFA500}PM SPY is {FFFFFF}ON");
	    else SendClientMessage(playerid, -1, "{FFA500}PM SPY is {FFFFFF}OFF");
	    if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /pmspy\n```",  Player[playerid][RealName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	    return 1;
	}
    return 0;
}

CMD:cmdcheck(playerid)
{
	if(Player[playerid][pAdmin] > 3)
	{
	    Player[playerid][CanCheckCMD] =! Player[playerid][CanCheckCMD];
	    if(Player[playerid][CanCheckCMD]) SendClientMessage(playerid, -1, "{FFA500}CMD CHECKER is {FFFFFF}ON");
	    else SendClientMessage(playerid, -1, "{FFA500}CMD CHECKER is {FFFFFF}OFF");
	    if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
	        new __action[128];
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(__action, sizeof __action, "```\n%s used /cmdcheck\n```",  Player[playerid][RealName]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif
		}
	    return 1;
	}
    return 0;
}

CMD:class(playerid, const params[])
{
	if(strlen(params) > 1)
	{
	    new i;
	    for( i = 0; i < sizeof(svrCLHXP); i++ )
	    {
	        if(strfind(params, humanClassesListNames[0][i], true) != -1)
	        {
	            if(Player[playerid][pXP] >= svrCLHXP[i] || gettime() < PlayerClassUnlocked[playerid][TEAM_HUMAN][i])
		 		{
		 		    /*if(i == FIREMANIAC && GetWeekDay() == GANG_WARS_DAY)
				 	{
					 	i = CIVILIAN;
					 	SendClientMessage(playerid, -1, "{FF0000}>>You cannot select this class, select it tomorrow");
					}*/
		 		    if(!Player[playerid][pWasGangAffected]) setPlayerClass(playerid, i, TEAM_HUMAN);
		 		    else SendClientMessage(playerid, -1, "{FFF000}>> You are too wounded to change class");
		 		}
		 		else
				{
				    ShowExpError(playerid, svrCLHXP[i]);
				}
	            return 1;
	        }
	    }
	    
	    for( i = 0; i < sizeof(svrCLZXP); i++ )
	    {
	        if(strfind(params, zombieClassesListNames[0][i], true) != -1)
	        {
	            if(Player[playerid][pXP] >= svrCLZXP[i] || gettime() < PlayerClassUnlocked[playerid][TEAM_ZOMBIE][i])
		 		{
		 		    /*if(PlayerClassBought[playerid][TEAM_ZOMBIE][i] <= 0)
				    {
				        ShowDialogBuyClass(playerid, i, TEAM_ZOMBIE);
				        byingClass[playerid][0] = i;
	            		byingClass[playerid][1] = TEAM_ZOMBIE;
						return 1;
					}*/
			 		setPlayerClass(playerid, i, TEAM_ZOMBIE);
		 		}
		 		else
			 	{
				 	ShowExpError(playerid, svrCLZXP[i]);
				}
	            return 1;
	        }
	    }
	    ShowPlayerDialog(playerid, DIALOG_CLASSES, DIALOG_STYLE_LIST, serverLang[Player[playerid][pLang]][7], serverLang[Player[playerid][pLang]][8], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);
	}
	else ShowPlayerDialog(playerid, DIALOG_CLASSES, DIALOG_STYLE_LIST, serverLang[Player[playerid][pLang]][7], serverLang[Player[playerid][pLang]][8], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);
	return 1;
}

//CMD:language(playerid) return ShowPlayerDialog(playerid, DIALOG_LANGUAGE, DIALOG_STYLE_LIST, serverLang[Player[playerid][pLang]][2], serverLang[Player[playerid][pLang]][3], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);

public OnPlayerRequestClass(playerid, classid)
{
    SetPlayerHealthAC(playerid, 100.0);
    SetPlayerArmourAC(playerid, 0.0);
    CurePlayer(playerid);

	/*if(!SelectReward[playerid])
	{
		SetPlayerTime(playerid, 0, 0);
		SetPlayerWeather(playerid, 8);
		SetPlayerPosAC(playerid, 2481.5100, 926.8403, 10.3255);
		SetPlayerCameraPos(playerid, 2473.7588, 931.9109, 14.0419);
		SetPlayerCameraLookAt(playerid, 2474.6667, 931.4795, 14.2678);
		SetPlayerSkinAC(playerid, 181);
	}
	else
	{*/
    SetPlayerPosAC(playerid, 2415.5414,-50.4586,28.1535);
	SetPlayerFacingAngle(playerid, 1.4218);
	SetPlayerCameraPos(playerid, 2415.7615, -45.1561, 28.8247);
	SetPlayerCameraLookAt(playerid, 2415.7559, -46.1539, 28.6447);
	SetPlayerSkinAC(playerid, 181);
	//}
	if(!IsOnRegister[playerid] && !Player[playerid][pLogged]) { CheckForPlayerExists(playerid); IsOnRegister[playerid] = true; }
	
	return 1;
}

fun TooMuchTimeOfThinking(playerid)
{
	//TODO Translate and send to all
	if(!Player[playerid][pLogged])
	{
	    foreach(Player, i)
	    {
	        switch(Player[i][pLang])
	        {
	    		case 0: SendClientMessageFormat(i, -1, "{33CCFF}>> %s has been kicked [Reason: Exceeded time for logging in]", Player[playerid][UserName]);
				case 1: SendClientMessageFormat(i, -1, "{33CCFF}>> Игрок %s был кикнут [Причина: Превышено время для авторизации]", Player[playerid][UserName]);
                case 2: SendClientMessageFormat(i, -1, "{33CCFF}>> %s ha sido expulsado [Motivo: Tiempo excedido para iniciar sesion]", Player[playerid][UserName]);
			}
		}
		PlayerKick(playerid);
	}
}

fun GetLeadersActivity()
{
    if(cache_num_rows())
	{
	    #if debug_mode == 0
	    new str[200], id, Name[MAX_PLAYER_NAME+1], c, d, online_t[25];
	    DiscordChannel = DCC_FindChannelById("667021505846312960");
	    for( new i = 0; i < cache_num_rows(); i++ )
	    {
		    cache_get_value_name_int(i, "ID", id);
			cache_get_value_name(i, "Name", Name, MAX_PLAYER_NAME+1);
			cache_get_value_name_int(i, "Clan", c);
			cache_get_value_name_int(i, "ClanRank", d);
            cache_get_value_name(i, "lalog", online_t, 25);
   			format(str, sizeof(str), "```\n(GANG #%d) %s(%d) - Rank: %d - Last Login: %s\n```", c, Name, id, d, online_t);
		 	DCC_SendChannelMessageEx(DiscordChannel, str);
		}
		#endif
	}
	return 1;
}

fun GetAdminsActivity(mnt, type)
{
	if(cache_num_rows())
	{
	    new i, n[25], a, id, query[164], year;
	    getdate(year, _, _);
	    
		for( i = 0; i < cache_num_rows(); i++ )
		{
		    cache_get_value_name_int(i, "ID", id);
		    cache_get_value_name(i, "Name", n, 25);
		    cache_get_value_name_int(i, "Admin", a);
		    
		    mysql_format(Base, query, sizeof(query), "SELECT * FROM `aactivity` WHERE `month` = '%d' AND `id` = '%d' AND `year`='%d' ORDER BY `h` DESC LIMIT 1", mnt, id, year);
			mysql_tquery(Base, query, "ShowAActivity", "siii", n, id, a, type);
		}
	}
	return 1;
}

fun ShowAActivity(const name[], const id, const admin, const type)
{
	new str[1024], h = 0, m = 0, s = 0, indays = 0, f[512], act[15] = "";
    if(cache_num_rows())
	{
	    cache_get_value_name_int(0, "h", h);
		cache_get_value_name_int(0, "m", m);
		cache_get_value_name_int(0, "s", s);
		cache_get_value_name_int(0, "indays", indays);
		
		if(m <= 0) m = 0;
		if(s <= 0) s = 0;
		
		act = "Inactive";
		if(h >= 15) act = "Semi-Active";
	    if(h >= 30) act = "Active";
		if(h >= 60) act = "Very-Active";
		if(indays > 0)
		{
			format(f, sizeof(f), "```diff\n- %s %s (ID: %d) - %s - (%02d:%02d) / (30:00) | [Days of Inactivity %d]\n```", AdminRanks[0][admin-1], name, id, act, h > -1 ? h : 0, m, indays);
            strcat(str, f);
		}
		else
		{
			format(f, sizeof(f), "```yaml\n- %s %s (ID: %d) - %s - (%02d:%02d) / (30:00)\n```", AdminRanks[0][admin-1], name, id, act, h > -1 ? h : 0, m);
  		    strcat(str, f);
		}
	}
	else
	{
	    format(f, sizeof(f), "```diff\n- %s %s (ID: %d) (Has never logged in to the server this month)\n```", AdminRanks[0][admin-1], name, id);
	    strcat(str, f);
	}
	#if debug_mode == 0
	if(type == 0)
	{
		DiscordChannel = DCC_FindChannelById("613185790683513003");
	 	DCC_SendChannelMessageEx(DiscordChannel, str);
	}
	else
	{
	    DiscordChannel = DCC_FindChannelById("610987221431877642");
	 	DCC_SendChannelMessageEx(DiscordChannel, str);
	}
	#endif
	
	return 1;
}

fun bool:CanUseDSComamnds(DCC_Guild:Guild, DCC_User:author, DCC_Role:role)
{
    #if debug_mode == 0
    new role_count, i, bool:hasRole, roleid[DCC_ID_SIZE];
    DCC_GetGuildMemberRoleCount(Guild, author, role_count);
    for (i = 0; i != role_count; i++)
	{
	    DCC_GetGuildMemberRole(Guild, author, i, role);
	    DCC_HasGuildMemberRole(Guild, author, role, hasRole);
	    if(hasRole)
	    {
	        DCC_GetRoleId(role, roleid);
	        if(!strcmp(SERVER_DEFINING_ROLE, roleid, true) && !strcmp(SERVER_DEFINING_BUILD, SERVER_BUILD, true)) return true;
	    }
	}
	#endif
	return false;
}

fun bool:GetRolePermissions(code, DCC_Guild:Guild, DCC_User:author, DCC_Role:role, perm_high, perm_low, DCC_Channel:channel)
{
    #if debug_mode == 0
	new role_count, i, bool:hasRole;
    DCC_GetGuildMemberRoleCount(Guild, author, role_count);

	/*if(role_count <= 1)
	{
	    DCC_SendChannelMessageEx(channel, "```diff\n- Set the rights you want to use (Build v16 | Build v20)\n```");
		return false;
	}*/
	
	if(CanUseDSComamnds(Guild, author, role))
 	{
		for (i = 0; i != role_count; i++)
		{
		    DCC_GetGuildMemberRole(Guild, author, i, role);
		    DCC_HasGuildMemberRole(Guild, author, role, hasRole);
		    if(hasRole)
		    {
                DCC_GetRolePermissions(role, perm_high, perm_low);
	   			if((perm_low & code) == code)
	   			{
				   	return true;
				}
		    }
		}
	}
	#endif
	return false;
}

fun bool:GetUserRolePermissions(DCC_Guild:Guild, DCC_User:author, DCC_Role:role, perm_high, perm_low, DCC_Channel:channel)
{
    #if debug_mode == 0
	new role_count, i, bool:canUseCommands, bool:hasRole, roleid[DCC_ID_SIZE];
    DCC_GetGuildMemberRoleCount(Guild, author, role_count);

	/*if(role_count <= 1)
	{
	    DCC_SendChannelMessageEx(channel, "```diff\n- Set the rights you want to use (Build v16 | Build v20)\n```");
		return false;
	}*/

	for (i = 0; i != role_count; i++)
	{
	    DCC_GetGuildMemberRole(Guild, author, i, role);
	    DCC_HasGuildMemberRole(Guild, author, role, hasRole);
	    if(hasRole)
	    {
	        DCC_GetRoleId(role, roleid);
            if(!strcmp(SERVER_DEFINING_ROLE, roleid, true) && !strcmp(SERVER_DEFINING_BUILD, SERVER_BUILD, true)) canUseCommands = true;
   			DCC_GetRolePermissions(role, perm_high, perm_low);
   			if(canUseCommands) return true;
	    }
	}
	#endif
	return false;
}

#define dcc_debug 0

fun newUserPrivateChannel(playerid, userID[])
{
    printf("---> Channel created successfuly");
    
    new private_channel_id[DCC_ID_SIZE];
	DCC_GetChannelId(DCC_GetCreatedPrivateChannel(), private_channel_id);
    printf("---> Created: %s", private_channel_id);

	strmid(UserPrivateChannelUserIDs[playerid][UserCreatedChannels[playerid]], userID, 0, DCC_ID_SIZE, DCC_ID_SIZE);
	strmid(UserPrivateChannelID[playerid][UserCreatedChannels[playerid]], private_channel_id, 0, DCC_ID_SIZE, DCC_ID_SIZE);
	UserCreatedChannels[playerid]++;
	printf("---> UserID: %s | Given: %s", userID, UserPrivateChannelUserIDs[playerid][0]);
	
    new DCC_Channel:channel = DCC_INVALID_CHANNEL;
	new msg[200];
	
	channel = DCC_FindChannelById(private_channel_id);
    if(channel == DCC_INVALID_CHANNEL)
	{
 		printf("---> Invalid channel");
		return 0;
	}
	
	format(msg, sizeof(msg), "```yaml\nBy communicating with me, you transfer personal messages to %s\n```", Player[playerid][UserName]);
	DCC_SendChannelMessageEx(channel, msg);
	DCC_SendChannelMessageEx(channel, "```yaml\nYour records of conversations will be available to the administration and will be saved in logs to ensure the safety of users.\n```");
	
	return 1;
}

#if debug_mode == 0
public DCC_OnMessageCreate(DCC_Message:message)
{
    DCC_SetBotPresenceStatus(DO_NOT_DISTURB);
	DCC_SetBotActivity("Grand Theft Auto San Andreas");
		
    new DCC_Guild:Guild = DCC_FindGuildById("596363897947160607");
    if(Guild == DCC_INVALID_GUILD)
	{
	    #if dcc_debug == 1
	        printf("Invalid guild");
	    #endif
		return 0;
    }
    
    DCC_SetBotNickname(Guild, "Amelia");
    
   	new DCC_Channel:channel = DCC_INVALID_CHANNEL;
    DCC_GetMessageChannel(message, channel);
    if(channel == DCC_INVALID_CHANNEL)
	{
	    #if dcc_debug == 1
	        printf("Invalid channel");
	    #endif
		return 0;
	}
	
    new DCC_User:author, userID[DCC_ID_SIZE];
	DCC_GetMessageAuthor(message, author);
	if(author == DCC_INVALID_USER)
	{
 		#if dcc_debug == 1
	        printf("Invalid author");
	    #endif
		return 0;
	}
	
	DCC_GetUserId(author, userID);
	
	new bool: IsBot, userMessage[128];
	DCC_IsUserBot(author, IsBot);
	DCC_GetMessageContent(message, userMessage);

    new userName[32];
	new DCC_Channel:PrivateChannel = channel;
	
	foreach(Player, i) {
	    for( new b = 0; b < UserCreatedChannels[i]; b++) {
	    	if(DCC_FindChannelById(UserPrivateChannelID[i][b]) == PrivateChannel && !IsBot) {
                new i_pos = 0;
			    while(userMessage[i_pos])
				{
					if(userMessage[i_pos] == '%') userMessage[i_pos] = '#';
					i_pos++;
				}
				
				if(CheckForWebsite(userMessage) || CheckForIP(userMessage)) {}
				else
				{
			        DCC_GetUserName(author, userName);
			        strmid(UserPrivateChannelUserNames[i][b], userName, 0, DCC_ID_SIZE, DCC_ID_SIZE);
					SendClientMessageFormat(i, -1, "{FFF000}>> [DISCORD PM]: %s(%d): %s", userName, b, userMessage);

	                new __action[200], y, mnt, d, h, minutes, s;
	                format(__action, sizeof __action, "```\n[DISCORD]: %s: %s\n```", userName, userMessage);
	                DCC_SendChannelMessageEx(PrivateChannel, __action);
	                
					TimestampToDate(gettime(), y, mnt, d, h, minutes, s, 3);
					DiscordChannel = DCC_FindChannelById("662009556817149962");
					format(__action, sizeof __action, "```\n[DISCORD]: %02d/%02d/%04d %02d:%02d %s(%d) to %s(%d) (Message: %s)\n```", d, mnt, y, h, minutes, userName, b, Player[i][RealName], Player[i][pAccountID], userMessage);
					DCC_SendChannelMessageEx(DiscordChannel, __action);
	    		}
			}
		}
	}

	if(userMessage[0] != '!')
	{
	    #if dcc_debug == 1
	        printf("Not a command");
	    #endif
		return 0;
	}
	
	if(!strlen(userMessage))
	{
		#if dcc_debug == 1
	        printf("No text in the message");
	    #endif
		return 0;
	}
	
	DCC_GetGuildMemberNickname(Guild, author, userName);
	
    new msg[200], perm_high, perm_low, vip[21], i_pos = 0, DCC_Role:role;
	
	while(userMessage[i_pos])
	{
		if(userMessage[i_pos] == '%') userMessage[i_pos] = '#';
		i_pos++;
	}

 	// printf("PERSIMMIONS: %d", GetUserRolePermissions(Guild, author, role, perm_high, perm_low, channel));

	if(GetUserRolePermissions(Guild, author, role, perm_high, perm_low, channel) && !IsBot)
 	{
 	    if(channel == DCC_FindChannelById("612998988609880076"))
		{
		    if(strfind(userMessage, "!pm") == 0 && strlen(userMessage) > 4)
			{
			    strdel(userMessage, 0, 4);
				new id;
				#if debug_mode == 0
				if(sscanf(userMessage, "i", id))
				{
			    	DCC_SendChannelMessageEx(channel, "```!pm (playerid)```");
					return 1;
				}
				
   		        if(!IsPlayerConnected(id)) {
   		            DCC_SendChannelMessageEx(channel, "```A player isn't connected```");
   		            return 1;
   		        }
				
   				format(msg, 200, "```yaml\n[DISCORD]: Trying to open end-to-end encryption...\n```");
		    	DCC_SendChannelMessageEx(channel, msg);
				if(UserCreatedChannels[id] >= MAX_PLAYERS) {
				    format(msg, 200, "```yaml\n[DISCORD]: Connection broken at the end of execution.\n```");
		    		DCC_SendChannelMessageEx(channel, msg);
		    		return 1;
				}
		    	else {
		    	    new b;
					for( b = 0; b < UserCreatedChannels[id]; b++) {
						if(!strcmp(UserPrivateChannelUserIDs[id][b], userID)) {
                            DCC_SendChannelMessageEx(channel, "```css\n[ERROR]: You are already communicating\n```");
                            return 1;
						}
					}
					
					foreach(Player, i) {
					    if(i == id) continue;
					    for( b = 0; b < UserCreatedChannels[i]; b++) {
					        if(!strcmp(UserPrivateChannelUserIDs[i][b], userID)) {
                                new DCC_Channel: ToSent = DCC_FindChannelById(UserPrivateChannelID[i][b]);
    							DCC_SendChannelMessageEx(ToSent, "```yaml\nDisconnecting from old conversation\n```");
    							DCC_DeleteChannel(DCC_FindChannelById(UserPrivateChannelID[i][b]));
					        }
					    }
					}
					
					format(msg, 200, "```yaml\n[DISCORD]: Creating a private conversation between you and %s\n```", Player[id][UserName]);
                    DCC_SendChannelMessageEx(channel, msg);
                    DCC_SendChannelMessageEx(channel, "```yaml\n[DISCORD]: I'll write you a private message when I'm ready.\n```");
					DCC_CreatePrivateChannel(author, "newUserPrivateChannel", "ds", id, userID);
					
					return 1;
				}
				#endif
				return 1;
			}
			if(strfind(userMessage, "!say") == 0 && strlen(userMessage) > 4)
			{
	        	if(CheckForWebsite(userMessage)) {}
	        	else
	        	{
					new i_numcount, i_period, check_pos = 0;
			        if(strfind(userMessage, ".", true) != -1)
					{
				        while(userMessage[check_pos])
						{
				            if('0' <= userMessage[check_pos] <= '9') i_numcount ++;
				            else if(userMessage[check_pos] == '.') i_period ++;
				            check_pos++;
				        }
					}

	                if(i_numcount <= 7 && i_period <= 2)
					{
					    #if debug_mode == 0
				    	DCC_GetGuildMemberNickname(Guild, author, userName);
				    	if(strlen(userName) <= 0) DCC_GetUserName(author, userName);
				    	SendMessageFormatToAll(-1, "{7289da}>> [DISCORD]: %s:{FFFFFF} %s", userName, userMessage[5]);

						format(msg, 200, "```yaml\n[DISCORD]: %s: %s\n```", userName, userMessage[5]);
						DCC_SendChannelMessageEx(channel, msg);
						#endif
					}
				}
				return 1;
			}
		}
		if(!strcmp(userMessage, "!updlog"))
		{
		    DCC_SendChannelMessageEx(channel, "Last Update "SERVER_UPDATE"");
		    DCC_SendChannelMessageEx(channel, SERVER_UPDATE_LOG);
		    return 1;
		}
 	   	/*if(!strcmp(userMessage, "!players"))
		{
		    if(playerOnline >= 1)
		    {
		        new str[900], frm[33], c;
		        strcat(str, "```diff\n");
				foreach(Player, i)
				{
				    format(frm, 32, "- %s (ID %d)\n", Player[i][UserName], i);
				    strcat(str, frm);
				    c++;
				}
				format(frm, 32, "+ Total of %d players\n```", c);
				strcat(str, frm);
				DCC_SendChannelMessageEx(channel, str);
				return 1;
			}
			else
			{
			    DCC_SendChannelMessageEx(channel, "```yaml\nNobody connected :(\n```");
			}
			return 1;
		}*/
	}
	if(channel == DCC_FindChannelById("610987221431877642"))
	{
	    if(strfind(userMessage, "!activity") == 0)
   		{
   		    strdel(userMessage, 0, 10);
			new reason;
			if(sscanf(userMessage, "i", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!activity (month)```");
				return 1;
			}
   		    if(reason < 1 || reason > 12)
   		    {
			    DCC_SendChannelMessageEx(channel, "```!activity (month)```");
				return 1;
			}
   		    DCC_SendChannelMessageEx(channel, "```Processing...```");

   		    new query[128];
   		    mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`Admin` FROM `users` WHERE `Admin` > '0' AND `ID` > '1' ORDER BY `Admin` DESC");
			mysql_tquery(Base, query, "GetAdminsActivity", "ii", reason, 1);
			return 1;
		}
	    return 1;
	}
	if(channel == DCC_FindChannelById("613185790683513003"))
	{
	    if(strfind(userMessage, "!activity") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 10);
			new reason;
			if(sscanf(userMessage, "i", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!activity (month)```");
				return 1;
			}
   		    if(reason < 1 || reason > 12)
   		    {
			    DCC_SendChannelMessageEx(channel, "```!activity (month)```");
				return 1;
			}
   		    DCC_SendChannelMessageEx(channel, "```Processing...```");

   		    new query[128];
   		    mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`Admin` FROM `users` WHERE `Admin` > '0' AND `ID` > '1' ORDER BY `Admin` DESC");
			mysql_tquery(Base, query, "GetAdminsActivity", "ii", reason, 0);
			return 1;
		}
		
        if(strfind(userMessage, "!getinfo") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 9);
			new userid = -1;
			sscanf(userMessage, "I(-1)", userid);
			if(userid <= -1)
			{
			    DCC_SendChannelMessageEx(channel, "```!getinfo (id)```");
			    return 1;
			}
			else if(!IsPlayerConnected(userid))
			{
   				DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
   				return 1;
			}
			else
			{
				new Float: info[2], ip[16], info_str[512], frm_info[128];
				switch(Player[userid][pVip])
				{
				    case 0: vip = "No";
				    case 1: vip = "Bronze(1)";
				    case 2: vip = "Silver(2)";
				    case 3: vip = "Gold(3)";
				}
				new GunName[47][20] =
				{
				    "Fist","Brass Knuckles","Golf Club","Nightstick","Knife","Basebal Bat","Shovel","Pool Cue","Katana","Chainsaw","Double-ended Dildo","Dildo","Vibrator",
				    "Silver Vibrator","Flowers","Cane","Grenade","Tear Gas","Molotv Cocktail","?","?","?","9mm","Silenced 9mm","Desert Eagle","Shotgun","Sawnoff-Shotgun",
				    "Combat Shotgun","Micro-SMG","MP5","Ak-47","M4","Tec9","Country Rifle","Sniper Rifle","RPG","HS-RPG","Flame-Thrower","Minigun","Satchel Charge","Detonator",
				    "Spray Can","Fire Extinguisher","Camera","Night Goggles","Thermal Goggles","Parachute"
				};

				GetPlayerIp(userid,ip,sizeof(ip));
				GetPlayerHealth(userid,info[0]);
				GetPlayerArmour(userid,info[1]);

	            new y, m, d, h, i, s;
				TimestampToDate(Player[userid][pRegDate], y, m, d, h, i, s, 3);
	            strcat(info_str, "```\n");
	            format(frm_info, sizeof(frm_info), ">> %s's Information (IP: %s) (Last IP: %s)\n", Player[userid][UserName], ip, Player[userid][pLastIP]);
	            strcat(info_str, frm_info);
	            format(frm_info, sizeof(frm_info), ">> Registered IP (%s) (Date: %02dD/%02dM/%04dY)\n", Player[userid][pIP], d, m, y);
	            strcat(info_str, frm_info);
				new vtl[64], gmbs[64], ghbs[64], gabs[64];

				gmbs = "";
				ghbs = "";
				gabs = "";

				vtl = "";
				format(frm_info, sizeof(frm_info), ">> Health: %.1f%s%s - Armour: %.1f\n", info[0], vtl, ghbs, info[1], gabs);
	            strcat(info_str, frm_info);
	            format(frm_info, sizeof(frm_info), ">> EXP: %d - Money: %d\n", Player[userid][pXP], GetPlayerMoney(userid));
	            strcat(info_str, frm_info);
	            format(frm_info, sizeof(frm_info), ">> Spawned: %s - S0BEIT: %s\n", Player[userid][pLogged] == false ? ("No") : ("Yes"), S0beitSuspecting[userid] >= 2 ? ("YES") : S0beitSuspecting[userid] == 1 ? ("SUSPECTED") : ("NO"));
	            strcat(info_str, frm_info);
	            format(frm_info, sizeof(frm_info), ">> Country: %s\n", GetPlayerCountry(userid));
	            strcat(info_str, frm_info);

				if(GetPlayerTeamEx(userid) == TEAM_ZOMBIE && Player[userid][pClass][TEAM_ZOMBIE+1] < sizeof(zombieClassesListNames[])) {
	                format(frm_info, sizeof(frm_info), ">> Team: Zombie - Class: %s\n", zombieClassesListNames[0][Player[userid][pClass][TEAM_ZOMBIE+1]]);
	            	strcat(info_str, frm_info);
				}
				if(GetPlayerTeamEx(userid) == TEAM_ZOMBIE && Player[userid][pClass][TEAM_ZOMBIE+1] > sizeof(zombieClassesListNames[])) {
	                format(frm_info, sizeof(frm_info), ">> Team: Zombie - Class: %s\n", zombieVIPCl[0][Player[userid][pClass][TEAM_ZOMBIE+1]-5000]);
	            	strcat(info_str, frm_info);
				}

				if(GetPlayerTeamEx(userid) == TEAM_HUMAN && Player[userid][pClass][TEAM_HUMAN] < sizeof(humanClassesListNames[])) {
					format(frm_info, sizeof(frm_info), ">> Team: Human - Class: %s\n", humanClassesListNames[0][Player[userid][pClass][TEAM_HUMAN]]);
	            	strcat(info_str, frm_info);
				}

				if(GetPlayerTeamEx(userid) == TEAM_HUMAN && Player[userid][pClass][TEAM_HUMAN] > sizeof(humanClassesListNames[])) {
	            	format(frm_info, sizeof(frm_info), ">> Team: Human - Class: %s\n", humanVIPCl[0][Player[userid][pClass][TEAM_HUMAN]-5000]);
	            	strcat(info_str, frm_info);
				}

				if(Player[userid][pAdmin] > 0) {
					format(frm_info, sizeof(frm_info),  ">> V.I.P: %s - Admin: %s\n", vip, AdminRanks[0][Player[userid][pAdmin]-1]);
	            	strcat(info_str, frm_info);
				}
				else {
					format(frm_info, sizeof(frm_info),  ">> V.I.P: %s - Admin: No\n", vip);
	            	strcat(info_str, frm_info);
				}

				new slot, weap[14], ammo[14];
			    for ( slot = 0; slot < 14; slot++ )
			    {
			        GetPlayerWeaponData(userid,slot,weap[slot],ammo[slot]);
			        if(ammo[slot] >= 1)
			        {
	    				format(frm_info, sizeof(frm_info),  ">> Weapon: %s - Ammo: %d%s\n", GunName[weap[slot]], ammo[slot], gmbs);
	            		strcat(info_str, frm_info);
					}
				}
				if(Player[userid][pClan] > 0)
				{
					format(frm_info, sizeof(frm_info),   ">> Clan: (ID %d)(Rank: %d)\n", Player[userid][pClan],Player[userid][pClanRank]);
	  				strcat(info_str, frm_info);
				}
	        	format(frm_info, sizeof(frm_info), ">> Packets lost: %.2f", NetStats_PacketLossPercent(userid));
				strcat(info_str, frm_info);
				strcat(info_str, "```");
				DCC_SendChannelMessageEx(channel, info_str);
			}
			return 1;
		}
		
		if(strfind(userMessage, "!acmds") == 0)
   		{
			if(GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!offtban (name) (time) (reason)\n!banname (name)\n!unban (name)\n!banip (IP)\n!unbanip (IP)\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!blockport (port)\n!unblockport (port)\n!bankey (key)\n!unbankey (key)\n!admins\n!skipmap\n```");
			}
			else if(GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!offtban (name) (time) (reason)\n!banname (name)\n!unban (name)\n!banip (IP)\n!unbanip (IP)\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!blockport (port)\n!unblockport (port)\n!admins\n!skipmap\n```");
			}
			else if(GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
			}
			else if(GetRolePermissions(0x2, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
			}
			else if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
			}
			return 1;
   		}

    	if(strfind(userMessage, "!admins") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			if(playerOnline >= 1)
	        {
		        new str[400], frm[64], count;
		        strcat(str, "```yaml\n");
				foreach(Player, i)
				{
				    if(Player[i][pAdmin] >= 1 && FakeData[i][7] <= 0)
				    {
				    	format(frm, 64, "%s (ID %d) (Level %d)\n", Player[i][UserName], i, Player[i][pAdmin]);
				    	strcat(str, frm);
				    	count++;
					}
				}
				strcat(str, "```");
				if(count >= 1) DCC_SendChannelMessageEx(channel, str);
				else DCC_SendChannelMessageEx(channel, "```yaml\nNo administrators\n```");
				return 1;
			}
			else
			{
			    DCC_SendChannelMessageEx(channel, "```yaml\nNobody connected :(\n```");
			}
			return 1;
		}
	}
	
    if(channel == DCC_FindChannelById("667021505846312960"))
	{
        if(!strcmp(userMessage, "!acmds"))
   		{
			if(GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!removeexp (name/Account ID) (percents)\n!makeadminoffline (name) (level)\n!unbanip (IP)\n!banip (IP)\n!banname (name) (reason)\n!unban (name)```");
			}
			return 1;
		}
    }
    
    if(channel == DCC_FindChannelById("674323910648397894"))
	{
        if(!strcmp(userMessage, "!acmds"))
   		{
			if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!ostats (name)\n!checkname (name) (limit)\n!checkip (ip)\n!banlog (account id)\n!compare (account id) (account id)\n!vpn (account id)\n!logs (account id) (day) (month) (year) (count)\n!all about (account id)\n!checkpay (account id) (limit) [type = 0 /paid | 1 = /gang deposit | 2 = /gang pay | 3 = /givezaps]\n!key (key)\n!getport (account id)\n!port (port)\n!getkey (account id)\n```");
			}
			return 1;
		}
	}

	if(channel == DCC_FindChannelById("674323910648397894"))
	{
        /*if(!strcmp(userMessage, "!acmds"))
   		{
			if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!ostats (name)\n!checkname (name)\n!checkip (ip)\n!banlog (account id)\n!compare (account id) (account id)\n!vpn (account id)\n!logs (account id) (day) (month) (year) (count)\n!all about (account id)\n!checkpay (account id) (limit) [type = 0 /paid | 1 = /gang deposit | 2 = /gang pay | 3 = /givezaps]\n!key (key)\n```");
			}
			return 1;
		}*/

	    if(strfind(userMessage, "!key") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 5);
			new reason[41];
			if(sscanf(userMessage, "s[41]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!key (key)```");
			    return 1;
			}

			DCC_SendChannelMessageEx(channel, "```yaml\n+++ KEY FINDING +++\n```");

			new query[400];
			mysql_format(Base, query, sizeof(query), "SELECT users.ID aid, users.Name uname, userinfo.last_log la_log FROM users JOIN userinfo ON userinfo.id = users.id WHERE users.kie LIKE '%e%%' GROUP BY aid ORDER BY userinfo.last_log DESC;", reason);
			mysql_tquery(Base, query, "ITCompareKeys", "");
			return 1;
		}
		
		if(strfind(userMessage, "!getkey") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 8);
			new reason;
			if(sscanf(userMessage, "i", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!getkey (account id)```");
			    return 1;
			}
            if(reason <= 0)
			{
			    DCC_SendChannelMessageEx(channel, "```!getkey (account id)```");
			    return 1;
			}

			new query[450];
			mysql_format(Base, query, sizeof(query), "SELECT users.Name, pactions.date, pactions.sign, pactions.reg_sign, pactions.acc FROM pactions JOIN users ON pactions.acc = users.id WHERE pactions.acc = '%d' ORDER BY pactions.date DESC LIMIT 1;", reason);
			mysql_tquery(Base, query, "ITGetKey", "");
			return 1;
		}
		
		if(strfind(userMessage, "!getport") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 9);
			new reason;
			if(sscanf(userMessage, "i", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!getport (account id)```");
			    return 1;
			}
            if(reason <= 0)
			{
			    DCC_SendChannelMessageEx(channel, "```!getport (account id)```");
			    return 1;
			}
			DCC_SendChannelMessageEx(channel, "```yaml\n+++ PORT GETTING +++\n```");

			new query[450];
			mysql_format(Base, query, sizeof(query), "SELECT users.ID aid, users.Name uname, userinfo.port FROM users JOIN userinfo ON userinfo.id = users.id WHERE userinfo.port = '%d'", reason);
			mysql_tquery(Base, query, "ITGetPort", "");
			return 1;
		}
		
		if(strfind(userMessage, "!port") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 6);
			new reason;
			if(sscanf(userMessage, "i", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!port (port)```");
			    return 1;
			}
			if(reason <= 0)
			{
			    DCC_SendChannelMessageEx(channel, "```!port (port)```");
			    return 1;
			}
			DCC_SendChannelMessageEx(channel, "```yaml\n+++ PORT FINDING +++\n```");

			new query[450];
			mysql_format(Base, query, sizeof(query), "SELECT users.ID aid, users.Name uname, userinfo.last_log la_log, userinfo.port upotr FROM users JOIN userinfo ON userinfo.id = users.id WHERE userinfo.port = '%d' GROUP BY aid ORDER BY userinfo.last_log DESC;", reason);
			mysql_tquery(Base, query, "ITComparePorts", "");
			return 1;
		}

		if(strfind(userMessage, "!checkname") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 11);
			new reason[24], limit;
			if(sscanf(userMessage, "s[24]i", reason, limit))
			{
			    DCC_SendChannelMessageEx(channel, "```!checkname (name) (limit)```");
			    return 1;
			}
  			new query[164];
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `namechanger` WHERE `newName` LIKE '%%%e%%' OR `oldName` LIKE '%%%e%%' AND `build`='"SERVER_BUILD"'", reason, reason);
			mysql_tquery(Base, query, "TryToFindUserNamesFromDiscord", "d", limit);
			return 1;
		}

        if(strfind(userMessage, "!compare") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 9);
		    new id, id2;
			if(sscanf(userMessage, "ii", id, id2))
			{
			    DCC_SendChannelMessageEx(channel, "```!compare (account id) (account id)```");
			    return 1;
			}
			if(id > 0 && id2 > 0)
			{
            	new query[128];
				mysql_format(Base, query, sizeof(query), "SELECT u.kie AS 'fk', u.kie AS 'sk' FROM users u WHERE `ID` IN('%d','%d') AND `build`='"SERVER_BUILD"'", id, id2);
				mysql_tquery(Base, query, "ITCompareAccunts", "ii", id, id2);
			}
			return 1;
		}

		if(strfind(userMessage, "!banlog") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 8);
		    new id;
			if(sscanf(userMessage, "i", id))
			{
			    DCC_SendChannelMessageEx(channel, "```!banlog (account id)```");
			    return 1;
			}
			if(id > 0)
			{
            	new query[128];
				mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlog` WHERE `acc` = '%d' AND `build`='"SERVER_BUILD"'", id);
				mysql_tquery(Base, query, "ShowBanLog", "ii", id, 0);
			}
			return 1;
		}
		
		/*if(strfind(userMessage, "!checkisp") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 10);
		    new isp[64];
			if(sscanf(userMessage, "s[64]", isp))
			{
			    DCC_SendChannelMessageEx(channel, "```!checkisp (isp name)```");
			    return 1;
			}
			if(strlen(isp) > 0)
			{
            	new query[256];
				mysql_format(Base, query, sizeof(query), "SELECT users.ID, users.Name FROM `isp` JOIN `users` ON users.ID = isp.ID WHERE isp.name = '%e' GROUP BY users.ID;", isp);
				mysql_tquery(Base, query, "ProtocolCheckISP", "");
			}
			return 1;
		}
		
		if(strfind(userMessage, "!isp") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 5);
		    new id;
			if(sscanf(userMessage, "i", id))
			{
			    DCC_SendChannelMessageEx(channel, "```!isp (account id)```");
			    return 1;
			}
			if(id > 0)
			{
            	new query[128];
				mysql_format(Base, query, sizeof(query), "SELECT `name` FROM `isp` WHERE `ID` = '%d' GROUP BY `name`", id);
				mysql_tquery(Base, query, "ProtocolShowISP", "ii", id, 0);
			}
			return 1;
		}
		
		if(strfind(userMessage, "!banisp") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 8);
		    new isp[64];
			if(sscanf(userMessage, "s[64]", isp))
			{
			    DCC_SendChannelMessageEx(channel, "```!banisp (isp name)```");
			    return 1;
			}
			if(strlen(isp) > 0)
			{
            	new query[128];
            	mysql_format(Base, query, sizeof(query), "INSERT INTO `banisp` (`name`) VALUES ('%e')", isp);
				mysql_tquery(Base, query, "", "", "");
			}
			return 1;
		}
		
		if(strfind(userMessage, "!unbanisp") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 10);
		    new isp[64];
			if(sscanf(userMessage, "s[64]", isp))
			{
			    DCC_SendChannelMessageEx(channel, "```!unbanisp (isp name)```");
			    return 1;
			}
			if(strlen(isp) > 0)
			{
            	new query[128];
            	mysql_format(Base, query, sizeof(query), "DELETE FROM `banisp` WHERE `name` = '%e'", isp);
				mysql_tquery(Base, query, "", "", "");
			}
			return 1;
		}*/

		if(strfind(userMessage, "!vpn") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 5);
		    new id;
			if(sscanf(userMessage, "i", id))
			{
			    DCC_SendChannelMessageEx(channel, "```!vpn (account id)```");
			    return 1;
			}
			if(id > 0)
			{
				new query[256];
			    mysql_format(Base, query, sizeof(query), "SELECT vpns.*, users.Name FROM `vpns` JOIN `users` WHERE users.ID = '%d' AND vpns.acc = '%d' ORDER BY vpns.login DESC LIMIT 5", id, id);
				mysql_tquery(Base, query, "ShowVPNActions", "i", id);
			}
			return 1;
		}

		if(strfind(userMessage, "!logs") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 6);
		    new id, month, day, year, count;
			if(sscanf(userMessage, "iiiii", id, day, month, year, count))
			{
			    DCC_SendChannelMessageEx(channel, "```!logs (account id) (day) (month) (year) (count)```");
			    return 1;
			}
			if(id > 0)
			{
                new TimeDate = datetime_to_unix(year, month, day-1, 0, 0, 0);
                new TimeDateNext = datetime_to_unix(year, month, day+1, 0, 0, 0);
				new query[256];
			    mysql_format(Base, query, sizeof(query), "SELECT pactions.*, users.Name FROM `pactions` JOIN `users` WHERE users.ID = '%d' AND pactions.acc = '%d' AND pactions.date BETWEEN '%d' AND '%d' ORDER BY pactions.date DESC LIMIT %d", id, id, TimeDate, TimeDateNext, count);
				mysql_tquery(Base, query, "ShowAccActions", "i", id);
			}
			return 1;
		}

		if(strfind(userMessage, "!all about") == 0 && GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 11);
		    new id;
			if(sscanf(userMessage, "i", id))
			{
			    DCC_SendChannelMessageEx(channel, "```!all about (account id)```");
			    return 1;
			}
			if(id > 0)
			{
			    new query[164];
			    mysql_format(Base, query, sizeof(query), "SELECT users.*, userinfo.reg_date, userinfo.last_ip FROM users JOIN userinfo ON userinfo.id = users.ID WHERE users.ID = '%d' AND users.build ='"SERVER_BUILD"'", id);
				mysql_tquery(Base, query, "CheckForOffStatsInInvDiscord", "i", 0);
			
				DCC_SendChannelMessageEx(channel, "```diff\n- Information gathering process initiated\n- Connecting to security protocols [LIMIT 5 errors]\n```");
			    mysql_format(Base, query, sizeof(query), "SELECT * FROM `security` WHERE `acc` = '%d' ORDER BY `type` DESC, `date` DESC LIMIT 5", id);
				mysql_tquery(Base, query, "ShowSecurityErrors", "i", id);
			}
			return 1;
		}

		if(strfind(userMessage, "!checkpay") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 10);
			new reason = -1, lim = 10, payment_type = -1;
			sscanf(userMessage, "iI(10)I(-1)", reason, lim, payment_type);

			if(reason == -1)
			{
			    DCC_SendChannelMessageEx(channel, "```!checkpay (account ID) (limit) [type = 0 /paid | 1 = /gang deposit | 2 = /gang pay | 3 = /givezaps]```");
				return 1;
			}

			new query[128];
			if(payment_type <= -1 || payment_type > 3) mysql_format(Base, query, sizeof(query), "SELECT * FROM `payments` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"' ORDER BY `date` DESC LIMIT %d", reason, lim);
			else mysql_format(Base, query, sizeof(query), "SELECT * FROM `payments` WHERE `ID` = '%d' AND `type` = '%d' AND `build`='"SERVER_BUILD"' ORDER BY `date` DESC LIMIT %d", reason, payment_type, lim);
			mysql_tquery(Base, query, "CheckUserForPayments");
			return 1;
		}

		if(strfind(userMessage, "!ostats") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 8);
			new reason[24];
			if(sscanf(userMessage, "s[24]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!ostats (name)```");
				return 1;
			}
			new query[264];
			mysql_format(Base, query, sizeof(query), "SELECT users.*, userinfo.reg_date, userinfo.last_ip FROM users JOIN userinfo ON userinfo.id = users.ID WHERE `Name` LIKE '%e%%' OR users.ID = '%d' AND users.build ='"SERVER_BUILD"'", reason, strval(reason));
			mysql_tquery(Base, query, "CheckForOffStatsInInvDiscord", "i", 0);
		 	return 1;
		}
		if(strfind(userMessage, "!checkip") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 9);
			new reason[16];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!checkip (ip)```");
				return 1;
			}
		    new query[144];
			mysql_format(Base, query, sizeof(query), "SELECT `Name`,`ID` FROM `users` WHERE `IP` LIKE '%e%%' AND `build`='"SERVER_BUILD"'", reason);
		 	mysql_tquery(Base, query, "CheckForIpsInDiscord", "i", 0);
			return 1;
		}
	}

	if(channel == DCC_FindChannelById("667021505846312960"))
	{
        /*if(strfind(userMessage, "!acmds") == 0)
   		{
			if(GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!activity\n!removeexp (name/Account ID) (percents)\n!makeadminoffline (name) (level)\n!unbanip (IP)\n!banip (IP)\n!banname (name) (reason)\n!unban (name)```");
			}
			return 1;
		}*/
		if(strfind(userMessage, "!leaders") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    new query[128];
   		    mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`Clan`,`lalog`,`ClanRank` FROM `users` WHERE `ClanRank` > 4 AND `build`='"SERVER_BUILD"' ORDER BY `Clan` ASC");
			mysql_tquery(Base, query, "GetLeadersActivity");
   		    return 1;
   		}

		if(strfind(userMessage, "!makeadminoffline") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 18);
			new reason[24], lvl;
			if(sscanf(userMessage, "s[24]i", reason, lvl))
			{
			    DCC_SendChannelMessageEx(channel, "```!makeadminoffline (name) (lvl)```");
				return 1;
			}
			if(lvl < 0 || lvl > 4)
			{
			    DCC_SendChannelMessageEx(channel, "```!makeadminoffline (name) (0-4)```");
				return 1;
			}
			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			new query[128];
			mysql_format(Base, query, sizeof(query), "SELECT `Admin` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
			mysql_tquery(Base, query, "MakeAdminOfflineDiscord", "ssi", userName, reason, lvl);
			return 1;
   		}

        if(strfind(userMessage, "!unbanip") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 9);
			new reason[16];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!unbanip (ip)```");
				return 1;
			}

			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

            new query[128];
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `banip` WHERE `IP` = '%e'", reason);
		 	mysql_tquery(Base, query, "CheckToUnbanIpFromDiscord", "ss", reason, userName);
			return 1;
		}

        if(strfind(userMessage, "!unban") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 7);
		    new reason[24];
			if(sscanf(userMessage, "s[24]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!unban (name)```");
				return 1;
			}
			new query[200];

			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
		 	mysql_tquery(Base, query, "TryToUnbanFromDiscord", "ssi", reason, userName, 0);
			return 1;
		}

        if(strfind(userMessage, "!skipmap") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    if(Time <= 280) DCC_SendChannelMessageEx(channel, "```\nSkipped\n```");
		    else DCC_SendChannelMessageEx(channel, "```\nWait till 280 secs\n```");
		    
		    if(!already_skipped)
		    {
		        KillTimerEx(mapvar[0]);
				KillTimerEx(mapvar[1]);
				KillTimerEx(mapvar[2]);
				mapvar[2] = SetTimer("EndMap", MAX_RESTART_TIME, false);
				already_skipped = true;
			} else {
			    DCC_SendChannelMessageEx(channel, "```\nAlready skipped\n```");
			}
			return 1;
		}

        if(strfind(userMessage, "!banname") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 9);
		    new user[24], reason[128];
			if(sscanf(userMessage, "s[24]s[128]", user, reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!banname (name) (reason)```");
				return 1;
			}
    		new query[256];
    		DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

		    mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", user);
			mysql_tquery(Base, query, "TryToBanNameFromDiscord", "sss", user, reason, userName);
			return 1;
		}

		if(strfind(userMessage, "!banip") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 7);
			new reason[16], query[128];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!banip (ip)```");
				return 1;
			}
			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			format(query, 128, "banip %s", reason);
 			SendRconCommand(query);
 			SendRconCommand("reloadbans");

			mysql_format(Base, query, sizeof(query), "INSERT INTO `banip` (`IP`,`build`) VALUE ('%e','"SERVER_BUILD"')", reason);
			mysql_tquery(Base, query, "", "", "");

			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][142], userName, reason);
            format(msg, 128, "```yaml\n%s has banned IP %s\n```", userName, reason);
            DiscordChannel = DCC_FindChannelById("613185790683513003");
			DCC_SendChannelMessageEx(DiscordChannel, msg);
			return 1;
		}

   		if(strfind(userMessage, "!removeexp") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 10);
			new reason[24], percent;
			if(sscanf(userMessage, "s[24]i", reason, percent))
			{
			    DCC_SendChannelMessageEx(channel, "```!removeexp (name/Account ID) (percents)```");
				return 1;
			}

			if(percent <= 0 || percent > 100)
			{
			    DCC_SendChannelMessageEx(channel, "```!removeexp (name/Account ID) (percents)```");
				return 1;
			}

			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

            new query[128];
			mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Name`,`EXP` FROM `users` WHERE `Name` = '%e' OR `ID` = '%d' AND `build`='"SERVER_BUILD"'", reason, strval(reason));
			mysql_tquery(Base, query, "TryToRemovePlayerEXPFromDiscord", "si", userName, percent);
			return 1;
		}
	}

	if(channel == DCC_FindChannelById("613185790683513003"))
	{
        if(strfind(userMessage, "!say") == 0 && strlen(userMessage) > 4)
   		{
  			DCC_GetGuildMemberNickname(Guild, author, userName);
	    	if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			format(msg, 200, "```diff\n- <A-CHAT> %s: %s\n```", userName, userMessage[5]);
			DCC_SendChannelMessageEx(channel, msg);

			new utf8msg[300];
            utf8decode(utf8msg, userMessage[5]);
			foreach(Player, i)
			{
				if(Player[i][pAdmin] > 0 && Player[i][pLogged])
				{
					SendClientMessageFormat(i, -1, "{66ffff}<A-CHAT> %s: %s", userName, utf8msg);
				}
			}

            return 1;
		}

		/*if(strfind(userMessage, "!acmds") == 0)
   		{
			if(GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!offtban (name) (time) (reason)\n!banname (name)\n!unban (name)\n!banip (IP)\n!unbanip (IP)\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
   		    	return 1;
			}

			if(GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!offtban (name) (time) (reason)\n!banname (name)\n!unban (name)\n!banip (IP)\n!unbanip (IP)\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
   		    	return 1;
			}

			if(GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
   		    	return 1;
			}

			if(GetRolePermissions(0x2, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
   		    	return 1;
			}

			if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
			{
				DCC_SendChannelMessageEx(channel, "```\n!checkip (IP)\n!getip (name)\n!ostats (name/ID)\n!getinfo (id)\n!admins\n```");
   		    	return 1;
			}
			return 1;
   		}*/

   		if(strfind(userMessage, "!unbanip") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 9);
			new reason[16];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!unbanip (ip)```");
				return 1;
			}
			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

            new query[128];
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `banip` WHERE `IP` = '%e'", reason);
		 	mysql_tquery(Base, query, "UnbanIPFromDiscord", "ss", userName, reason);
			return 1;
		}

   		if(strfind(userMessage, "!banip") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 7);
			new reason[16], query[128];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!banip (ip)```");
				return 1;
			}
			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			format(query, 128, "banip %s", reason);
 			SendRconCommand(query);
 			SendRconCommand("reloadbans");

			mysql_format(Base, query, sizeof(query), "INSERT INTO `banip` (`IP`,`build`) VALUE ('%e','"SERVER_BUILD"')", reason);
			mysql_tquery(Base, query, "", "", "");

			foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][142], userName, reason);
            format(msg, 128, "```yaml\n%s has banned IP %s\n```", userName, reason);
            DiscordChannel = DCC_FindChannelById("613185790683513003");
			DCC_SendChannelMessageEx(DiscordChannel, msg);
			return 1;
		}

        if(strfind(userMessage, "!unbankey") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 10);
		    new port[41];
	     	if(sscanf(userMessage, "s[41]", port))
		    {
                DCC_SendChannelMessageEx(channel, "```!unbankey (key)```");
                return 1;
		    }

			if(strlen(port) <= 38)
			{
			    DCC_SendChannelMessageEx(channel, "```!unbankey (key)```");
				return 1;
			}

            DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

	        foreach(Player, i)
			{
				if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has unblocked the key {FFFFFF}%s!", userName, port);
			}

			new query[128];
			mysql_format(Base, query, sizeof(query), "DELETE FROM `machines` WHERE `ID` = '%e'", port);
			mysql_tquery(Base, query, "", "", "");

			return 1;
		}
        
        if(strfind(userMessage, "!unban") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 7);
		    new reason[24];
			if(sscanf(userMessage, "s[24]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!unban (name)```");
				return 1;
			}
			new query[200];

			DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
		 	mysql_tquery(Base, query, "TryToUnbanFromDiscord", "ssi", reason, userName, 1);

			return 1;
		}
        
        if(strfind(userMessage, "!bankey") == 0 && GetRolePermissions(0x00000008, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 8);
		    new port[41], serial[41];
	     	if(sscanf(userMessage, "s[41]", port))
		    {
                DCC_SendChannelMessageEx(channel, "```!bankey (key)```");
                return 1;
		    }
		    
			if(strlen(port) <= 38)
			{
			    DCC_SendChannelMessageEx(channel, "```!bankey (key)```");
				return 1;
			}

            DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

	        foreach(Player, i)
			{
				if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has blocked the key {FFFFFF}%s!", userName, port);
	            gpci(i, serial, sizeof(serial));
	            if(!strcmp(serial, port, false)) PlayerKick(i);
			}

			new query[128];
			mysql_format(Base, query, sizeof(query), "INSERT INTO `machines` (`ID`) VALUE ('%e')", port);
			mysql_tquery(Base, query, "", "", "");
			
			format(msg, 128, "```yaml\n%s has banned the key %d\n```", userName, port);
            DiscordChannel = DCC_FindChannelById("613185790683513003");
			DCC_SendChannelMessageEx(DiscordChannel, msg);
			
			return 1;
		}
		
		if(strfind(userMessage, "!blockport") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 11);
		    new port;
	     	if(sscanf(userMessage, "i", port))
		    {
                DCC_SendChannelMessageEx(channel, "```!blockport (port)```");
                return 1;
		    }
		    if(port <= 0)
			{
			    DCC_SendChannelMessageEx(channel, "```!blockport (port)```");
                return 1;
			}
		    new query[256];

		    DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

	        foreach(Player, i)
			{
				if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has blocked port %d!", userName, port);
				if(Player[i][pPort] == port) PlayerKick(i);
			}

			mysql_format(Base, query, sizeof(query), "INSERT INTO `ports` (`ptr`) VALUE ('%d')", port);
			mysql_tquery(Base, query, "", "", "");
			
            format(msg, 128, "```yaml\n%s has blocked port %d\n```", userName, port);
            DiscordChannel = DCC_FindChannelById("613185790683513003");
			DCC_SendChannelMessageEx(DiscordChannel, msg);
			
			return 1;
		}
		
		if(strfind(userMessage, "!unblockport") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 13);
		    new port;
	     	if(sscanf(userMessage, "i", port))
		    {
                DCC_SendChannelMessageEx(channel, "```!unblockport (port)```");
                return 1;
		    }
		    if(port <= 0)
			{
			    DCC_SendChannelMessageEx(channel, "```!unblockport (port)```");
                return 1;
			}
		    new query[256];

		    DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

	        foreach(Player, i)
			{
				if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has blocked port %d!", userName, port);
			}

			mysql_format(Base, query, sizeof(query), "DELETE FROM `ports` WHERE `ptr` = '%d'", port);
	  		mysql_tquery(Base, query, "", "", "");

            format(msg, 128, "```yaml\n%s has unblocked port %d\n```", userName, port);
            DiscordChannel = DCC_FindChannelById("613185790683513003");
			DCC_SendChannelMessageEx(DiscordChannel, msg);

			return 1;
		}

		if(strfind(userMessage, "!offtban") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 9);
		    new name[24], time, reason[64];
	     	if(sscanf(userMessage, "s[24]is[64]", name, time, reason))
		    {
                DCC_SendChannelMessageEx(channel, "```!offtban (name) (hours) (reason)```");
                return 1;
		    }
		    if(time <= 0 || time > 999)
			{
			    DCC_SendChannelMessageEx(channel, "```!offtban (name) (hours) (reason)```");
                return 1;
			}
		    new query[256];

		    DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

	        mysql_format(Base, query, sizeof(query), "SELECT `ID`,`Admin` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", name);
			mysql_tquery(Base, query, "OfftbanUserInDiscord", "ssis", userName, name, time, reason);
			return 1;
		}

		if(strfind(userMessage, "!banname") == 0 && GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		{
		    strdel(userMessage, 0, 9);
		    new user[24], reason[128];
			if(sscanf(userMessage, "s[24]s[128]", user, reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!banname (name) (reason)```");
				return 1;
			}

            DCC_GetGuildMemberNickname(Guild, author, userName);
			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

			new query[256];
		    mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", user);
			mysql_tquery(Base, query, "BanNameInIRC", "sss", userName, user, reason);
			return 1;
		}

		////////////////////////////////////////////////////////////////////

		if(strfind(userMessage, "!ostats") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
		{
			strdel(userMessage, 0, 8);
			new reason[24];
			if(sscanf(userMessage, "s[24]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!ostats (name)```");
				return 1;
			}
			new query[264];
			mysql_format(Base, query, sizeof(query), "SELECT users.*, userinfo.reg_date, userinfo.last_ip FROM users JOIN userinfo ON userinfo.id = users.ID WHERE `Name` LIKE '%e%%' OR users.ID = '%d' AND users.build ='"SERVER_BUILD"'", reason, strval(reason));
			mysql_tquery(Base, query, "CheckForOffStatsInInvDiscord", "i", 1);
		 	return 1;
		}

		if(strfind(userMessage, "!checkip") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 9);
			new reason[16];
			if(sscanf(userMessage, "s[16]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!checkip (ip)```");
				return 1;
			}

			new query[144];
			mysql_format(Base, query, sizeof(query), "SELECT `Name`,`ID` FROM `users` WHERE `IP` LIKE '%e%%' AND `build`='"SERVER_BUILD"'", reason);
		 	mysql_tquery(Base, query, "CheckForIpsInDiscord", "i", 1);
			return 1;
		}

		if(strfind(userMessage, "!getip") == 0 && GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
   		{
   		    strdel(userMessage, 0, 7);
			new reason[24];
			if(sscanf(userMessage, "s[24]", reason))
			{
			    DCC_SendChannelMessageEx(channel, "```!getip (name)```");
				return 1;
			}
		    new query[144];
			mysql_format(Base, query, sizeof(query), "SELECT `IP` FROM `users` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
		 	mysql_tquery(Base, query, "DiscordGetIpFromPlayer", "s", reason);
			return 1;
		}
	}

	if(channel == DCC_FindChannelById("612998988609880076"))
	{
	    if(strfind(userMessage, "!help") == 0 || strfind(userMessage, "!cmds") == 0)
   		{
   		    DCC_SendChannelMessageEx(channel, "```!say (message)\n!pm (playerid)\n!updlog```");
   		    return 1;
   		}

   		if(strfind(userMessage, "!acmds") == 0)
   		{
   		    if(GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
		   	{
		   		DCC_SendChannelMessageEx(channel, "```\n!a (text)\n!unban (name)\n!ban (id) (reason)\n!tban (id) (1 - 999 hours) (reason)\n!warn (id) (reason)\n!mute (id) (time) (reason)\n!unmute (id)\n!kick (id) (reason)\n```");
		   		return 1;
			}
   		    if(GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
			{
			   	DCC_SendChannelMessageEx(channel, "```\n!a (text)\n!ban (id) (reason)\n!tban (id) (1 - 999 hours) (reason)\n!warn (id) (reason)\n!mute (id) (time) (reason)\n!unmute (id)\n!kick (id) (reason)\n```");
				return 1;
			}

			if(GetRolePermissions(0x2, Guild, author, role, perm_high, perm_low, channel)) // 0x2
		   	{
   		    	DCC_SendChannelMessageEx(channel, "```\n!a (text)\n!tban (id) (1 - 999 hours) (reason)\n!warn (id) (reason)\n!mute (id) (time) (reason)\n!unmute (id)\n!kick (id) (reason)\n```");
				return 1;
	   		}

   		    if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel)) // 0x2
		   	{
		   	    DCC_SendChannelMessageEx(channel, "```\n!a (text)\n!tban (id) (1 - 3 hours) (reason)\n!warn (id) (reason)\n!mute (id) (time) (reason)\n!unmute (id)\n!kick (id) (reason)\n```");
                return 1;
	   		}
   		    return 1;
   		}

   		if(GetRolePermissions(0x08000000, Guild, author, role, perm_high, perm_low, channel))
	    {
	        if(strfind(userMessage, "!a") == 0)
    		{
	     		strdel(userMessage, 0, 3);
				new reason[128];
				if(sscanf(userMessage, "s[128]", reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!a (text)```");
					return 1;
				}
				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][110], reason);
				format(msg, 200, "```yaml\nAdministrator Announcement: %s\n```", reason);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
    		}

	        if(strfind(userMessage, "!unban") == 0)
    		{
    		    strdel(userMessage, 0, 7);
    		    new reason[24];
				if(sscanf(userMessage, "s[24]", reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!unban (name)```");
					return 1;
				}
				new query[200];
				DCC_GetGuildMemberNickname(Guild, author, userName);
				if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
			 	mysql_tquery(Base, query, "UnbanPlayerInDiscord", "ss", userName, reason);
				return 1;
    		}
    		if(strfind(userMessage, "!tban") == 0)
			{
    		    strdel(userMessage, 0, 6);
    		    new id, time, reason[64];
    		    if(sscanf(userMessage, "iis[64]", id, time, reason))
    		    {
                    DCC_SendChannelMessageEx(channel, "```!tban (id) (hours) (reason)```");
                    return 1;
    		    }
    		    if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
    		    if(time <= 0 || time > 999)
    		    {
    		        DCC_SendChannelMessageEx(channel, "```!tban (id) (hours only 1-999) (reason)```");
                    return 1;
    		    }
    		    if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```Admins can be banned only in the game```");
					return 1;
				}
    		    DCC_GetGuildMemberNickname(Guild, author, userName);
    			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				new query[256];
				mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"')", Player[id][UserName], userName, reason, time*(60*60)+gettime());
				mysql_tquery(Base, query, "", "", "");
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || id == i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][49], Player[id][UserName], userName, time, reason);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][51]);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][52]);
		  	    DiscordChannel = DCC_FindChannelById("619186196718944256");
 				format(msg, sizeof msg, "```\n%s has been banned by %s for %d hours [Reason: %s]\n```", Player[id][UserName], userName, time, reason);
  				DCC_SendChannelMessageEx(DiscordChannel, msg);
                IsBanned{id} = true;
			  	PlayerKick(id);
				return 1;
			}
	    }

	    if(GetRolePermissions(0x4, Guild, author, role, perm_high, perm_low, channel))
	    {
	        if(strfind(userMessage, "!a") == 0)
    		{
	     		strdel(userMessage, 0, 3);
				new reason[128];
				if(sscanf(userMessage, "s[128]", reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!a (text)```");
					return 1;
				}
				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][110], reason);
				format(msg, 200, "```yaml\nAdministrator Announcement: %s\n```", reason);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
    		}

	        if(strfind(userMessage, "!ban") == 0)
    		{
    		    strdel(userMessage, 0, 5);
    		    new id, reason[64];
				if(sscanf(userMessage, "is[64]", id, reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!ban (id) (reason)```");
					return 1;
				}
				if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
				if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```Admins can be banned only in the game```");
					return 1;
				}
				DCC_GetGuildMemberNickname(Guild, author, userName);
	    		if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				new query[256];
				mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',1,0,'"SERVER_BUILD"')", Player[id][UserName], userName, reason);
				mysql_tquery(Base, query);
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == id) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][50], Player[id][UserName], userName, reason);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][51]);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][52]);
		  	    format(msg, 200, "%s(%d) has been banned by %s [Reason: %s]", Player[id][UserName], id, userName, reason);
				DCC_SendChannelMessageEx(channel, msg);

				DiscordChannel = DCC_FindChannelById("619186196718944256");
 				format(msg, sizeof msg, "```\n%s has been banned by %s [Reason: %s]\n```", Player[id][UserName], userName, reason);
  				DCC_SendChannelMessageEx(DiscordChannel, msg);
				IsBanned{id} = true;
		  	    PlayerKick(id);
				return 1;
    		}
    		if(strfind(userMessage, "!tban") == 0)
			{
    		    strdel(userMessage, 0, 6);
    		    new id, time, reason[64];
    		    if(sscanf(userMessage, "iis[64]", id, time, reason))
    		    {
                    DCC_SendChannelMessageEx(channel, "```!tban (id) (hours) (reason)```");
                    return 1;
    		    }
    		    if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
    		    if(time <= 0 || time > 999)
    		    {
    		        DCC_SendChannelMessageEx(channel, "```!tban (id) (hours only 1-999) (reason)```");
                    return 1;
    		    }
    		    if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```Admins can be banned only in the game```");
					return 1;
				}
    		    DCC_GetGuildMemberNickname(Guild, author, userName);
    			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				new query[256];
				mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"')", Player[id][UserName], userName, reason, time*(60*60)+gettime());
				mysql_tquery(Base, query, "", "", "");
			 	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || id == i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][49], Player[id][UserName], userName, time, reason);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][51]);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][52]);

		  	    DiscordChannel = DCC_FindChannelById("619186196718944256");
 				format(msg, sizeof msg, "```\n%s has been banned by %s for %d hours [Reason: %s]\n```", Player[id][UserName], userName, time, reason);
  				DCC_SendChannelMessageEx(DiscordChannel, msg);
		  	    IsBanned{id} = true;
		  	    PlayerKick(id);
				return 1;
			}
	    }

	    if(GetRolePermissions(0x2, Guild, author, role, perm_high, perm_low, channel))
	    {
	        if(strfind(userMessage, "!a") == 0)
    		{
	     		strdel(userMessage, 0, 3);
				new reason[128];
				if(sscanf(userMessage, "s[128]", reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!a (text)```");
					return 1;
				}
				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][110], reason);
				format(msg, 200, "```yaml\nAdministrator Announcement: %s\n```", reason);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
    		}
	    	if(strfind(userMessage, "!tban") == 0)
			{
    		    strdel(userMessage, 0, 6);
    		    new id, time, reason[64];
    		    if(sscanf(userMessage, "iis[64]", id, time, reason))
    		    {
                    DCC_SendChannelMessageEx(channel, "```!tban (id) (hours) (reason)```");
                    return 1;
    		    }
    		    if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
    		    if(time <= 0 || time > 24)
    		    {
    		        DCC_SendChannelMessageEx(channel, "```!tban (id) (hours only 1-24) (reason)```");
                    return 1;
    		    }
    		    if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```Admins can be banned only in the game```");
					return 1;
				}
    		    DCC_GetGuildMemberNickname(Guild, author, userName);
    			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				new query[256];
				mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"')", Player[id][UserName], userName, reason, time*(60*60)+gettime());
				mysql_tquery(Base, query, "", "", "");
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || id == i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][49], Player[id][UserName], userName, time, reason);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][51]);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][52]);
		  	    DiscordChannel = DCC_FindChannelById("619186196718944256");
 				format(msg, sizeof msg, "```\n%s has been banned by %s for %d hours [Reason: %s]\n```", Player[id][UserName], userName, time, reason);
  				DCC_SendChannelMessageEx(DiscordChannel, msg);
  				IsBanned{id} = true;
		  	    PlayerKick(id);
				return 1;
			}
	    }

	    if(GetRolePermissions(0x00400000, Guild, author, role, perm_high, perm_low, channel))
	    {
	        if(strfind(userMessage, "!a") == 0)
    		{
	     		strdel(userMessage, 0, 3);
				new reason[128];
				if(sscanf(userMessage, "s[128]", reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!a (text)```");
					return 1;
				}
				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][110], reason);
				format(msg, 200, "```yaml\nAdministrator Announcement: %s\n```", reason);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
    		}
        	if(strfind(userMessage, "!tban") == 0)
			{
    		    strdel(userMessage, 0, 6);
    		    new id, time, reason[64];
    		    if(sscanf(userMessage, "iis[64]", id, time, reason))
    		    {
                    DCC_SendChannelMessageEx(channel, "```!tban (id) (hours) (reason)```");
                    return 1;
    		    }
    		    if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
    		    if(time <= 0 || time > 3)
    		    {
    		        DCC_SendChannelMessageEx(channel, "```!tban (id) (hours only 1-3) (reason)```");
                    return 1;
    		    }
    		    if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```Admins can be banned only in the game```");
					return 1;
				}
    		    DCC_GetGuildMemberNickname(Guild, author, userName);
    			if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				new query[256];
				mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"')", Player[id][UserName], userName, reason, time*(60*60)+gettime());
				mysql_tquery(Base, query);
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || id == i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][49], Player[id][UserName], userName, time, reason);
    			SendClientMessage(id, -1, serverLang[Player[id][pLang]][51]);
		  	    SendClientMessage(id, -1, serverLang[Player[id][pLang]][52]);
		  	    IsBanned{id} = true;
		  	    PlayerKick(id);
				return 1;
			}

	        if(strfind(userMessage, "!warn") == 0)
    		{
				strdel(userMessage, 0, 6);
				new id, reason[64];
				if(sscanf(userMessage, "is[64]", id, reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!warn (id) (reason)```");
					return 1;
				}

				if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
				DCC_GetGuildMemberNickname(Guild, author, userName);
	    		if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

				Player[id][Warnings]++;
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == id) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][145], Player[id][UserName], userName, Player[id][Warnings], reason);
				format(msg, 200, "%s(%d) has been warned by %s [Reason: %s]", Player[id][UserName], id, userName, reason);
				DCC_SendChannelMessageEx(channel, msg);
				ShowPlayerDialog(id, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", reason, "Ok", "");
				if(Player[id][Warnings] >= 3)
				{
					foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == id) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][146], Player[id][UserName]);
					PlayerKick(id);
					format(msg, 200, "%s(%d) has been kicked by %s [Reason: Warning limit]", Player[id][UserName], id, userName);
					DCC_SendChannelMessageEx(channel, msg);
				}
				return 1;
			}

			if(strfind(userMessage, "!mute") == 0)
    		{
				strdel(userMessage, 0, 6);
				new id, time, reason[64];
				if(sscanf(userMessage, "iis[64]", id, time, reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!mute (id) (minutes) (reason)```");
					return 1;
				}

				if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}
				DCC_GetGuildMemberNickname(Guild, author, userName);
	    		if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

                Player[id][Muted] = time*60;
 				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][111], Player[id][UserName], userName, time, reason);
 				format(msg, 200, "%s(%d) has been muted by %s for %d minutes [Reason: %s]", Player[id][UserName], id, userName, time, reason);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
			}

			if(strfind(userMessage, "!unmute") == 0)
    		{
				strdel(userMessage, 0, 8);
				new id;
				if(sscanf(userMessage, "i", id))
				{
				    DCC_SendChannelMessageEx(channel, "```!unmute (id)```");
					return 1;
				}
				if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}

				if(Player[id][Muted] == 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```The player isn't muted```");
					return 1;
				}

				DCC_GetGuildMemberNickname(Guild, author, userName);
	    		if(strlen(userName) <= 0) DCC_GetUserName(author, userName);

                Player[id][Muted] = 0;
 				foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][114], Player[id][UserName], userName);
 				format(msg, 200, "%s(%d) has been unmuted by %s", Player[id][UserName], id, userName);
				DCC_SendChannelMessageEx(channel, msg);
				return 1;
			}

			if(strfind(userMessage, "!kick") == 0)
    		{
				strdel(userMessage, 0, 6);
				new id, reason[64];
				if(sscanf(userMessage, "is[64]", id, reason))
				{
				    DCC_SendChannelMessageEx(channel, "```!kick (id) (reason)```");
					return 1;
				}
				if(!IsPlayerConnected(id))
				{
				    DCC_SendChannelMessageEx(channel, "```The player isn't connected```");
				    return 1;
				}

				if(Player[id][pAdmin] > 0)
				{
		    		DCC_SendChannelMessageEx(channel, "```The player is an Admin```");
					return 1;
				}

				DCC_GetGuildMemberNickname(Guild, author, userName);
	    		if(strlen(userName) <= 0) DCC_GetUserName(author, userName);
				foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == id) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][106], Player[id][UserName], userName, reason);
                format(msg, 200, "%s(%d) has been kicked by %s [Reason: %s]", Player[id][UserName], id, userName, reason);
				DCC_SendChannelMessageEx(channel, msg);
				PlayerKick(id);
				return 1;
			}
   		}
	}
    return 1;
}

fun CheckForBan(id, const User[], type, playerid, DStype)
{
	switch(type)
	{
	    case 0:
	    {
	        if(IsPlayerConnected(playerid))
	        {
		        if(cache_num_rows() > 0)
				{
				    SendClientMessageFormat(playerid, -1, "{FF0000}BANNED: {33CCFF}(Account ID %d) >> Name: %s", id, User);
				}
				else
				{
				    SendClientMessageFormat(playerid, -1, "{FF0000}{33CCFF}(Account ID %d) >> Name: %s", id, User);
				}
			}
	    }
	    case 1:
	    {
     		new msg[128];
     		if(DStype == 1) DiscordChannel = DCC_FindChannelById("674323910648397894");
     		else DiscordChannel = DCC_FindChannelById("613185790683513003");
			if(cache_num_rows() > 0)
			{
			    format(msg, 128, "```yaml\nBANNED: (Account ID %d) >> Name: %s\n```", id, User);
			    DCC_SendChannelMessageEx(DiscordChannel, msg);
			}
			else
			{
			    format(msg, 128, "```yaml\n(Account ID %d) >> Name: %s\n```", id, User);
				DCC_SendChannelMessageEx(DiscordChannel, msg);
			}
		}
	}
	return 1;
}

fun CheckISPBan(playerid) {
    if(cache_num_rows() > 0)
 	{
 	    foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Banned]", Player[playerid][UserName]);

        #if debug_mode == 0
        new name[64], msg[128], y, m, d, h, i, s;
        cache_get_value_name(0, "name", name, 64);

		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		DiscordChannel = DCC_FindChannelById("674323910648397894");
		format(msg, sizeof(msg), "```\n%04d-%02d-%02d %02d:%02d:%02d %s's ISP banned (%s)\n```", y, m, d, h, i, s, Player[playerid][UserName], name);
		DCC_SendChannelMessageEx(DiscordChannel, msg);
		#endif

		IsBanned{playerid} = true;
	 	PlayerKick(playerid);
 	}
	return 1;
}

fun CheckMachineBan(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Banned]", Player[playerid][UserName]);

        #if debug_mode == 0
        new y, m, d, h, i, s, msg[164], desc[128], ID[128];
        cache_get_value_name(0, "desc", desc, 128);
        cache_get_value_name(0, "ID", ID, 128);

		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		DiscordChannel = DCC_FindChannelById("674323910648397894");
		format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s's (%d) key banned (Key: %s) (Desc: %s)\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], ID, desc);
		DCC_SendChannelMessageEx(DiscordChannel, msg);
		#endif

		IsBanned{playerid} = true;
	 	PlayerKick(playerid);
 	}
 	return 1;
}

fun UnbanPlayerInDiscord(const userName[], const reason[])
{
	if(cache_num_rows())
	{
	    new query[128], msg[128];
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][47], reason, userName);
		mysql_format(Base, query, sizeof(query), "DELETE FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
		mysql_tquery(Base, query, "", "", "");
		format(msg, 128, "```%s has been unbanned by %s```", reason, userName);
		DCC_SendChannelMessageEx(DiscordChannel, msg);

		DiscordChannel = DCC_FindChannelById("624580613697175582");
		format(query, sizeof query, "```\n%s has been unbanned by %s (IRC)\n```", reason, userName);
		DCC_SendChannelMessageEx(DiscordChannel, query);
	}
	else
	{
		DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
	}
	return 1;
}
#endif

fun CheckIpBan(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    /*foreach(Player, j)
	 	{
	 	    if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: IP Banned]", Player[playerid][UserName]);
		}
		IsBanned{playerid} = true;
	 	PlayerKick(playerid);*/
 	}
 	return 1;
}

fun CheckBan(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    new time, p, await;
 	    cache_get_value_name_int(0, "Permanent", p);
     	cache_get_value_name_int(0, "Time", time);
        cache_get_value_name_int(0, "await", await);
        
		if(p)
		{
		    new admin[MAX_PLAYER_NAME],reason[128];
     	    foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][43], Player[playerid][UserName]);
     	    cache_get_value_name(0, "Admin", admin);
            cache_get_value_name(0, "Why", reason, 128);
            SendClientMessage(playerid, -1, "Congratulations, you're {FF0000}banned!");
     	    SendClientMessageFormat(playerid, -1, "Reason: %s | Admin: %s", reason, admin);
     	    SendClientMessageFormat(playerid, -1, "Appeal at %s", FORUM);
		    PlayerKick(playerid);
		    return 1;
		}
 	    if(gettime() > time)
		{
		    new query[164];
			if(await <= 0) {
			    mysql_format(Base, query, sizeof(query), "DELETE FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", Player[playerid][UserName]);
				mysql_tquery(Base, query, "", "", "");
			} else {
                mysql_format(Base, query, sizeof(query), "UPDATE `banlog` SET `await` = '0' WHERE `acc` = '%d'", Player[playerid][pAccountID]);
                mysql_format(Base, query, sizeof(query), "UPDATE `banlist` SET `await` = '0', `Time` = '%d' WHERE `acc` = '%d'", (await*3600)+gettime(), Player[playerid][pAccountID]);
			}
		}
		else if(gettime() <= time || await >= 1)
		{
     	    new admin[MAX_PLAYER_NAME],reason[128], y, m, d, h, a, s;
     	    foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][44], Player[playerid][UserName]);
     	    cache_get_value_name(0, "Admin", admin);
            cache_get_value_name(0, "Why", reason, 128);
    		TimestampToDate(time, y, m, d, h, a, s, 3);
     	    SendClientMessage(playerid, -1, "Congratulations, you're {FF0000}temp banned!");
     	    SendClientMessageFormat(playerid, -1, "Reason: %s | Admin: %s", reason, admin);
     	    SendClientMessageFormat(playerid, -1, "Till: %02d.%02d.%04d %02d:%02d", d, m, y, h, a);
     	    SendClientMessageFormat(playerid, -1, "Appeal at %s", FORUM);
     	    PlayerKick(playerid);
		}
 	}
 	else
 	{
 	    new IP[16], serial[64], query[256];
 	    GetPlayerIp(playerid, IP, 16);
 	    gpci(playerid, serial, 64);
 	    mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `ip` = '%e' AND `gpci` = '%e' AND `build`='"SERVER_BUILD"'", IP, serial);
 		mysql_tquery(Base, query, "CheckBanEvader", "i", playerid);
 	}
 	return 1;
}

fun CheckBanEvader(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly Ban Evader", Player[playerid][UserName], playerid);
	}
 	return 1;
}

fun AutoLogin(playerid)
{
	if(cache_num_rows() > 0)
	{
	    new N[25], PIP[16], ip[16];
     	GetPlayerIp(playerid, ip, sizeof(ip));
        cache_get_value_name(0, "Name", N, 25);
        cache_get_value_name(0, "IP", PIP, 17);
        if(!strcmp(N, Player[playerid][UserName]) && !strcmp(PIP, ip)) SetPVarInt(playerid, "auto-log", 1);
	}
	else
	{
	    SetPVarInt(playerid, "auto-log", 0);
	}
	return 1;
}

#define VK_KEY_Z 0x5A

CMD:banport(playerid, params[])
{
	if(Player[playerid][pAdmin] > 3)
	{
    	if(sscanf(params, "i", params[0]))
		{
			SendClientMessage(playerid, -1, "/banport (port)");
    	    return 1;
		}
		if(params[0] <= 0)
		{
		    SendClientMessage(playerid, -1, "/banport (port)");
    	    return 1;
		}
        foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has blocked port %d!", Player[playerid][UserName], params[0]);
			if(Player[i][pPort] == params[0]) PlayerKick(i);
		}

        new query[144];
		mysql_format(Base, query, sizeof(query), "INSERT INTO `ports` (`ptr`) VALUE ('%d')", params[0]);
		mysql_tquery(Base, query, "", "", "");
		
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(query, sizeof query, "```\n%s used /banport %d\n```",  Player[playerid][RealName], params[0]);
			DCC_SendChannelMessageEx(DiscordChannel, query);
			#endif
		}
		return 1;
	}
	return 0;
}

CMD:unbanport(playerid, params[])
{
	if(Player[playerid][pAdmin] > 3)
	{
    	if(sscanf(params, "i", params[0]))
		{
			SendClientMessage(playerid, -1, "/unbanport (port)");
    	    return 1;
		}
		if(params[0] <= 0)
		{
		    SendClientMessage(playerid, -1, "/unbanport (port)");
    	    return 1;
		}
        foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s has unblocked port %d!", Player[playerid][UserName], params[0]);
		}

        new query[144];
		mysql_format(Base, query, sizeof(query), "DELETE FROM `ports` WHERE `ptr` = '%d'", params[0]);
  		mysql_tquery(Base, query, "", "", "");
		
		if(Player[playerid][pAdmin] <= 5)
		{
		    #if debug_mode == 0
			DiscordChannel = DCC_FindChannelById("623193667628433438");
			format(query, sizeof query, "```\n%s used /unbanport %d\n```",  Player[playerid][RealName], params[0]);
			DCC_SendChannelMessageEx(DiscordChannel, query);
			#endif
		}
		return 1;
	}
	return 0;
}

fun OnIncomingConnection(playerid, ip_address[], port)
{
	foreach(Player, i)
	{
	    if(Player[i][pAdmin] > 0 && Player[i][pLogged])
	    {
	        SendClientMessageFormat(i, -1, "{e1eaea}Incoming connection for player (ID %i) [IP & Port: %s:%i]", playerid, ip_address, port);
	    }
	}
	Player[playerid][pPort] = port;
	new query[144];
	mysql_format(Base, query, sizeof(query), "SELECT `ptr` FROM `ports` WHERE `ptr` = '%d' AND `build`='"SERVER_BUILD"'", port);
	mysql_tquery(Base, query, "GetBannedPort", "i", playerid);
    return 1;
}

fun GetBannedPort(playerid)
{
	if(cache_num_rows())
	{
	    PlayerKick(playerid);
	}
	return 1;
}

fun OnPlayerConnect(playerid)
{
    PR_VirtualWorldForPlayer[playerid] = 0;
	/////////////////////// EVENT //////////////////////////////////////////////
   	/*DestroyVehicle(EventTank[playerid]);
    DestroyVehicle(CurTankID[playerid]);
	EventTank[playerid] = -1;
	CurTankID[playerid] = -1;
 	CurTankTextID[playerid] = -1;
  	WarPlayerTeam[playerid] = -1;
  	WarTankSelected[playerid] = 0;
  	UserTankInWarState[playerid] = -1; // Event
    DestroyVehicle(CurTankID[playerid]);
    TK_CanDisplayEvent[playerid] = 1;
    
	DestroyVehicle(EventTank[playerid]);
	SetPlayerCameraPos(playerid, 646.8121, 1609.2610, 12.8967);
	SetPlayerCameraLookAt(playerid, 647.2643, 1608.3638, 12.6266);
	InterpolateCameraPos(playerid, 646.8121, 1609.2610, 12.8967, 646.8121, 1609.2610, 12.8967, 100, CAMERA_MOVE);
    InterpolateCameraLookAt(playerid, 647.2643, 1608.3638, 12.6266, 647.2643, 1608.3638, 12.6266, 100, CAMERA_MOVE);
	*/
	////////////////////////////////////////////////////////////////////////////
	
    Player[playerid][pChannel] = 0;
    
    IsUsingProxy{playerid} = false;
    PlayerPlaySound(playerid, 0, 0.0, 0.0, 0.0);
    IsPlayerDead[playerid] = false;
    Iter_Add(Players, playerid);
    
    RemoveObjects(playerid);
    SetPlayerHealthAC(playerid, 100.0);
    SetPlayerArmourAC(playerid, 0.0);

    GetPlayerName(playerid, Player[playerid][RealName], MAX_PLAYER_NAME);
    GetPlayerName(playerid, Player[playerid][UserName], MAX_PLAYER_NAME);
    
	if(mapid >= 2) Player[playerid][ConnectedMap] = mapid - 1;
	
    if(IsPlayerNPC(playerid))
    {
        foreach(Player, j)
		{
		    if(Player[j][pAdmin] > 0 && Player[j][pLogged] || j == playerid)
		    {
				SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) has been banned [Reason: NPC]", Player[playerid][UserName], playerid);
			}
		}
       	BanPlayer(playerid, "NPC hack");
		//PlayerKick(playerid);
	}

    SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
    Player[playerid][pClass][TEAM_HUMAN] = CIVILIAN;
	Player[playerid][pClass][TEAM_ZOMBIE+1] = STANDARDZOMBIE;
    Player[playerid][pClass][TEAM_HUMAN+1] = CIVILIAN;
	Player[playerid][pClass][TEAM_ZOMBIE+2] = STANDARDZOMBIE;
    Player[playerid][IsBurned][0] = 0;
    Player[playerid][IsBurned][1] = 0;
   	Player[playerid][aDuty] = false;
   	Portals[playerid] = INVALID_OBJECT_ID;
   	PlayerTextType[playerid] = 0;
   	Player[playerid][SlowWalk] = 0;
   	lotteryNumber[playerid] = -1;
   	p_FallingTime[playerid] = -1;
   	p_FallingCheck{playerid} = 0;
   	AimOff[playerid] = 0;
   	LastHealth[playerid][0] = 0.0;
   	LastHealth[playerid][1] = 0.0;
   	Player[playerid][Poisioned] = false;
   	Player[playerid][hasBleedEffect] = false;
   	S0beitSuspecting[playerid] = 0;
   	Player[playerid][Blidness] = 0;
   	KillTimer(Player[playerid][InfectedTimer]);
   	KillTimer(Player[playerid][PoisionTimer]);
   	KillTimer(Player[playerid][BlidnessTimer]);
   	KillTimer(Player[playerid][BleedingTimer]);
   	
   	TextDrawHideForPlayer(playerid, Blidnes[playerid]);
   	TextDrawHideForPlayer(playerid, Infected[playerid]);
   	TextDrawHideForPlayer(playerid, Poision[playerid]);
   	TextDrawHideForPlayer(playerid, GreenScreen[playerid]);
   	TextDrawHideForPlayer(playerid, Stun[playerid]);
    for( new i; i < 10; i++ ) RemovePlayerAttachedObject(playerid, i);
	CurePlayer(playerid);
    new query[164], IP[16], serial[41];
    GetPlayerIp(playerid, IP, 16);
    
    /*new contime = GetTickCount();
    if(strlen(gIP[playerid]) && gTime[playerid] != 0)
    {
        if(!strcmp(IP, gIP[playerid]))
        {
            foreach(Player, j)
			{
			    if(Player[j][pAdmin] > 0 && Player[j][pLogged] || j == playerid)
			    {
					SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) has been kicked [Reason: Fast reconnect]", Player[playerid][UserName], playerid);
				}
			}
            if(contime - gTime[playerid] < MIN_RECONNECT_TIME) PlayerKick(playerid);
            return 1;
        }
    }
    for(new i; i < MAX_PLAYERS; i++)
    {
        if((i == playerid) || IsPlayerConnected(i)) continue;
        if(strlen(gIP[i]))
        {
            if(!strcmp(IP, gIP[i]))
            {
                Kick(playerid);
               	return 1;
            }
        }
    }*/
    
	mysql_format(Base, query, sizeof(query), "SELECT * FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", Player[playerid][UserName]);
 	mysql_tquery(Base, query, "CheckBan", "i", playerid);
	
	mysql_format(Base, query, sizeof(query), "SELECT * FROM `autolog` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", Player[playerid][UserName]);
	mysql_tquery(Base, query, "AutoLogin", "i", playerid);
	
	mysql_format(Base, query, sizeof(query), "SELECT * FROM `banip` WHERE `IP` = '%e'", IP);
 	mysql_tquery(Base, query, "CheckIpBan", "i", playerid);
	
	gpci(playerid, serial, sizeof(serial));
	
	mysql_format(Base, query, sizeof(query), "SELECT * FROM `machines` WHERE `ID` = '%e'", serial);
 	mysql_tquery(Base, query, "CheckMachineBan", "i", playerid);
 	
	mysql_tquery(Base, "DELETE FROM `autolog` WHERE `time` < (NOW() - INTERVAL 6 HOUR) AND `build`='"SERVER_BUILD"'", "", "");
	
	mysql_format(Base, query, sizeof(query), "DELETE FROM `quest` WHERE `etime` <  '%d' AND `build`='"SERVER_BUILD"'", gettime() - 86400);
 	mysql_tquery(Base, query, "", "");
	
 	//GetPlayerIp(playerid, IP, 16);
 	
 	new i_numcount, i_pos;
 	while(i_pos < strlen(serial))
	{
 		if('0' <= serial[i_pos] <= '9') i_numcount ++;
   		i_pos++;
   	}
    if(i_numcount >= 30)
	{
		foreach(Player, i)
		{
		    if(Player[i][pAdmin] > 0 && Player[i][pLogged])
		    {
				SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) has been kicked [Reason: Unforeseen Error]", Player[playerid][UserName], playerid);
			}
		}
		PlayerKick(playerid);
		return 1;
	}
	
	if(CheckForWebsite(Player[playerid][UserName]))
	{
	    foreach(Player, i)
		{
		    if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == playerid)
		    {
				SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) has been kicked [Reason: Change your name]", Player[playerid][UserName], playerid);
			}
		}
		PlayerKick(playerid);
		return 1;
 	}
 	
 	new text[25];
 	strmid(text, Player[playerid][UserName], 0, 25, 25);
   	if(strfind(text, ".", true) != -1)
	{
	    new i_period;
        i_numcount = 0,
		i_pos = 0;
        while(text[i_pos])
		{
            if('0' <= text[i_pos] <= '9') i_numcount ++;
            else if(text[i_pos] == '.') i_period ++;
            i_pos++;
        }
        if(i_numcount >= 5 && i_period >= 3)
	 	{
	 	    foreach(Player, i)
			{
		    	if(Player[i][pAdmin] > 0 && Player[i][pLogged] || i == playerid)
		    	{
					SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) has been kicked [Reason: Change your name]", Player[playerid][UserName], playerid);
				}
			}
			PlayerKick(playerid);
      		return 1;
        }
	}
	
 	attemptsToLog[playerid] = 3;
 	
	RemoveBuildingForPlayer(playerid, 3425, -466.4297, 2190.2734, 55.9922, 0.25);
	Player[playerid][pLogged] = false;
	
    TextDrawHideForPlayer(playerid, SpawnProtection[playerid]);
    ResetWeapons(playerid);
	
	SetPlayerTime(playerid, 12, 0);
	SetPlayerWeather(playerid, 1);
	
	new y, m, d, h, i, s;
	TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		
    #if debug_mode == 0
    new msg[128];
    DiscordChannel = DCC_FindChannelById("612998988609880076");
    format(msg, sizeof msg, "%04d-%02d-%02d %02d:%02d %s (ID %d) has just joined the server.", y, m, d, h, i, Player[playerid][UserName], playerid);
    DCC_SendChannelMessageEx(DiscordChannel, msg);
    #endif
    resetVars(playerid); // <----
    AFK[playerid] = -2;
    GetPlayerIp(playerid, IP, 16);
    GetPlayerIpInfo(playerid, IP);
	return 1;
}

fun TryToSendEmail(playerid)
{
    if(cache_num_rows())
	{
	    new lastEmailSend;
 		cache_get_value_name_int(0, "lastEmailSend", lastEmailSend);
        if(lastEmailSend < gettime())
        {
            new strDest[16], strLen = 16;
    		while(strLen--) strDest[strLen] = CodeLetters[random(sizeof(CodeLetters))];
    
		    new message_str[] = "Hello-%s,--your-new-secret-word-is--%s", params[128];
		    format(params, sizeof(params), message_str, Player[playerid][UserName], strDest);
		    new request_to_the_server[512];

		 	format(request_to_the_server,sizeof(request_to_the_server), "theme=%s&msg=%s&email=%s", "SAMPZDM-Community", params, Player[playerid][pEmail]);
		  	HTTP(0, HTTP_POST, "sampzdmailer.000webhostapp.com/8f7a1c2q7r4f.php", request_to_the_server, "EmailDelivered");
		    SendClientMessageFormat(playerid, -1, "{FFF000}>> Email with the new secret word has been send to{FFFFFF} %s!", Player[playerid][pEmail]);

		    mysql_format(Base, request_to_the_server, sizeof(request_to_the_server), "UPDATE `users` SET `Secret`='%e',`lastEmailSend`='%d' WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", strDest, gettime()+86400, Player[playerid][pAccountID]);
			mysql_tquery(Base, request_to_the_server, "", "");
		}
		else
		{
		    SendClientMessage(playerid, -1, "{FFF000}>> You already got an email, wait for 24 hours!");
		}
	}
	else
	{
	    SendClientMessage(playerid, -1, "{FFF000}>> Error while trying to send an email!");
	}
	return 1;
}

fun __cril(playerid)
{
    if(strlen(Player[playerid][pEmail]) >= 1) return 0;
    ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account", "Ok", "Back");
    return 1;
}

CMD:email(playerid)
{
    if(strlen(Player[playerid][pEmail]) >= 1)
    {
        if(strfind(Player[playerid][pEmail], "@") >= 3)
        {
            new request_to_the_server[256];
		  	mysql_format(Base, request_to_the_server, sizeof(request_to_the_server), "SELECT `lastEmailSend` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
		  	mysql_tquery(Base, request_to_the_server, "TryToSendEmail", "i", playerid);
		}
		else
		{
            SendClientMessage(playerid, -1, "Your email isn't valid! Use /changeemail");
	    	return 1;
		}
	}
	else
	{
	    __cril(playerid);
	    return 1;
	}
	return 1;
}

fun EmailDelivered(index, response_code, data[])
{
	printf("Email Code: %d", response_code);
	
    return 1;
}

fun HTTP_OnPlayerProxyCheck(playerid, response_code, data[])
{
    #if debug_mode == 0
	if(response_code == 200)
	{
		switch(data[0])
		{
			case 'Y','y':
			{
			    IsUsingProxy{playerid} = true;
			    foreach(Player, j) if(Player[j][pAdmin] >= 1 && Player[j][pLogged])
				{
					SendClientMessageFormat(j, -1, "{6A8EE2}|: %s(%d) redirects traffic to another place. (VPN detected)", Player[playerid][UserName], playerid);
                    SendClientMessageFormat(j, -1, "{6A8EE2}|: Filtered and saved to the database. Account ID: %d", Player[playerid][pAccountID]);
					GameTextForPlayer(j, "VPN USER", 3000, 1);
				}
				new query[264], IP[16], str[512];
				GetPlayerIp(playerid, IP, 16);
				mysql_format(Base, query, sizeof(query), "INSERT INTO `vpns` (`acc`,`kie`,`login`,`country`,`ip`) VALUES ('%d','%e','%d','%e','%e')", Player[playerid][pAccountID], Player[playerid][pGPCI], gettime(), Player[playerid][pRegion], IP);
				mysql_tquery(Base, query, "", "", "");
				
				new y, m, d, h, i, s;
  				TimestampToDate(gettime(), y, m, d, h, i, s, 3);
				
				DiscordChannel = DCC_FindChannelById("614265642966843404");
	    		format(str, sizeof str, "```%04d-%02d-%02d %02d:%02d:%02d Proxy Detected: %s(%d) (REG: %s | CUR: %s)```", y, m, d, h, i, s, Player[playerid][UserName], Player[playerid][pAccountID], Player[playerid][pIP], IP);
				DCC_SendChannelMessageEx(DiscordChannel, str);
				
				DiscordChannel = DCC_FindChannelById("674323910648397894");
				format(str, sizeof str, "```[SECURITY] %04d-%02d-%02d %02d:%02d:%02d Proxy Detected: %s(%d)```", y, m, d, h, i, s, Player[playerid][UserName], Player[playerid][pAccountID]);
				DCC_SendChannelMessageEx(DiscordChannel, str);
				
				//Kick(playerid);
				
				return 1;
			}
			case 'N','n': IsUsingProxy{playerid} = false;
			case 'X','x': return printf("(Proxy Detector): invalid ip format.");
			default: return printf("The request failed! The response code was: %d", response_code);
		}
	}
	printf("The response code was: %d", response_code);
	#endif
	
	return 1;
}

fun CheckForRegs(playerid)
{
    new query[400], IP[16];
    GetPlayerIp(playerid, IP, sizeof(IP));
    if(cache_num_rows() > 0)
 	{
 	    cache_get_value_name_int(0, "reg_date", Player[playerid][pRegDate]);
 	    cache_get_value_name(0, "last_ip", Player[playerid][pLastIP], 17);
        mysql_format(Base, query, sizeof(query), "UPDATE `userinfo` SET `last_ip` ='%e',`last_log`='%d',`port`='%d' WHERE `id` = '%d'", IP, gettime(), Player[playerid][pPort], Player[playerid][pAccountID]);
		mysql_tquery(Base, query, "", "", "");
 	}
 	else
 	{
        mysql_format(Base, query, sizeof(query), "INSERT INTO `userinfo` (`id`,`last_ip`,`reg_date`,`port`) VALUES ('%d','%e','%d','%d')", Player[playerid][pAccountID], IP, gettime(), Player[playerid][pPort]);
		mysql_tquery(Base, query, "", "", "");
		Player[playerid][pRegDate] = gettime();
		Player[playerid][pLastIP] = IP;
 	}
	return 1;
}

fun CheckForEXP(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    #if debug_mode == 0
 	    new delete[128], a, y, m, d, h, i, s, msg[350];
		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		DiscordChannel = DCC_FindChannelById("680543908828151818");
 	    
 	    for( new j; j < cache_num_rows(); j++ )
 	    {
	 	    new desc[144], type = 0;
	 	    cache_get_value_name_int(j, "amount", a);
	 	    cache_get_value_name_int(j, "type", type);
	        cache_get_value_name(j, "desc", desc, 145);
	        if(a > 0)
			{
				switch(type)
				{
					case 0:
					{
						Player[playerid][pXP] += a;
						SendClientMessageFormat(playerid, -1, "{6A8EE2}>> You have received enrollment in %d experience", a);
						
						if(strlen(desc) <= 0) format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got a payment in %d EXP\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], a);
						else format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got a payment in %d EXP (%s)\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], a, desc);
						DCC_SendChannelMessageEx(DiscordChannel, msg);
					}
					case 1:
					{
						Player[playerid][pBalance] += float(a);
						SendClientMessageFormat(playerid, -1, "{6A8EE2}>> You have received enrollment in %d zaps", a);
						
						format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got a payment in %d ZAPs\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], a);
						DCC_SendChannelMessageEx(DiscordChannel, msg);
					}
					default:
					{
						Player[playerid][pXP] += a;
					    SendClientMessageFormat(playerid, -1, "{6A8EE2}>> You have received enrollment in %d experience", a);
					    
					    if(strlen(desc) <= 0) format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got a payment in %d EXP\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], a);
						else format(msg, sizeof(msg), "```\n%04d-%02d-%02d %s[%d] got a payment in %d EXP (%s)\n```", y, m, d, Player[playerid][UserName], Player[playerid][pAccountID], a, desc);
						DCC_SendChannelMessageEx(DiscordChannel, msg);
					}
				}
				if(strlen(desc) && a > 0) SendClientMessageFormat(playerid, -1, "{6A8EE2}>> Additional Information:{FFFFFF} %s", desc);
			}
	        mysql_format(Base, delete, sizeof(delete), "DELETE FROM `paydays` WHERE `acc` = '%d'", Player[playerid][pAccountID]);
			mysql_tquery(Base, delete, "", "", "");
		}
		#endif
 	}
 	return 1;
}

fun CheckForUser(playerid)
{
    //SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][152], Name(playerid), playerid, IP, country);
    if(cache_num_rows() > 0)
 	{
		new salt[128],lists[3][24], attach[400], playerIP[16], kie[41];
		cache_get_value_name_int(0, "ID", Player[playerid][pAccountID]);
        cache_get_value_name_int(0, "Kills", Player[playerid][pKills]);
        cache_get_value_name_int(0, "pk", Player[playerid][pPlayerKills]);
        
        cache_get_value_name_int(0, "total_pk", Player[playerid][totalPlayersKilledInGW]);
        
        cache_get_value_name_int(0, "Cards", Player[playerid][pCardSet]);
        
        cache_get_value_name_int(0, "pkb", Player[playerid][pPlayerKillsBack]);
        cache_get_value_name_int(0, "Killstreak", Player[playerid][pKillstreakMax]);
        cache_get_value_name_float(0, "bal", Player[playerid][pBalance]);
        cache_get_value_name_int(0, "RoundWins", Player[playerid][RoundsWin]);
        cache_get_value_name_int(0, "DuelWins", Player[playerid][DuelsWin]);
        cache_get_value_name_int(0, "DuelLoses", Player[playerid][DuelsLose]);
        cache_get_value_name_int(0, "VIP", Player[playerid][pVip]);
        cache_get_value_name_int(0, "Admin", Player[playerid][pAdmin]);
        cache_get_value_name_int(0, "Rank", Player[playerid][pRank]);
        cache_get_value_name_int(0, "EXP", Player[playerid][pXP]);
        cache_get_value_name_int(0, "Clan", Player[playerid][pClan]);
        cache_get_value_name_int(0, "ClanRank", Player[playerid][pClanRank]);
        cache_get_value_name_int(0, "ClanWarns", Player[playerid][pClanWarns]);
        cache_get_value_name_int(0, "ref", Player[playerid][pRefID]);
        
        cache_get_value_name(0, "Password", salt, sizeof(salt));

        cache_get_value_name(0, "Email", Player[playerid][pEmail], 255);
        
        cache_get_value_name_int(0, "Language", Player[playerid][pLang]);
        cache_get_value_name_int(0, "settings", Player[playerid][pSettings]);
        cache_get_value_name_int(0, "gbnd", Player[playerid][GangBanned]);
        cache_get_value_name_int(0, "points", Player[playerid][pUpgPoints]);
        
        cache_get_value_name_int(0, "lastGangJoin", Player[playerid][pLastGangJoin]);
        
        cache_get_value_name(0, "kie", kie);
        cache_get_value_name(0, "Secret", Player[playerid][pSecret], 65);
        
        cache_get_value_name(0, "IP", playerIP);
        cache_get_value_name(0, "ZombieList", lists[0]);
        cache_get_value_name(0, "HumanList", lists[1]);

        cache_get_value_name_int(0, "VipTime", Player[playerid][pVipTime]);

        cache_get_value_name(0, "attachID", lists[2]);
        cache_get_value_name(0, "attachPos", attach);

		cache_get_value_name_int(0, "days", Player[playerid][e_Days]);
		cache_get_value_name_int(0, "plg", Player[playerid][e_PrevLogin]);
		
        sscanf(lists[2],"p<,>iiiiiiii", Player[playerid][pAttID][0], Player[playerid][pAttID][1], Player[playerid][pAttID][2], Player[playerid][pAttID][3], Player[playerid][pAttID][4], Player[playerid][pAttID][5], Player[playerid][pAttID][6], Player[playerid][pAttID][7]);
        sscanf(attach,"p<,>ffffffffffffffffffffffffffffffffffff",
		Player[playerid][pAttIDPos][0], Player[playerid][pAttIDPos][1],
		Player[playerid][pAttIDPos][2], Player[playerid][pAttIDPos][3],
		Player[playerid][pAttIDPos][4], Player[playerid][pAttIDPos][5],
		Player[playerid][pAttIDPos][6], Player[playerid][pAttIDPos][7],
		Player[playerid][pAttIDPos][8], Player[playerid][pAttIDPos][9],
		Player[playerid][pAttIDPos][10], Player[playerid][pAttIDPos][11],
		Player[playerid][pAttIDPos][12], Player[playerid][pAttIDPos][13],
		Player[playerid][pAttIDPos][14], Player[playerid][pAttIDPos][15],
		Player[playerid][pAttIDPos][16], Player[playerid][pAttIDPos][17],
		Player[playerid][pAttIDPos][18], Player[playerid][pAttIDPos][19],
		Player[playerid][pAttIDPos][20], Player[playerid][pAttIDPos][21],
		Player[playerid][pAttIDPos][22], Player[playerid][pAttIDPos][23],
		Player[playerid][pAttIDPos][24], Player[playerid][pAttIDPos][25],
		Player[playerid][pAttIDPos][26], Player[playerid][pAttIDPos][27],
		Player[playerid][pAttIDPos][28], Player[playerid][pAttIDPos][29],
		Player[playerid][pAttIDPos][30], Player[playerid][pAttIDPos][31],
		Player[playerid][pAttIDPos][32], Player[playerid][pAttIDPos][33],
		Player[playerid][pAttIDPos][34], Player[playerid][pAttIDPos][35]);

        sscanf(lists[0],"p<,>ii", Player[playerid][pZombieClassesUnlocked_0], Player[playerid][pZombieClassesUnlocked_1]);
        sscanf(lists[1],"p<,>ii", Player[playerid][pHumanClassesUnlocked_0], Player[playerid][pHumanClassesUnlocked_1]);
        strmid(Player[playerid][pPass], salt, false, 128, 128);
        strmid(Player[playerid][pIP], playerIP, false, 16, 16);
        
        new IP[16];
        GetPlayerIp(playerid, IP, sizeof(IP));
        strmid(Player[playerid][pCurIP], IP, false, 16, 16);
        
        strmid(Player[playerid][pGPCI], kie, false, 40, 41);
        
        new query[512];
 		mysql_format(Base, query, sizeof(query), "SELECT * FROM `Achievements` WHERE `ID` = '%d'", Player[playerid][pAccountID]);
 		mysql_tquery(Base, query, "LoadAchievements", "i", playerid);
 		
 		mysql_format(Base, query, sizeof(query), "SELECT * FROM `timeout` WHERE `ID` = '%d'", Player[playerid][pAccountID]);
 		mysql_tquery(Base, query, "LoadTimeout", "i", playerid);
 		
 		new y, month, d;
 		getdate(y, month, d);
 		if( d == 1 )
 		{
            Player[playerid][AdminActivity][4] = 0;
 		    Player[playerid][AdminActivity][3] = 0;
		    Player[playerid][AdminActivity][2] = 0;
		    Player[playerid][AdminActivity][1] = 0;
		    Player[playerid][AdminActivity][0] = 0;
 		}
 		else
 		{
	 		mysql_format(Base, query, sizeof(query), "SELECT * FROM `aactivity` WHERE `id` = '%d' AND `month` = '%d' AND `year` = '%d'", Player[playerid][pAccountID], month, y);
	 		mysql_tquery(Base, query, "LoadAdminActivity", "i", playerid);
 		}
 		
        if(GetUnlockedSlot(Player[playerid][pSettings], 30) == 1 && (Player[playerid][pAdmin] <= 0 || Player[playerid][pAdmin] > 3)) SetUnlockedSlot(Player[playerid][pSettings], 30, 0);
        
        new str[200];
        
        new g[41];
		gpci(playerid, g, sizeof(g));
        if(strcmp(Player[playerid][pGPCI], g) && strlen(Player[playerid][pGPCI]) >= 1)
		{
		    #if debug_mode == 0
 			DiscordChannel = DCC_FindChannelById("614265642966843404");
			new m, h, i, s, ip[16];
			GetPlayerIp(playerid, ip, sizeof(ip));
  			TimestampToDate(gettime(), y, m, d, h, i, s, 3);
					  	
    		format(str, sizeof str, "%04d-%02d-%02d %02d:%02d:%02d Data Mismatch: %s(%d)  - (REG: %s | CUR: %s)", y, m, d, h, i, s, Player[playerid][UserName], Player[playerid][pAccountID], Player[playerid][pIP], ip);

            mysql_format(Base, query, sizeof(query), "INSERT INTO `security` (`acc`,`ip`,`date`,`reg`,`sign`,`type`) VALUES ('%d','%e','%d','%e','%e', '0')", Player[playerid][pAccountID], ip, gettime(), Player[playerid][pIP], g);
			mysql_tquery(Base, query, "", "", "");

			DCC_SendChannelMessageEx(DiscordChannel, str);
			#endif
		}
        
        if(GetPVarInt(playerid, "auto-log") == 0 || GetPVarInt(playerid, "auto-log") == 1 && GetUnlockedSlot(Player[playerid][pSettings], PS_AUTO_LOGIN) == 0)
		{
		    Registered{playerid} = true;
		    if(Player[playerid][pLang] == 1)
			{
				format(str, sizeof(str), ServerRegisters[Player[playerid][pLang]][8], 3);
                ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][7], str, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
			}
			else
			{
				format(str, sizeof(str), ServerRegisters[Player[playerid][pLang]][7], 3);
				ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][6], str, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
			}
        	RegisterTimer[playerid] = SetTimerEx("TooMuchTimeOfThinking", 120000, false, "i", playerid);
 		}
 		else
 		{
 		    Registered{playerid} = true;
 		    SendClientMessage(playerid, -1, "{FFF000}>> Auto-Login");
			Player[playerid][pLogged] = true;
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `paydays` WHERE `acc` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "CheckForEXP", "i", playerid);
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `userinfo` WHERE `id` = '%d'", Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "CheckForRegs", "i", playerid);
			KillTimer(RegisterTimer[playerid]);
		 	playerOnline++;
		 	SignCreate(playerid);
 		}
	}
 	else
 	{
 	    Registered{playerid} = false;
 	   	RegisterTimer[playerid] = SetTimerEx("TooMuchTimeOfThinking", 300000, false, "i", playerid);
 	   	
 	   	ShowPlayerDialog(playerid, DIALOG_REGISTER_LANGUAGE, DIALOG_STYLE_LIST, "{FF0000}Language - Язык - Idioma", "{FF0000}English (LATEST STANDARD & UPDATE)\n{FFFFFF}Русский\n{FFFFFF}Spanish", "Select", "Close");
 	   	
		foreach(Player, i)
		{
		    switch(Player[i][pLang])
		    {
				case 0: SendClientMessageFormat(i, -1, "Welcome the new player to our server{e65c00} %s (ID %d)!", Player[playerid][UserName], playerid);
		        case 1: SendClientMessageFormat(i, -1, "Приветствуем нового игрока на нашем сервере{e65c00} %s (ИД %d)!", Player[playerid][UserName], playerid);
		        case 2: SendClientMessageFormat(i, -1, "Bienvenido al nuevo jugador a nuestro servidor{e65c00} %s (ID %d)!", Player[playerid][UserName], playerid);
			}
		}
	}
}

fun CheckForPlayerExists(playerid)
{
	new query[128]; // Important?
	mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Name` = '%e' AND `build` = '%e'", Player[playerid][UserName], SERVER_BUILD);
	mysql_tquery(Base, query, "CheckForUser", "i", playerid);
	return 1;
}

fun OnPlayerDisconnect(playerid, reason)
{
	/////////////////////////////////////// EVENT //////////////////////////////
    /*DestroyVehicle(EventTank[playerid]);
    DestroyVehicle(CurTankID[playerid]);
    EventTank[playerid] = -1;
	CurTankID[playerid] = -1;
 	CurTankTextID[playerid] = -1;
 	WarTankSelected[playerid] = 0;
  	WarPlayerTeam[playerid] = -1;
  	UserTankInWarState[playerid] = -1;
    removefromTankevent(playerid);
    DestroyVehicle(CurTankID[playerid]);
    EventWaitForBeCounted[playerid] = 0;
    TK_CanDisplayEvent[playerid] = 1;*/
    /////////////////////////////////////// ////////////////////////////////
    
    
    
    Iter_Remove(Players, playerid);
    GetPlayerIp(playerid, gIP[playerid], 16);
    gTime[playerid] = GetTickCount();
    
    if(!AdminOnline() && !AntiCheatAlertMode)
    {
        SendClientMessageToAll(-1, "{FF0077}>> Anti-cheat went into high alert mode.");
        AntiCheatAlertMode = true;
        reportsCount = 0;
    }
    
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("612998988609880076");
    
    if(IsBanned{playerid})
    {
        new msg[128], y, m, d, h, i, s;
		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
    	format(msg, sizeof msg, "%04d-%02d-%02d %02d:%02d %s has left the server. (Banned)", y, m, d, h, i, Player[playerid][UserName]);
    	DCC_SendChannelMessageEx(DiscordChannel, msg);
    }
    else
    {
	    new msg[128], y, m, d, h, i, s;
	    TimestampToDate(gettime(), y, m, d, h, i, s, 3);
	    format(msg, sizeof msg, "%04d-%02d-%02d %02d:%02d %s has left the server. (%s)",  y, m, d, h, i, Player[playerid][UserName], serverLang[0][9 + reason]);
	    DCC_SendChannelMessageEx(DiscordChannel, msg);
    }
    #endif
    
    if(Player[playerid][pLogged]) playerOnline--;
    IsOnRegister[playerid] = false;
    
    DeletePVar(playerid, "Slide");
    DeletePVar(playerid,"flood");
    DeletePVar(playerid,"bunnyhop");
    DeletePVar(playerid,"cmdflood");
    
	foreach(Player, i)
	{
	    if(Player[i][pAdmin] > 0) SendClientMessageFormat(i,-1,"{C0C0C0}*** %s has left the server. [%s] [%s]", Player[playerid][UserName], serverLang[Player[i][pLang]][9 + reason], Player[playerid][pCurIP]);
		else SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][12], Player[playerid][UserName], serverLang[Player[i][pLang]][9 + reason]);
        Player[playerid][pIgnore][i] = false;
	}
	
	if(kick_player[playerid] == true)
 	{
 		foreach(Player, i) SendClientMessage(i,-1,serverLang[Player[i][pLang]][76]);
 	    votekick = false;
		voites = 0;
		kick_player[playerid] = false;
	}
	
	if(IsPlayerOnDuel[playerid])
	{
	    if(reason == 1)
	    {
		    CanUseCBugTime[playerid] = (gettime() + 20);
		    CanUseCBugTime[DuelerID[playerid]] = (gettime() + 20);

		    if(DuelEXP[DuelerID[playerid]] <= 0)
		    {
			    foreach(Player, i)
				{
				    switch(Player[i][pLang])
				    {
						case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
						case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
						case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
					}
				}
			}
			else
			{
			    if(Player[playerid][pXP] >= DuelEXP[playerid] && CanPay)
			    {
			        Player[playerid][pXP] -= DuelEXP[playerid];
			        Player[DuelerID[playerid]][pXP] += (DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));

					foreach(Player, i)
					{
					    switch(Player[i][pLang])
					    {
							case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s and got %d EXP!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
							case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s и получил %d ОПЫТА!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
							case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s y obtuve %d EXP!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
						}
					}
				}
				else
				{
				    foreach(Player, i)
					{
					    switch(Player[i][pLang])
					    {
							case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
							case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
							case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
						}
					}
				}
			}
	    }
	    else
	    {
		    foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
					case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
					case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
					case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
				}
			}
		}
		
		DuelReceived[DuelerID[playerid]] = false;

		DuelEXP[DuelerID[playerid]] = 0;
		DuelRules[0][DuelerID[playerid]] = 0;
		DuelRules[1][DuelerID[playerid]] = 0;

		DuelerID[DuelerID[playerid]] = -1;
		IsPlayerOnDuel[DuelerID[playerid]] = false;
		SetPlayerTeamEx(DuelerID[playerid], TEAM_ZOMBIE);
		
		Player[DuelerID[playerid]][DuelsWin]++;
		
		Player[playerid][DuelsLose]++;
		
        SetSpawnInfo(DuelerID[playerid],TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(DuelerID[playerid]);

		DuelReceived[playerid] = false;
		DuelerID[playerid] = -1;
		IsPlayerOnDuel[playerid] = false;
	}
	
	if(IsBeingSpeced[playerid])
    {
        foreach(Player,i)
        {
            if(spectatorid[i] == playerid && Player[i][pAdmin] > 0)
            {
                GameTextForPlayer(i,"~r~~n~Player is disconnected",2000,6);
                TogglePlayerSpectating(i, false);
            }
        }
    }
    
    foreach(Player,i)
    {
	    for( new j; j < 2; j++ )
	   	{
	   		if(NewSpawnPoints[j][0] != 0.0 && NewSpawnsCreators[j] == i)
			{
		 		NewSpawnsCreators[j] = INVALID_PLAYER_ID;
		 		Delete3DTextLabel(NewSpawnPointsText[j]);
		 		NewSpawnPoints[j][0] = 0.0;
			}
		}
	}
    
    /*if(GetTeamPlayersAlive(TEAM_HUMAN) >= 1 && Time <= 0)
	{
	    new count;
		foreach(Player, i)
		{
		    if(GetPlayerTeamEx(i) == TEAM_HUMAN && GetPlayerColor(i) == COLOR_EVACUATED)
			{
				count ++;
		    }
		}
		if(count >= GetTeamPlayersAlive(TEAM_HUMAN) && !MapStarted)
		{
		    KillTimer(mapvar[0]);
			KillTimer(mapvar[1]);
		    foreach(Player, i) SendClientMessage(i,-1, serverLang[Player[i][pLang]][39]);
			if(MapCanEnd) { SetTimer("EndMap", MAX_RESTART_TIME, false); MapCanEnd = false; }
			MapStarted = true;
		}
	}*/
	
	SaveUserData(playerid);
    Player[playerid][pLogged] = false;

    resetVars(playerid);
    for( new j; j < 18; j++ )
    {
	    if(IsValidObject(box[playerid][j]))
	    {
	    	DestroyObject(box[playerid][j]);
      		Delete3DTextLabel(boxText[playerid][j]);
      		box[playerid][j] = INVALID_OBJECT_ID;
		}
		box[playerid][j] = INVALID_OBJECT_ID;
	}
	
	if(IsValidObject(Portals[playerid]))
	{
	    DestroyObject(Portals[playerid]);
   		Delete3DTextLabel(PortalsText[playerid]);
   		Portals[playerid] = INVALID_OBJECT_ID;
	}
	
	if(reconnect[playerid])
	{
	    new unbanningip[16], string[128];
	    GetPVarString(playerid, "reconnect", unbanningip, 16);
	    format(string,sizeof(string),"unbanip %s", unbanningip);
    	SendRconCommand(string);
    	SendRconCommand("reloadbans");
    	reconnect[playerid] = false;
	}
	
	SortKillstreakList();
	DeleteFromKillstreakList(playerid);
	return 1;
}

stock Float:GetVipOnKillBonus(p) {
	switch(Player[p][pVip]) {
	    case 1: return 1.3;
	    case 2: return 1.6;
	    case 3: return 2.0;
	    default: return 1.0;
	}
	return 1.0;
}

stock GetVIPOnKSBonus(p) {
    switch(Player[p][pVip]) {
	    case 1: return 1;
	    case 2: return 2;
	    case 3: return 3;
	    default: return 1;
	}
	return 1;
}

fun OnPlayerDeath(playerid, killerid, reason)
{
    if(!IsPlayerConnected(playerid)) return 0;
    SetPlayerGravity(playerid, 0.008);
    GravityReset[playerid] = false;
    TormentTime[playerid] = 0;
    ARDestructionTime[playerid] = 0;
    for( new i = 0; i < MAX_PLAYERS; i++ ) HeadshotsInCount[playerid][i] = 0;
    KillTimer(Player[playerid][InfectedTimer]);
   	KillTimer(Player[playerid][PoisionTimer]);
   	KillTimer(Player[playerid][BleedingTimer]);
   	Player[playerid][hasBleedEffect] = false;
   	
    if(KilledBy[playerid] != INVALID_PLAYER_ID && IsPlayerDeadByWarMember[playerid] == INVALID_PLAYER_ID)
	{
		killerid = KilledBy[playerid];
        reason = KilledByWeapon[playerid];
	}
	
	KilledBy[playerid] = INVALID_PLAYER_ID;
    KilledByWeapon[playerid] = 0;
    
    if(!IsPlayerConnected(killerid)) killerid = INVALID_PLAYER_ID;
    
   	switch(reason)
	{
	    case WEAPON_PARACHUTE: reason = WEAPON_COLLISION;
	    case WEAPON_CARPARK: reason = WEAPON_VEHICLE;
	    case WEAPON_PISTOLWHIP: reason = WEAPON_UNARMED;
	    case WEAPON_VEHICLE_M4: reason = WEAPON_M4;
        case WEAPON_VEHICLE_MINIGUN: reason = WEAPON_MINIGUN;
    }
	if(reason < 0 && reason >= WEAPON_UNKNOWN) reason = WEAPON_DROWN;
	
	if(IsPlayerDeadByWarMember[playerid] == INVALID_PLAYER_ID) SendDeathMessage(killerid, playerid, reason);

	AntiCheat[playerid][ac_OldHP] = 0.0;
    AntiCheat[playerid][ex_OldHP] = 0.0;
    AntiCheat[playerid][weap_OldHP] = -100.0;
    
	////////////////////////////////////////////////////////////////////////
    
	if(killerid == INVALID_PLAYER_ID)
	{
	    if(IsPlayerOnDuel[playerid]) DeathInDuel(playerid);
	    else
	    {
    		CreatePetItem(playerid, killerid);
    		
		    IsPlayerDeadByWarMember[playerid] = INVALID_PLAYER_ID;

		    resetPlayerOnDeath(playerid, killerid); // Resets on Death
	    	resetPlayerOnDeathFromEvent(playerid); // Resets On Event
	    	resetAntis(playerid); // Reset Antis
	    	setupZombie(playerid);
	    }
	    
	    AFK[playerid] = -5;
	    
	    return 1;
	}

	if(reason >= 0 && reason <= 42)
	{
	    #if debug_mode == 0
		DiscordChannel = DCC_FindChannelById("612998988609880076");
    	new msg[128], gunname[32];
    	GetWeaponName(reason, gunname, sizeof(gunname));

        if(strlen(gunname) >= 2)
        {
			new query[900], serial[41];
			gpci(playerid, serial, sizeof(serial));

			mysql_format(Base, query, sizeof(query), "INSERT INTO `pactions` (`acc`,`type`,`date`,`text`,`sign`,`reg_sign`,`ip`) VALUES ('%d','1','%d','%e','%e', '%e', '%e')", Player[playerid][pAccountID], gettime(), gunname, serial, Player[playerid][pGPCI], Player[playerid][pIP]);
			mysql_tquery(Base, query, "", "", "");

		    gpci(killerid, serial, sizeof(serial));
			mysql_format(Base, query, sizeof(query), "INSERT INTO `pactions` (`acc`,`type`,`date`,`text`,`sign`,`reg_sign`,`ip`) VALUES ('%d','3','%d','%e','%e', '%e', '%e')", Player[killerid][pAccountID], gettime(), gunname, serial, Player[killerid][pGPCI], Player[killerid][pIP]);
			mysql_tquery(Base, query, "", "", "");

			new y, m, d, h, i, s;
			TimestampToDate(gettime(), y, m, d, h, i, s, 3);
	    	format(msg, sizeof msg, "%04d-%02d-%02d %02d:%02d %s been killed by %s (%s)", y, m, d, h, i, Player[playerid][UserName], Player[killerid][UserName], gunname);
	    	DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
		#endif
	}
	
 	if(IsPlayerConnected(killerid))
    {
		if(Player[playerid][pInGangMatch] && Player[killerid][pInGangMatch] && GetPlayerTeamEx(playerid) != GetPlayerTeamEx(killerid)) {
    		Player[killerid][pPlayerKills]++;
    		setHumanColor(killerid);
		}
		
		if(GetPlayerTeamEx(killerid) == TEAM_ZOMBIE && HumanHumanBoss[playerid])
	    {
			GivePlayerXP(killerid, 20);
			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][186], Player[killerid][UserName], Player[playerid][UserName]);
		}

		if(GetPlayerTeamEx(killerid) == TEAM_HUMAN && HumanZombieBoss[playerid])
	    {
	        #if debug_mode == 0
			new __action[256], y, m, d, h, s, o;
			TimestampToDate(gettime(), y, m, d, h, o, s, 3);
			DiscordChannel = DCC_FindChannelById("727667573654683758");
	        format(__action, sizeof(__action), "%d-%02d-%02d %02d:%02d (Zombie Boss) %s[%d] been killed by (Human) %s[%d]", y, m, d, h, o, Player[playerid][UserName], Player[playerid][pAccountID], Player[killerid][UserName], Player[killerid][pAccountID]);
			DCC_SendChannelMessageEx(DiscordChannel, __action);
			#endif

			GivePlayerXP(killerid, 20);
			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][167], Player[killerid][UserName], Player[playerid][UserName]);
		}
		
		if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) 		AchievementAddProgress(killerid, ach_KILLED_HUMANS);
		else if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) 	AchievementAddProgress(killerid, ach_KILLED_ZOMBIE);

		AchievementAddProgress(killerid, ach_KILLED_PLAYERS);
		
		if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && GetPlayerTeamEx(killerid) == TEAM_HUMAN && GetBitSlot(Achievements[killerid][ach_BMask][1], _:ach_KILL_IN_5_SEC) <= 0)
		{
		    if(Achievements[killerid][ctg_time][0] == 0 || gettime() > Achievements[killerid][ctg_time][0])
			{
				Achievements[killerid][ctg_time][0] = gettime() + 5;
		    	Achievements[killerid][ctg_time][1] = 1;
			}
			else Achievements[killerid][ctg_time][1]++;

		    if(gettime() < Achievements[killerid][ctg_time][0] && Achievements[killerid][ctg_time][1] >= 5) AchievementAddProgress(killerid, ach_KILL_IN_5_SEC);
	    }
	}
	
	AchievementAddProgress(playerid, ach_DIED_TIMES);
	
	resetPlayerOnDeath(playerid, killerid); // Resets on Death
    resetPlayerOnDeathFromEvent(playerid); // Resets On Event
    resetAntis(playerid); // Reset Antis
    //if(IsPlayerConnected(killerid)) AimSystemChecks(playerid, killerid); // Check for AIM
    
    if(IsPlayerConnected(killerid))
    {
        if(SuspectForAIM[killerid] && reason > 22)
        {
			foreach(Player, i)
			{
			    if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}[AIM-CHECKER]: %s(%d) killed {FFFFFF}%s{6A8EE2} with %d headshots!", Player[killerid][UserName], killerid, Player[playerid][UserName], HeadshotsInCount[killerid][playerid]);
			}
        }
        
        HeadshotsInCount[killerid][playerid] = 0;
        
        new current_tick = GetTickCount(), interval = GetTickDiff(current_tick, FakekillData[playerid][LastDeathTime]);
    	if(interval < FAKEKILL_DELAY)
        {
            FakekillData[playerid][DeathCount]++;
            if(FakekillData[playerid][DeathCount] == FAKEKILL_LIMIT)
            {
                IsBanned{playerid} = true;
                BanPlayer(playerid, "Fake Kill");
                FakekillData[playerid][DeathCount] = 0;
            }
            printf("Fake Kill");
            return 0;
        }
        else FakekillData[playerid][DeathCount] = 1;
        FakekillData[playerid][LastDeathTime] = GetTickCount();
        
        /***********************************************************************/
        
        if(!PlayerShotPlayer[killerid][playerid])
		{
		    Suspecting[playerid]++;
			if(Suspecting[playerid] >= 5)
	  		{
	  		    IsBanned{playerid} = true;
			  	BanPlayer(playerid, "Fake Kill");
			}
			PlayerShotPlayer[killerid][playerid] = false;
   			printf("Not Shot A Player");
			return 0;
		}
		
		if(IsPlayerOnDuel[playerid])
		{
			DeathInDuel(playerid);
			setupZombie(playerid);
			return 1;
		}
		
		if(IsPlayerOnDuel[killerid])
		{
			DeathDuelWin(playerid, killerid);
			setupZombie(killerid);
			return 1;
		}
		
		//////////////////////////////////// KILLS /////////////////////////////
		
		if(!FirstBlood)
	    {
	        if(GetPlayerTeamEx(playerid) == TEAM_HUMAN || GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	        {
		        foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][40], Player[killerid][UserName]);
				FirstBlood = true;
				GivePlayerXP(killerid, 10);
	    	}
		}

        ++Player[killerid][pKills];
		RankUp(killerid);
		
		if(GetPlayerTeamEx(killerid) == TEAM_HUMAN)
		{
			Player[killerid][Killstreak]++;
			UpdateKillstreaksList(killerid);
	 		AchievementAddProgress(killerid, ach_ACHIEVED_KILLSTREAK);
		}
		
		UpdateKillstreaksList(playerid);
		
		if((Player[killerid][Killstreak] % 5 == 0) && GetPlayerTeamEx(killerid) == TEAM_HUMAN && Player[killerid][Killstreak] >= 1)
		{
	    	foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][28], Player[killerid][UserName], Player[killerid][Killstreak], floor(Player[killerid][Killstreak] * GetVIPOnKSBonus(killerid) * GetVipOnKillBonus(killerid)));
			Player[killerid][pXP] += floor(Player[killerid][Killstreak] * GetVIPOnKSBonus(killerid) * GetVipOnKillBonus(killerid));
		}
		
		if(Player[killerid][pClan] > 0) Clan[Player[killerid][pClan]][EXP]+=floor(1*Map[m_XPType]*GetVipOnKillBonus(playerid));
		
		if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && GetPlayerTeamEx(killerid) == TEAM_HUMAN)
		{
			new st[32];
		    foreach(Player, i)
		    {
		        if(Player[i][CheckForProtect] == playerid) Player[i][CheckForProtect] = INVALID_PLAYER_ID;
	     		if(PlayerShotPlayer[i][playerid] && i != killerid && GetPlayerTeamEx(i) == TEAM_HUMAN)
	     		{
     		    	GivePlayerXP(i, floor(2 * Map[m_XPType] * GetVipOnKillBonus(playerid)));
     		    	switch(Player[i][pLang])
					{
					    case 0: format(st, 32, "~w~ASSIST:~n~~w~+_%d_]", floor(2 * Map[m_XPType] * GetVipOnKillBonus(playerid)));
						case 1: format(st, 32, RusToGame("~w~ПОМОЩЬ:~n~~w~+_%d_]"), floor(2 * Map[m_XPType] * GetVipOnKillBonus(playerid)));
						case 2: format(st, 32, "~w~AYUDAR:~n~~w~+_%d_]", floor(2 * Map[m_XPType] * GetVipOnKillBonus(playerid)));
					}
     		    	GameTextForPlayer(i, st, 2000, 5);
     		    	PlayerDamageChecker[i][DamageGiven] = 0.0;
     		    	PlayerDamageChecker[i][p_ID] = -1;
				}
				PlayerShotPlayer[i][playerid] = false;
		    }
		}
		
		new Float:multipler = 1.0;
		if(Player[killerid][pVip] == 1) multipler += 0.3;
		if(Player[killerid][pVip] == 2) multipler += 0.6;
		if(Player[killerid][pVip] == 3) multipler += 1.0;
		if(GetPlayerTeamEx(killerid) == TEAM_ZOMBIE) multipler += 1.0;
		
		if(Map[m_XPType] >= 2)
		{
		    switch(Player[killerid][pVip])
		    {
		        case 1: multipler += 1.3;
		        case 2: multipler += 1.6;
		        case 3: multipler += 2.0;
		        default: multipler += 1.0;
		    }
		}

		new x = floor(10*multipler);
		GivePlayerXP(killerid, x);
		if(Player[killerid][pRestTime] >= 0.1) Player[killerid][pRestTime] -= 0.1;
		
		////////////////////////////// FISTS ///////////////////////////////
		
		if(reason == 0)
	    {
	        new j;
		    for( j = 0; j < sizeof(Map[ZombieSpawnX]); j++ )
			{
     			if(IsPlayerInRangeOfPoint(playerid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j]))
     			{
     			    SetPlayerHealthAC(killerid, 0.0);
     			    ShowDamageTaken(killerid, 100.0);
				}
			}
		}
		
    	/////////////////////////////////////////// ZOMBIES ABILITIES /////////////
    
		if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == BOOMERZOMBIE) boomersOnDeath(playerid, 0);
        if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == DEMONZOMBIE) boomersOnDeath(playerid, 1);
        //if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == BOOMERZOMBIE) boomersOnDeath(playerid, 0);
		
		if(GetPlayerTeamEx(killerid) == TEAM_ZOMBIE && lastHuman[playerid] && !LastHumanKilled)
	    {
	        foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][41], Player[killerid][UserName]);
			GivePlayerXP(killerid, 10);
			LastHumanKilled = true;
		}
	}
	///////////////////////////////////// SETUP AS A ZOMBIE ////////////////////

    CreatePetItem(playerid, killerid);
	if(IsPlayerOnDuel[playerid]) DeathInDuel(playerid);
    
	setupZombie(playerid);
    IsPlayerDeadByWarMember[playerid] = INVALID_PLAYER_ID;
    AFK[playerid] = -5;
    
	////////////////////////////////////////////////////////////////////////////
	return 1;
}

stock CreatePetItem(playerid, killerid)
{
	new Float:pos[3];
	GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	
	foreach(Player, i)
	{
		if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == TORNADOZOMBIE && IsPlayerInRangeOfPoint(i, 15.0, pos[0], pos[1], pos[2]))
		{
	        GivePlayerXP(i, 2);
	    	return 0;
		}
	}
	
	if(IsPlayerConnected(killerid)) CreatePickupMeat(2804, 1, pos[0], pos[1], pos[2], 0, Player[killerid][pAccountID], playerid);
	else CreatePickupMeat(2804, 1, pos[0], pos[1], pos[2], 0, -1, playerid);
	return 1;
}

stock boomersOnDeath(playerid, type = 0)
{
 	new Float:pos[3], count, Float:radius = 5.5, bool:wAntiB;
	GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
    foreach(Player,i) if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2])) if(!CanBeInExplosion(i)) { wAntiB = true; break; }

	if(!wAntiB)
	{
	 	foreach(Player,i)
		{
	 		if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2]))
			{
			    switch(type)
			    {
			        case 0,2: if(InfectPlayer(radius, i, playerid)) count++;
			        case 1:
			        {
			            if(canBeBurned(i, true) && GetPlayerTeamEx(i) == TEAM_HUMAN)
			            {
							SetPlayerAttachedObject(i,9,18689,1,0.000000,-0.130999,-1.650999,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);
							Player[i][IsBurned][0] = 1;
							Player[i][IsBurned][1] = 2;
							count++;
						}
					}
				}
			}
	 	}
	 	
	 	switch(type)
	 	{
	 		case 0: CreateExplosion(pos[0], pos[1], pos[2], 0, 2.0);
            case 1: CreateExplosion(pos[0], pos[1], pos[2], 0, 2.5);
            case 2: CreateExplosion(pos[0], pos[1], pos[2], 0, 2.0);
		}
		
		switch(type)
		{
		    case 0:
		    {
				if(count >= 1 && count < 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][87], Player[playerid][UserName], count);
				if(count >= 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][88], Player[playerid][UserName], count);
			}
			case 1:
			{
			    if( count >= 1 && count < 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][89], Player[playerid][UserName], count);
				if( count >= 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][90], Player[playerid][UserName], count);
			}
			case 2:
			{
			    if(count >= 1 && count < 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][91], Player[playerid][UserName], count);
				if(count >= 5) foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][92], Player[playerid][UserName], count);
			}
		}
	}
}

stock DeathDuelWin(playerid, killerid)
{
    CanUseCBugTime[killerid] = (gettime() + 20);
    CanUseCBugTime[playerid] = (gettime() + 20);
    
    if(DuelEXP[killerid] <= 0)
    {
	    foreach(Player, i)
		{
		    switch(Player[i][pLang])
		    {
				case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[killerid][UserName], Player[playerid][UserName]);
				case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[killerid][UserName], Player[playerid][UserName]);
				case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[killerid][UserName], Player[playerid][UserName]);
			}
		}
	}
	else
	{
	    if(Player[playerid][pXP] >= DuelEXP[playerid] && CanPay)
	    {
	        Player[playerid][pXP] -= DuelEXP[playerid];
	        Player[killerid][pXP] += (DuelEXP[DuelerID[killerid]] - floor(DuelEXP[DuelerID[killerid]]*TAXES));

			foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
					case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s and got %d EXP!", Player[killerid][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[killerid]] - floor(DuelEXP[DuelerID[killerid]]*TAXES));
					case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s и получил %d ОПЫТА!", Player[killerid][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[killerid]] - floor(DuelEXP[DuelerID[killerid]]*TAXES));
					case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s y obtuve %d EXP!", Player[killerid][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[killerid]] - floor(DuelEXP[DuelerID[killerid]]*TAXES));
				}
			}
		}
		else
		{
		    foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
					case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[killerid][UserName], Player[playerid][UserName]);
					case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[killerid][UserName], Player[playerid][UserName]);
					case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[killerid][UserName], Player[playerid][UserName]);
				}
			}
		}
	}
	
	DuelEXP[killerid] = 0;
	DuelRules[0][killerid] = 0;
	DuelRules[1][killerid] = 0;

	DuelReceived[killerid] = false;
	DuelerID[killerid] = -1;
	IsPlayerOnDuel[killerid] = false;

	Player[killerid][DuelsWin]++;
	Player[playerid][DuelsLose]++;

    AchievementAddProgress(killerid, ach_DUELS_WIN);

	DuelReceived[playerid] = false;
	DuelerID[playerid] = -1;
	IsPlayerOnDuel[playerid] = false;
	SetPlayerTeamEx(killerid, TEAM_ZOMBIE);
	SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	SetSpawnInfo(killerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
	SpawnPlayer(killerid);
}

stock RankUp(playerid)
{
	for( new i = 0; i < sizeof(rank_names); i++ )
	{
		if(Player[playerid][pKills] >= rank_exp[i] && Player[playerid][pRank] < i)
		{
		    foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][197], Player[playerid][UserName], Player[playerid][UserName], rank_names[i]);
      		SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][198], rank_names[i]);

			switch(Player[playerid][pLang])
		    {
				case 0: GameTextForPlayer(playerid, "~y~Rank Up", 2000, 5);
		        case 1: GameTextForPlayer(playerid,RusToGame("~y~НОВЫЙ РАНГ"), 2000, 5);
		        case 2: GameTextForPlayer(playerid,"~y~Subir de rango", 2000, 5);
			}

			Player[playerid][pRank] = i;
		}
	}
}

stock DeathInDuel(playerid)
{
    CanUseCBugTime[playerid] = (gettime() + 20);
    CanUseCBugTime[DuelerID[playerid]] = (gettime() + 20);
    
    if(DuelEXP[DuelerID[playerid]] <= 0)
    {
	    foreach(Player, i)
		{
		    switch(Player[i][pLang])
		    {
				case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
				case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
				case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
			}
		}
	}
	else
	{
	    if(Player[playerid][pXP] >= DuelEXP[playerid] && CanPay)
	    {
	        Player[playerid][pXP] -= DuelEXP[playerid];
	        Player[DuelerID[playerid]][pXP] += (DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
	        
			foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
					case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s and got %d EXP!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
					case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s и получил %d ОПЫТА!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
					case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s y obtuve %d EXP!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName], DuelEXP[DuelerID[playerid]], DuelEXP[DuelerID[playerid]] - floor(DuelEXP[DuelerID[playerid]]*TAXES));
				}
			}
		}
		else
		{
		    foreach(Player, i)
			{
			    switch(Player[i][pLang])
			    {
					case 0: SendClientMessageFormat(i, -1, "{e9dec8}>> %s has won the duel against %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
					case 1: SendClientMessageFormat(i, -1, "{e9dec8}>> Игрок %s выиграл дуэль против игрока %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
					case 2: SendClientMessageFormat(i, -1, "{e9dec8}>> El jugador %s gano un duelo contra un jugador %s!", Player[DuelerID[playerid]][UserName], Player[playerid][UserName]);
				}
			}
		}
	}
	
	DuelReceived[DuelerID[playerid]] = false;
	
	DuelEXP[DuelerID[playerid]] = 0;
	DuelRules[0][DuelerID[playerid]] = 0;
	DuelRules[1][DuelerID[playerid]] = 0;
	
	DuelerID[DuelerID[playerid]] = -1;
	IsPlayerOnDuel[DuelerID[playerid]] = false;
	SetPlayerTeamEx(DuelerID[playerid], TEAM_ZOMBIE);

	Player[DuelerID[playerid]][DuelsWin]++;
    AchievementAddProgress(DuelerID[playerid], ach_DUELS_WIN);
    
	Player[playerid][DuelsLose]++;

    SetSpawnInfo(DuelerID[playerid],TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
	SpawnPlayer(DuelerID[playerid]);

	DuelReceived[playerid] = false;
	DuelerID[playerid] = -1;
	IsPlayerOnDuel[playerid] = false;
	SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
}

stock DeathInWar(playerid, killerid)
{
    if(!IsPlayerConnected(killerid)) return 1;
    if(!IsPlayerConnected(playerid)) return 1;
	return 1;
}

stock resetAntis(playerid)
{
    Player[playerid][IsBurned][0] = 0;
	Player[playerid][IsBurned][1] = 0;
   	KillTimer(Player[playerid][InfectedTimer]);
   	KillTimer(Player[playerid][PoisionTimer]);
   	KillTimer(Player[playerid][BleedingTimer]);
   	
    TextDrawHideForPlayer(playerid, Poision[playerid]);
    TextDrawHideForPlayer(playerid, GreenScreen[playerid]);
    TextDrawHideForPlayer(playerid, Stun[playerid]);
    TextDrawHideForPlayer(playerid, Blidnes[playerid]);
    TextDrawHideForPlayer(playerid, Infected[playerid]);
    Player[playerid][Blidness] = 0;
    KillTimer(Player[playerid][BlidnessTimer]);
    Player[playerid][Tasered] = false;
    Player[playerid][Poisioned] = false;
    Player[playerid][hasBleedEffect] = false;
   	for( new i = 0; i < MAX_SELLING_INFO; i++) Player[playerid][isInSelling][i] = -1;
}

stock GetTickDiff(newtick, oldtick)
{
	if (oldtick > newtick) return (cellmax - oldtick + 1) - (cellmin - newtick);
	return newtick - oldtick;
}

stock AimSystemChecks(playerid, killerid)
{
	if(IsPlayerConnected(killerid))
	{

	}
}

stock resetPlayerOnDeath(playerid, killerid)
{
    Player[playerid][pWasGangAffected] = false;
    Player[playerid][hasBleedEffect] = false;
	ZombieMoveTime[playerid] -= 10;
	SetPlayerHealthAC(playerid, 100.0, true);
	SetPlayerArmourAC(playerid, 0.0);
	
	KillTimer(Player[playerid][PoisionTimer]);
	KillTimer(Player[playerid][InfectedTimer]);
	KillTimer(Player[playerid][BleedingTimer]);

	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
		Player[playerid][Evacuated] = 0;
		
		if(IsPlayerDeadByWarMember[playerid] != INVALID_PLAYER_ID) {}
		else
		{
			if(IsPlayerConnected(killerid))
			{
				if(Player[playerid][Killstreak] >= 5)
				{
				    Player[killerid][pXP] += Player[playerid][Killstreak];
				    foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][59], Player[killerid][UserName], Player[playerid][Killstreak], Player[playerid][UserName], Player[playerid][Killstreak]);
                    if(Player[playerid][Killstreak] == 99) AchievementAddProgress(playerid, ach_SHOCK);
				}

				if(Player[playerid][Killstreak] > Player[playerid][pKillstreakMax])
				{
				    foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][60], Player[playerid][UserName], Player[playerid][Killstreak], Player[playerid][pKillstreakMax]);
			        Player[playerid][pKillstreakMax] = Player[playerid][Killstreak];
				}
			}
			Player[playerid][Killstreak] = 0;
			SortKillstreakList();
			DeleteFromKillstreakList(playerid);
		}
	}
	CurePlayer(playerid);
	Player[playerid][IsCursed] = false;
	HumanZombieBoss[playerid] = false;
	HumanHumanBoss[playerid] = false;
    Healer[playerid] = false;
}

stock resetPlayerOnDeathFromEvent(playerid)
{
    Player[playerid][hasBleedEffect] = false;
    KillTimer(Player[playerid][PoisionTimer]);
	KillTimer(Player[playerid][InfectedTimer]);
	KillTimer(Player[playerid][BleedingTimer]);
	
    if(Player[playerid][eventMember] > -1)
	{
	    new bool:something = false, str[144], i;
	    for(i = 0; i < 10; i++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][i] == Player[playerid][pAccountID]) { something = true; break; }

		new eventID = Player[playerid][eventMember];
	    if(strlen(EventInfo[eventID][e_Name]) >= 1)
	    {
			if(!something) {
				EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
				format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
				SendEventMessage(str);
			} else {
			    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
				SendEventMessage(str);
			}

			if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers] && !EventInfo[eventID][e_IsStarted] && EventInfo[eventID][e_IsJoinsClosed])
	        {
	            EventInfo[eventID][e_IsJoinsClosed] = false;
				format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto opened (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
				SendEventMessage(str);
	        }
		}
	    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
		Player[playerid][eventMember] = -1;
		SetPlayerGravity(playerid, 0.008);
	}
}

/*fun AntiBunnyuHop(playerid)
{
    AntiCheat[playerid][ac_OldHP] = 0.0;
	ApplyAnimation(playerid, "PED", "getup_front",4.1,0,0,0,0,0);
}*/

stock SetZombieHealthOnPickupPickup(playerid, &pickupid)
{
    new Float:hp;
    GetPlayerHealthEx(playerid, hp);
    
	switch(getZombieClass(playerid))
	{
		case TANKZOMBIE: {
        	if(hp <= 99.9) SetPlayerHealthAC(playerid, 100.0);
        }
        case DEMONZOMBIE, BOOMERZOMBIE, KAMIKAZEZOMBIE: {
            if(hp <= 14.9) SetPlayerHealthAC(playerid, 15.0);
        }
		case FREEZERZOMBIE: {
            if(hp <= 44.9) SetPlayerHealthAC(playerid, 45.0);
        }
	    default: {
	        if(hp <= 99.9) SetPlayerHealthAC(playerid, 100.0);
	    }
	}
    DestroyPickupEx(pickupid, true);
}

fun OnPlayerPickUpPickup(playerid, pickupid)
{
	if(Pickups[pickupid][e_ItemID] == 2804)
	{
	    new dropper_id = Pickups[pickupid][e_DropperID];
	    if( dropper_id < 0 ) dropper_id = playerid;
	    
	    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	    {
	    	if(Pickups[pickupid][e_ForPlayer] == Player[playerid][pAccountID] || gettime() >= Pickups[pickupid][e_Time] || GetPlayerTeamEx(dropper_id) == TEAM_ZOMBIE && Player[dropper_id][pClass][TEAM_ZOMBIE+1] == FLESHERZOMBIE && !Player[playerid][IsPlayerInfected])
			{
				TryToAddAmmoOrAntidote(playerid, Pickups[pickupid][e_DropperID]);
                DestroyPickupEx(pickupid, true);
		   		return 1;
			}
			else if(Pickups[pickupid][e_ForPlayer] != Player[playerid][pAccountID] && Pickups[pickupid][e_ForPlayer] != -1 && gettime() < Pickups[pickupid][e_Time])
			{
				SendClientMessageFormat(playerid, -1, "{FFFFFF}>> This thing is under {FF0000}protection{FFFFFF} for the player who received it, disabling protection through{FF0000} %d sec(s)", Pickups[pickupid][e_Time] - gettime());
				return 1;
			}
			else if(Pickups[pickupid][e_ForPlayer] == -1 || gettime() >= Pickups[pickupid][e_Time])
	  		{
	  		    TryToAddAmmoOrAntidote(playerid, Pickups[pickupid][e_DropperID]);
                DestroyPickupEx(pickupid, true);
				return 1;
	  		}
		}
		else if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
		{
		    SetZombieHealthOnPickupPickup(playerid, pickupid);
		    return 1;
		}
		return 1;
	}
	return 1;
}

stock IsValidWeapon(weaponid)
{
    if ( weaponid >= 22 && weaponid <= 25) return 1;
    if ( weaponid >= 29 && weaponid <= 34) return 1;
    return 0;
}

fun OnVehicleSpawn(vehicleid)
{
	return 1;
}

fun SaveUserData(playerid)
{
	new ip[16];
    GetServerVarAsString("bind", ip, sizeof (ip));
    if(Player[playerid][pLogged])
	{
	    new query[4096], dat[2][24], attch[128], attchPos[400];
	    format(dat[0], 128, "%d,%d", Player[playerid][pZombieClassesUnlocked_0], Player[playerid][pZombieClassesUnlocked_1]);
	    format(dat[1], 128, "%d,%d", Player[playerid][pHumanClassesUnlocked_0], Player[playerid][pHumanClassesUnlocked_1]);

	    format(attch, 128, "%d,%d,%d,%d,%d,%d,%d,%d", Player[playerid][pAttID][0], Player[playerid][pAttID][1], Player[playerid][pAttID][2], Player[playerid][pAttID][3], Player[playerid][pAttID][4], Player[playerid][pAttID][5], Player[playerid][pAttID][6], Player[playerid][pAttID][7]);
	    format(attchPos, 400, "%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f",
		Player[playerid][pAttIDPos][0], Player[playerid][pAttIDPos][1],
		Player[playerid][pAttIDPos][2], Player[playerid][pAttIDPos][3],
		Player[playerid][pAttIDPos][4], Player[playerid][pAttIDPos][5],
		Player[playerid][pAttIDPos][6], Player[playerid][pAttIDPos][7],
		Player[playerid][pAttIDPos][8], Player[playerid][pAttIDPos][9],
		Player[playerid][pAttIDPos][10], Player[playerid][pAttIDPos][11],
		Player[playerid][pAttIDPos][12], Player[playerid][pAttIDPos][13],
		Player[playerid][pAttIDPos][14], Player[playerid][pAttIDPos][15],
		Player[playerid][pAttIDPos][16], Player[playerid][pAttIDPos][17],
		Player[playerid][pAttIDPos][18], Player[playerid][pAttIDPos][19],
		Player[playerid][pAttIDPos][20], Player[playerid][pAttIDPos][21],
		Player[playerid][pAttIDPos][22], Player[playerid][pAttIDPos][23],
		Player[playerid][pAttIDPos][24], Player[playerid][pAttIDPos][25],
		Player[playerid][pAttIDPos][26], Player[playerid][pAttIDPos][27],
		Player[playerid][pAttIDPos][28], Player[playerid][pAttIDPos][29],
		Player[playerid][pAttIDPos][30], Player[playerid][pAttIDPos][31],
		Player[playerid][pAttIDPos][32], Player[playerid][pAttIDPos][33],
        Player[playerid][pAttIDPos][34], Player[playerid][pAttIDPos][35]);

	    new date[28], y, m, d, h, i, s;
        TimestampToDate(gettime(), y, m, d, h, i, s, 3);
		format(date, 28, "%02dD/%02dM/%04dY", d, m, y);

	    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Kills`='%d',`Killstreak`='%d',`RoundWins`='%d',`DuelWins`='%d',`DuelLoses`='%d',`VIP`='%d',`Admin`='%d',`Rank`='%d',`EXP`='%d',`Clan`='%d',`ClanRank`='%d',`Language`='%d',`ZombieList` = '%e',`HumanList` = '%e',`VipTime` = '%d',`settings`='%d',`attachID`='%e',\
		`attachPos`='%e',`lalog`='%e',`ClanWarns`='%d',`gbnd`='%d',`bal`='%.2f',`pk`='%d',`pkb`='%d',`ref`='%d',`days`='%d',`plg`='%d',`points`='%d',`lastGangJoin`='%d',`build`='%e',`total_pk`='%d',`Cards`='%d' WHERE `ID` = '%d'",
		Player[playerid][pKills],
		Player[playerid][pKillstreakMax],
		Player[playerid][RoundsWin],
		Player[playerid][DuelsWin],
		Player[playerid][DuelsLose],
		Player[playerid][pVip],
		Player[playerid][pAdmin],
		Player[playerid][pRank],
		Player[playerid][pXP],
		Player[playerid][pClan],
		Player[playerid][pClanRank],
		Player[playerid][pLang],
		dat[0],
		dat[1],
		Player[playerid][pVipTime],
		Player[playerid][pSettings],
		attch,
		attchPos,
		date,
		Player[playerid][pClanWarns],
		Player[playerid][GangBanned],
		Player[playerid][pBalance],
		Player[playerid][pPlayerKills],
		Player[playerid][pPlayerKillsBack],
		Player[playerid][pRefID],
		Player[playerid][e_Days],
		Player[playerid][e_PrevLogin],
		Player[playerid][pUpgPoints],
		Player[playerid][pLastGangJoin],
		SERVER_BUILD,
		Player[playerid][totalPlayersKilledInGW],
		Player[playerid][pCardSet],
		Player[playerid][pAccountID]);
		
       	mysql_tquery(Base, query, "", "", "");
       	
		UpdateSign(playerid);
		SaveAchievements(playerid);
		SaveTimeout(playerid);
		SaveAdminActivity(playerid);
	}
}

fun LoadAdminActivity(playerid)
{
	if(Player[playerid][pAdmin] > 0)
	{
	    if(cache_num_rows())
		{
		    cache_get_value_name_int(0, "done", Player[playerid][AdminActivity][4]);
		    if(Player[playerid][AdminActivity][4] >= 0)
		    {
			    cache_get_value_name_int(0, "auto", Player[playerid][AdminActivity][3]);
			    cache_get_value_name_int(0, "h", Player[playerid][AdminActivity][2]);
	 	    	cache_get_value_name_int(0, "m", Player[playerid][AdminActivity][1]);
		 	    cache_get_value_name_int(0, "s", Player[playerid][AdminActivity][0]);
			}
		}
		else
		{
		    Player[playerid][AdminActivity][4] = 0;
		    Player[playerid][AdminActivity][3] = 0;
		    Player[playerid][AdminActivity][2] = 0;
		    Player[playerid][AdminActivity][1] = 0;
		    Player[playerid][AdminActivity][0] = 0;

		    new y, m, query[512];
			getdate(y, m, _);
			mysql_format(Base, query, sizeof(query), "INSERT INTO `aactivity` (`month`,`year`,`id`) VALUES('%d','%d','%d')", m, y, Player[playerid][pAccountID]);
			mysql_tquery(Base, query, "", "", "");
			/*Player[playerid][AdminActivity][3] = cache_insert_id();
			printf("%d", );*/
		}
	}
	return 1;
}

stock SaveAdminActivity(playerid)
{
    new y,m,d, query[624];
	getdate(y, m, d);
	if(Player[playerid][AdminActivity][4] >= 90)
	{
		mysql_format(Base, query, sizeof(query), "UPDATE `aactivity` SET `h`='%d',`m`='%d',`s`='%d',`joined`='1',`done`='-1280000',`year`='%d' WHERE `id` = '%d' AND `month` = '%d'", Player[playerid][AdminActivity][2], Player[playerid][AdminActivity][1], Player[playerid][AdminActivity][0], y, Player[playerid][pAccountID], m);
		mysql_tquery(Base, query, "", "", "");
		Player[playerid][AdminActivity][4] = -1280000;
	}
	else
	{
	    if(Player[playerid][AdminActivity][4] >= 0)
	    {
	    	mysql_format(Base, query, sizeof(query), "UPDATE `aactivity` SET `h`='%d',`m`='%d',`s`='%d',`joined`='0',`done`='%d',`year`='%d' WHERE `id` = '%d' AND `month` = '%d'", Player[playerid][AdminActivity][2], Player[playerid][AdminActivity][1], Player[playerid][AdminActivity][0], Player[playerid][AdminActivity][4], y, Player[playerid][pAccountID], m);
			mysql_tquery(Base, query, "", "", "");
		}
	}
}

fun OnVehicleDeath(vehicleid, killerid)
{
	return 1;
}

fun OnPlayerText(playerid, text[])
{
    if(!Player[playerid][pLogged]) return 0;
    if(Player[playerid][Muted] > 0)
	{
		SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][112]);
		return 0;
	}
	
    if(strfind(text, LastMessage[playerid]) != -1)
    {
        if(gettime() > LastMessageTime[playerid])
		{
			LastMessagesTryed[playerid] = 0;
		}
        else
        {
            SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
            ++LastMessagesTryed[playerid];
            if(LastMessagesTryed[playerid] >= 5)
            {
                SendMessageFormatToAll(-1, "{33CCFF}>> %s has been kicked [Reason: Massive spam]", Player[playerid][UserName]);
                PlayerKick(playerid);
                LastMessagesTryed[playerid] = 0;
            }
            return 0;
        }
    }
    strmid(LastMessage[playerid], text, 0, 144, 145);
    LastMessageTime[playerid] = gettime() + 5;
    
    if(CheckForFlood(text)) {
        SendClientMessage(playerid, -1, "{FF0000}>> Do not flood!");
        return 0;
    }
    
    if(GetPVarInt(playerid,"flood") > gettime())
	{
		SendClientMessage(playerid, -1, "{FF0000}>> Do not spam!");
		return 0;
	}

	if(Player[playerid][pAdmin] <= 0) SetPVarInt(playerid,"flood",gettime() + 2);
 	
 	new query[900], serial[41];
    gpci(playerid, serial, sizeof(serial));
    
    mysql_format(Base, query, sizeof(query), "INSERT INTO `pactions` (`acc`,`type`,`date`,`text`,`sign`,`reg_sign`,`ip`) VALUES ('%d','2','%d','%e','%e', '%e', '%e')", Player[playerid][pAccountID], gettime(), text, serial, Player[playerid][pGPCI], Player[playerid][pIP]);
	mysql_tquery(Base, query, "", "", "");
 	
 	ReColor(text);
 	
 	new i_pos;
	while(text[i_pos])
	{
		if(text[i_pos] == '%') text[i_pos] = '#';
		i_pos++;
	}
 	
 	if(text[0] == '+' && Player[playerid][pClan] > 0 && Player[playerid][pClanRank] > 0 && Player[playerid][pLogged])
 	{
 	    #if debug_mode == 0
 	    new st[250];
        new ry, rm, rd, rh, rj, rs;
       	TimestampToDate(gettime(), ry, rm, rd, rh, rj, rs, 3);
        DiscordChannel = DCC_FindChannelById("662009624110694440");
        
 	    for( new i; i < 30; i++ )
		{
		    if(Clan[Player[playerid][pClan]][g_AllianceWith][i] == 2)
			{
			    foreach(Player, j)
			    {
			        if(Player[j][pClan] == Player[playerid][pClan] || Player[j][pClan] == i) SendClientMessageFormat(j, -1, "{66ffb3}[Alliance][%s]: %s(%d): %s", Clan[Player[playerid][pClan]][Short], Player[playerid][RealName], playerid, text[1]);
				}
                format(st, sizeof st, "```\n(%02dM/%02dD/%04dY %02d:%02d) [Alliance - #%d to #%d]: %s(%d) says: %s\n```", rm, rd, ry, rh, rj, Player[playerid][pClan], i, Player[playerid][UserName], playerid, text);
 				DCC_SendChannelMessageEx(DiscordChannel, st);
			}
		}
		#endif
 	    return 0;
 	}
 	
	if((text[0] == '@' || text[0] == '"') && Player[playerid][pAdmin] > 0)
	{
	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][29], Player[playerid][RealName], playerid, text[1]);
	    new ry, rm, rd, rh, rj, rs;
    	TimestampToDate(gettime(), ry, rm, rd, rh, rj, rs, 3);
    
	    new msg[200], utf8msg[200];
	    format(msg, 200, "```%04d-%02d-%02d %02d:%02d %s(%d): %s```", ry, rm, rd, rh, rj, Player[playerid][RealName], playerid, text[1]);
	    
	    utf8encode(utf8msg, msg);
	    #if debug_mode == 0
	    DiscordChannel = DCC_FindChannelById("613185790683513003");
	    DCC_SendChannelMessageEx(DiscordChannel, utf8msg);
	    #endif
	    
	    if((!strcmp(text, "@yes", true) || !strcmp(text, "@y", true) || !strcmp(text, "@ye", true) || !strcmp(text, "@yep", true)) && Player[playerid][pAdmin] >= 3)
	    {
			foreach(Player, i)
			{
				if(IsPlayerConnected(BanRequest[i]) && strlen(BanReason[i]) >= 2)
    			{
			        new str[70];
			        format(str, 70, "%s - %s", BanReason[i], Player[i][RealName]);
					TeamBan(BanRequest[i], playerid, str);
					GivePlayerXP(i, 10 * Map[m_XPType]);
					BanRequest[i] = -1;
					return 0;
			    }
			}
		}
		
		if((!strcmp(text, "@no", true) || !strcmp(text, "@n", true)) && Player[playerid][pAdmin] >= 3)
	    {
			foreach(Player, i)
			{
			    if(IsPlayerConnected(BanRequest[i]) && strlen(BanReason[i]) >= 2)
			    {
			        foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, -1, "{6A8EE2}>> Ban request has been rejected by %s", Player[playerid][RealName]);
					BanRequest[i] = -1;
     				return 0;
			    }
			}
		}
	    
	    if(strfind(text, "ban ", true, 1) == 1 && Player[playerid][pAdmin] <= 2)
	    {
	        new count;
	        foreach(Player, i) if(Player[i][pAdmin] >= 3) count++;
	        if(count >= 1)
	        {
				new id, reason[64];
				strdel(text, 0, 4);
				sscanf(text, "is[64]", id, reason);
				if(Player[id][pAdmin] >= Player[playerid][pAdmin]) return 0;
				BanRequest[playerid] = id;
				strmid(BanReason[playerid], text, 0, 64, 64);
				if(strlen(reason) >= 1 && IsPlayerConnected(id))
				{
			     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s wants to ban %s, type 'yes' to confirm and 'no' to reject", Player[playerid][RealName], Player[id][UserName]);
				}
			}
		}
		
		return 0;
	}
	
	//if(GetUnlockedSlot(Player[playerid][pSettings], PS_IAP) == 1 && !ProccessPay(playerid)) return 1;
	if((CheckForWebsite(text)) && PlayerTextType[playerid] <= 999)
 	{
 	    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s, use /adva %d to send a message", Player[playerid][UserName], text, playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
		strmid(PlayerText[playerid], text, 0, 128, 128);
		PlayerTextType[playerid] = 1;
		return 0;
 	}
	
	new i_numcount, i_period;
	i_pos = 0;
    while(text[i_pos])
	{
        if('0' <= text[i_pos] <= '9') i_numcount ++;
        else if(text[i_pos] == '.') i_period ++;
        i_pos++;
    }
    if(i_numcount >= 5 && PlayerTextType[playerid] <= 999)
 	{
		//foreach(Player, i) SendClientMessageFormat(i, -1, "{33CCFF}>> %s has been muted by Server-Bot [Reason: Nice try, stay muted]", Name(playerid));
        //Player[playerid][Muted] = 300;
        foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{b3ffff}>> [ADM-INFO] %s has advertised: %s, use /adva %d to send a message", Player[playerid][UserName], text, playerid);
		SendClientMessage(playerid, -1, "{FFF000}>> Your message is awaiting processing");
		strmid(PlayerText[playerid], text, 0, 128, 128);
		PlayerTextType[playerid] = 1;
        return 0;
    }
    
    //SendClientMessageFormat(playerid, -1, "T: %s | LM: %s | %d", text, LastMessage[playerid]);
	
	if((GetTextUpperCount(text) >= 5 && !QuizStarted) || (QuizStarted && GetTextUpperCount(text) >= 8))
	{
	    SendClientMessage(playerid, -1, "{FF0000}>> Turn off CAPSLOCK!");
		return 0;
	}
	
	if(QuizStarted)
	{
	    switch(QuizType)
	    {
	        case 0:
	        {
	            if(!strcmp(text, QuizTextAnswer, false))
	            {
	                foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][174], Player[playerid][UserName], QuizTextAnswer, QuizXp);
	                GivePlayerXP(playerid, QuizXp);
                    QuizStarted = false;
	            }
	        }
	        case 1:
	        {
	            if(strval(text) == QuizRealAnswer)
	            {
	                new s[11];
	                valstr(s, QuizRealAnswer);
             		foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][174], Player[playerid][UserName], s, QuizXp);
	                GivePlayerXP(playerid, QuizXp);
                    QuizStarted = false;
	            }
	        }
	        case 2:
	        {
	            if(strval(text) == QuizRealAnswer)
	            {
	                new s[11];
	                valstr(s, QuizRealAnswer);
             		foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][174], Player[playerid][UserName], s, QuizXp);
	                GivePlayerXP(playerid, QuizXp);
                    QuizStarted = false;
	            }
	        }
	        case 3:
	        {
	            if(!strcmp(text, questions_answers[0][QuizIndex], true)
				|| !strcmp(text, questions_answers[1][QuizIndex], true)
				|| !strcmp(text, questions_answers[2][QuizIndex], true))
	            {
      		 		GivePlayerXP(playerid, QuizXp);
					foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][174], Player[playerid][UserName], questions_answers[Player[playerid][pLang]][QuizIndex], QuizXp);
                    QuizStarted = false;
                    QuizIndex = -1;
				}
			}
		}
	}
	
	if(text[0] == '#' && (Player[playerid][pVip] > 0 || FakeData[playerid][2] > 0) || text[0] == '№' && (Player[playerid][pVip] > 0 || FakeData[playerid][2] > 0))
	{
	    foreach(Player, i) if(Player[i][pVip] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{FFA500}[VIP CHAT]: %s(%d): %s", Player[playerid][UserName], playerid, text[1]);

        #if debug_mode == 0
	    new msg[200], utf8msg[200];
	    format(msg, 200, "```[VIP SPY]: %s(%d): %s```", Player[playerid][UserName], playerid, text[1]);
	    DiscordChannel = DCC_FindChannelById("662021492225212447");
	    utf8encode(utf8msg, msg);
	    DCC_SendChannelMessageEx(DiscordChannel, utf8msg);
	    #endif
	    
		return 0;
	}
	
	new render[7] = "", rank[32];
	switch(Player[playerid][pClanRank])
	{
		case 1: strmid(rank, Clan[Player[playerid][pClan]][Rank_0], 0, 32, 33);
		case 2: strmid(rank, Clan[Player[playerid][pClan]][Rank_1], 0, 32, 33);
		case 3: strmid(rank, Clan[Player[playerid][pClan]][Rank_2], 0, 32, 33);
		case 4: strmid(rank, Clan[Player[playerid][pClan]][Rank_3], 0, 32, 33);
		case 5: strmid(rank, Clan[Player[playerid][pClan]][Rank_4], 0, 32, 33);
		case 6: strmid(rank, Clan[Player[playerid][pClan]][Rank_5], 0, 32, 33);
	}
	if(FakeData[playerid][7] >= 1) strmid(rank, "", 0, 32, 33);
	
	if(text[0] == '!' && Player[playerid][pClan] >= 1)
	{
	    new str[128];
	    format(str, 128, "{C659B6}[%s] %s(%d): %s", rank, Player[playerid][UserName], playerid, text[1]);
		SendGangMessage(playerid, str);
		
		#if debug_mode == 0
		new __action[200], utf8msg[200], y, ms, d, h, minutes, s;
		TimestampToDate(gettime(), y, ms, d, h, minutes, s, 3);
		DiscordChannel = DCC_FindChannelById("662009624110694440");
		format(__action, sizeof __action, "```\n%04d-%02d-%02d %02d:%02d (#%d) %s: %s\n```", y, ms, d, h, minutes, Player[playerid][pClan], Player[playerid][UserName], text[1]);
        utf8encode(utf8msg, __action);
		DCC_SendChannelMessageEx(DiscordChannel, utf8msg);
		#endif
		return 0;
	}
	
	new admin[19], vip[14], assist[256]="";
	switch(Player[playerid][pAdmin])
	{
	    case 0: admin = "";
	    case 1: admin = "{faf06d}(H)";
	    case 2: admin = "{00FF00}(M)";
	    case 3: admin = "{33CCFF}(A)";
	    case 4: admin = "{FF0000}(LA)";
	    case 5: if(Player[playerid][pAccountID] != 1) admin = "{9900CC}(HA)"; else admin = "";
	    default: admin = "";
	}
	
	if(GetUnlockedSlot(Player[playerid][pSettings], 29) == 1) strins(assist, "{FF00CC}(Event Creator)", strlen(assist));
	if(GetUnlockedSlot(Player[playerid][pSettings], 25) == 1) strins(assist, "{b3ffff}(Gang Manager)", strlen(assist));
	if(GetUnlockedSlot(Player[playerid][pSettings], 30) == 1) strins(assist, "{99ddff}(IT)", strlen(assist));
	
	if(GetUnlockedSlot(Player[playerid][pSettings], PS_HIDDEN) == 0) { admin = ""; assist = ""; }
    if(FakeData[playerid][7])
	{
		admin = "";
		assist = "";
	}
	
	switch(Player[playerid][pVip]+FakeData[playerid][2])
	{
	    case 0: vip = "";
	    case 1: vip = "{CD7F32}(VIP)";
	    case 2: vip = "{C0C0C0}(VIP)";
	    case 3: vip = "{FFF000}(VIP)";
	}
	
	if(!EmptyMessage(text))
	{
	    if(Player[playerid][pClan] > 0 && FakeData[playerid][0] <= 0) { format(render, 10, "[%s]", Clan[Player[playerid][pClan]][Short]); }
		SendMessageFormatToAll(-1, "%s%s%s%s{%06x}%s{FFFFFF}(%d): %s", render, vip, admin, assist, GetPlayerColor(playerid) >>> 8, Player[playerid][UserName], playerid, text);

        #if debug_mode == 0
        new st[250], utf8msg[250];
        new ry, rm, rd, rh, rj, rs;
    	TimestampToDate(gettime(), ry, rm, rd, rh, rj, rs, 3);
        DiscordChannel = DCC_FindChannelById("612998988609880076");
       	format(st, sizeof st, "```\n%04d-%02d-%02d %02d:%02d %s(%d): %s \n```", ry, rm, rd, rh, rj, Player[playerid][UserName], playerid, text);
        utf8encode(utf8msg, st);
		DCC_SendChannelMessageEx(DiscordChannel, utf8msg);
		#endif
	}
	return 0;
}

fun OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)
{
	if(Player[playerid][eventMember] <= -1)
	{
		if(Player[playerid][pAdmin] < 1 || !Player[playerid][aDuty]) ClearAnimations(playerid, 1);
	}
	else
	{
	    new eventID = Player[playerid][eventMember], newID;
	    for( new i = 0; i < 18; i++ )
	    {
	        newID = (i-1) > -1 ? i * 2 : 0;
	    	if(EventInfo[eventID][e_CarProps][newID] == vehicleid)
 			{
 			    if(EventInfo[eventID][e_CarProps][newID+1] == GetPlayerTeamEx(playerid)) return 1;
 			    if(EventInfo[eventID][e_CarProps][newID+1] == -1 && GetPlayerTeamEx(playerid) == 254) return 1;
			}
		}
		ClearAnimations(playerid, 1);
	}
	return 1;
}

fun OnPlayerExitVehicle(playerid, vehicleid)
{
    GetPlayerPos(playerid, OldPos[playerid][0], OldPos[playerid][1], OldPos[playerid][2]);
	return 1;
}

fun OnPlayerStateChange(playerid, newstate, oldstate)
{
	if(oldstate == PLAYER_STATE_DRIVER || oldstate == PLAYER_STATE_PASSENGER)
	{
	    AntiTPTimerEx(playerid, 4);
		AntiSlap(playerid, 2);
		AntiSpeedHack(playerid, 3);
		GetPlayerPos(playerid,OldPos[playerid][0],OldPos[playerid][1],OldPos[playerid][2]);
	}
	
    if(newstate == PLAYER_STATE_DRIVER || newstate == PLAYER_STATE_PASSENGER)
    {
        if(IsBeingSpeced[playerid])
        {
            foreach(Player,i)
            {
                if(spectatorid[i] == playerid && Player[i][pAdmin] > 0)
                {
                    PlayerSpectateVehicle(i, GetPlayerVehicleID(playerid));
                }
            }
        }
    }
    if(newstate == PLAYER_STATE_ONFOOT)
    {
        if(IsBeingSpeced[playerid])
        {
            foreach(Player,i)
            {
                if(spectatorid[i] == playerid && Player[i][pAdmin] > 0)
                {
                    PlayerSpectatePlayer(i, playerid);
                }
            }
        }
    }
	return 1;
}

fun OnPlayerEnterCheckpoint(playerid)
{
	if(GetPlayerVirtualWorld(playerid) != Map[m_World]) return 1;
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    /**************************************** CHAOS *******************************/
	    
		/*****************************************************************************/
		
	    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && lastHuman[playerid]) GivePlayerXP(playerid, 50);
		else
		{
		    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == TOURIST) GivePlayerXP(playerid, 30);
			else GivePlayerXP(playerid, 10);
		}
		
		PlayerPlaySound(playerid, 5448, 0.0, 0.0, 0.0);
        
		new Float:h;
		GetPlayerHealthEx(playerid, h);
		if(h <= 1.0) AchievementAddProgress(playerid, ach_SURVIVED);
        if(lastHuman[playerid]) AchievementAddProgress(playerid, ach_VOID);
		
        SetPlayerVirtualWorld(playerid, 9999);
        Player[playerid][RoundsWin]++;
        AchievementAddProgress(playerid, ach_WINNER);
        
		SetPlayerPosAC(playerid, 960.3299,-52.5693,1001.1172);
		SetPlayerInterior(playerid, 3);
		CurePlayer(playerid);
		Player[playerid][IsBurned][0] = 0;
    	Player[playerid][IsBurned][1] = 0;
	   	KillTimer(Player[playerid][InfectedTimer]);
	   	Player[playerid][IsCursed] = false;
	   	Player[playerid][hasBleedEffect] = false;
	   	KillTimer(Player[playerid][PoisionTimer]);
	   	KillTimer(Player[playerid][BleedingTimer]);
	   	TextDrawHideForPlayer(playerid, Infected[playerid]);
	    TextDrawHideForPlayer(playerid, Poision[playerid]);
	    TextDrawHideForPlayer(playerid, GreenScreen[playerid]);
	    TextDrawHideForPlayer(playerid, Stun[playerid]);
	    TextDrawHideForPlayer(playerid, Blidnes[playerid]);
	    KillTimer(Player[playerid][BlidnessTimer]);
	    Player[playerid][Blidness] = 0;
		DisablePlayerCheckpoint(playerid);
		SetPlayerColor(playerid,COLOR_EVACUATED);
		IsEvacuated[playerid] = true;
		
		foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][13], Player[playerid][UserName]);
		Player[playerid][Evacuated]++;
		
		if(Player[playerid][Evacuated] % 5 == 0)
		{
		    foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][170], Player[playerid][UserName], Player[playerid][Evacuated], Player[playerid][Evacuated] * 6);
			GivePlayerXP(playerid, Player[playerid][Evacuated] * 6);
		}
	}
	return 1;
}

public OnPlayerClickTextDraw(playerid, Text:clickedid)
{
	return 0;
}

fun CheckForNewsOnLogin(playerid)
{
   	if(cache_num_rows())
	{
	    new time;
		cache_get_value_name_int(0, "time", time);
		if(gettime() < time)
		{
		    new y, m, d, h, i, s;
            TimestampToDate(time-259200, y, m, d, h, i, s, 3);
            switch(Player[playerid][pLang])
            {
				case 0: SendClientMessageFormat(playerid, -1, "{33adff}>> Update from %02d/%02d/%04d, use {FFFFFF}/news{33adff} to check", d, m, y);
                case 1: SendClientMessageFormat(playerid, -1, "{33adff}>> Обновления от %02d/%02d/%04d, ипользуйте {FFFFFF}/news{33adff} чтобы прочитать", d, m, y);
                case 2: SendClientMessageFormat(playerid, -1, "{33adff}>> Actualizacion desde %02d/%02d/%04d, use {FFFFFF}/news{33adff} para verificar", d, m, y);
			}
			SetTimerEx("CreateDisplayInfo", 30, 0, "iffifffi", playerid, 1024.0, 354.9375, 14, 470.000, 354.9375, 10.0, 5000);
		}
	}
	return 1;
}

fun OnPlayerRequestSpawn(playerid)
{
	if(!Player[playerid][pLogged]) return 0;
	
	if(Player[playerid][pClan] > 0)
	{
	    if(strlen(Clan[Player[playerid][pClan]][g_Rules]) >= 1) SendClientMessageFormat(playerid, -1, "{C659B6}>> Gang rules: %s", Clan[Player[playerid][pClan]][g_Rules]);
	    if(strlen(Clan[Player[playerid][pClan]][g_Motd]) >= 1) SendClientMessageFormat(playerid, -1, "{C659B6}>> Gang mot: %s", Clan[Player[playerid][pClan]][g_Motd]);

		new i, id = Player[playerid][pClan];
		for( i = 0; i < 30; i++ )
		{
			if(Clan[i][g_AllianceWith][id] == 1) SendClientMessageFormat(playerid, -1, "{C659B6}>> %s wants to make an alliance with you, use /gang alliance %d", Clan[i][Full], i);
            if(Clan[i][g_EnemysWith][id] == -1) SendClientMessageFormat(playerid, -1, "{C659B6}>> %s wants to make a war with you, use /gang war %d", Clan[i][Full], i);
		}
		if(Clan[id][g_TimeToJoin] >= 1) {
		    SendClientMessage(playerid, -1, "{C659B6}>> Your gang is in the match, join by /gang match");
		}
		
		if(Clan[Player[playerid][pClan]][g_House] >= 1) {
			InGangHouse[playerid] = true;
			SendClientMessageFormat(playerid, -1, "{C659B6}>> Your character relaxed by %.2f '/.", floatdiv(floatmul(Player[playerid][pRestTime],100),1.5));
            SendClientMessageFormat(playerid, -1, "{C659B6}>> You will gain on x%.1f more EXP (-0.1 each kill)", Player[playerid][pRestTime]);
            Player[playerid][pRestTime] = 0.0;
		}
		else {
		    Player[playerid][pRestTime] = 0.0;
		}
	}
	
	new IP[16], msg[128];
	GetPlayerIp(playerid, IP, 16);
 	format(msg, sizeof(msg), "blackbox.ipinfo.app/lookup/%s", IP);
	HTTP(playerid, HTTP_GET, msg, "", "HTTP_OnPlayerProxyCheck");
	
	return 1;
}

fun OnObjectMoved(objectid)
{
	return 1;
}

fun OnPlayerObjectMoved(playerid, objectid)
{
	return 1;
}

fun OnVehicleMod(playerid, vehicleid, componentid)
{
    foreach(Player, i)
    {
        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Player Crasher", Player[playerid][UserName], playerid);
	}

    /*RemoveVehicleComponent(vehicleid,componentid);
    IsBanned{playerid} = true;
    BanPlayer(playerid, "Vehicle Mod");*/
    
	return 0;
}

fun OnVehiclePaintjob(playerid, vehicleid, paintjobid)
{
    foreach(Player, i)
    {
        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Player Crasher", Player[playerid][UserName], playerid);
	}
    /*IsBanned{playerid} = true;
    BanPlayer(playerid, "Vehicle Mod");*/
	return 0;
}

fun OnVehicleRespray(playerid, vehicleid, color1, color2)
{
    foreach(Player, i)
    {
        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Player Crasher", Player[playerid][UserName], playerid);
	}
    /*IsBanned{playerid} = true;
    BanPlayer(playerid, "Vehicle Mod");*/
	return 0;
}

fun OnPlayerSelectedMenuRow(playerid, row)
{
	return 1;
}

fun OnPlayerExitedMenu(playerid)
{
	return 1;
}

fun OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)
{
    if(IsBeingSpeced[playerid])
    {
        foreach(Player,i)
        {
            if(spectatorid[i] == playerid && Player[i][pAdmin] > 0)
            {
                SetPlayerInterior(i,GetPlayerInterior(playerid));
                SetPlayerVirtualWorld(i,GetPlayerVirtualWorld(playerid));
            }
        }
    }
	return 1;
}

fun HideSlenderObjects(playerid)
{
	for( new i; i < 6; i++ )
	{
	    RemovePlayerAttachedObject(playerid, 4 + i);
	}
	if(Player[playerid][Helmet]) SetPlayerAttachedObject(playerid, 9, 18936, 2, 0.129999,0.030000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);
}

fun RemoveRocketboots(playerid)
{
	RemovePlayerAttachedObject(playerid, 4);
	RemovePlayerAttachedObject(playerid, 5);
}

fun RogueSkinBackH(playerid)
{
    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN]  == ROGUEHUMAN)
    {
        setHumanColor(playerid);
        SetPlayerSkinAC(playerid, 97);
		ClearAnimations(playerid);
    }
}

fun RogueSkinBackZ(playerid)
{
    if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1]  == ROGUEZOMBIE)
    {
        SetPlayerColor(playerid, COLOR_ZOMBIE);
        SetPlayerSkinAC(playerid, 135);
		ClearAnimations(playerid);
    }
}

fun GetTopGangs(playerid)
{
	new mp = 1, bool:IsTopGang[30] = {false, ...}, i, j,
		alliance_count = 0, hasHouse[32] = " ";
	
    for( i = 0; i < cache_num_rows(); i++)
    {
    	cache_get_value_name_int(i, "controlled", mp);
     	if(strlen(Clan[mp][Full]) >= 1) IsTopGang[mp] = true;
	}
    for( i = 1; i < sizeof(Clan); i++ )
    {
        if(Clan[i][g_OwnerID] <= 0) continue;
        hasHouse = " ";
        alliance_count = 0;
    	for( j = 0; j < 30; j++ ) if(Clan[i][g_AllianceWith][j] == 2) alliance_count += Clan[j][g_MaxMembers];
        if(Clan[i][__isActive] && !IsTopGang[i])
		{
		    if(Clan[i][g_House] && !Clan[i][g_IsNeutral]) hasHouse = " ";
			SendClientMessageFormat(playerid, -1, "{B2F558}%s{FFFFFF} - ID: %d (%d EXP)", Clan[i][Full], i, Clan[i][EXP]);
		}
	}
	
 	new qu[300];
    mysql_format(Base, qu, sizeof(qu), "SELECT count(`controlled`), `controlled` FROM `maps` WHERE `controlled` > 0 GROUP BY `controlled` ORDER BY count(`controlled`) DESC");
	mysql_tquery(Base, qu, "ShowMostTopGangs", "i", playerid);
	
	return 1;
}

fun ShowMostTopGangs(playerid)
{
    new mp = 1, i = 0, c = 0, hasHouse[32] = " ", alliance_count, j;
    for( i = 0; i < cache_num_rows(); i++)
    {
        hasHouse = " ";
        cache_get_value_name_int(i, "controlled", mp);
        if(strlen(Clan[mp][Full]) >= 1)
        {
            alliance_count = 0;
            for( j = 0; j < 30; j++ ) if(Clan[mp][g_AllianceWith][j] == 2) alliance_count += Clan[j][g_MaxMembers];
            if(c == 0)
			{
			    if(Clan[mp][g_House]) hasHouse = " ";
				SendClientMessageFormat(playerid, -1, "{FFD500}%s - ID: %d (%d EXP){FFD500} - MOST POWERFUL GANG", Clan[mp][Full], mp, Clan[mp][EXP]);
			}
			else
			{
			    if(Clan[mp][g_House]) hasHouse = " ";
				SendClientMessageFormat(playerid, -1, "{FFD500}%s - ID: %d (%d EXP){FFD500} - POWERFUL GANG", Clan[mp][Full], mp, Clan[mp][EXP]);
			}
			c++;
		}
	}
	return 1;
}

fun UnfreezePlayer(playerid)
{
	TogglePlayerControllable(playerid, true);
    Player[playerid][Tasered] = false;
    ClearAnimations(playerid);
}

fun SpaceBreaker(playerid)
{
	RemovePlayerAttachedObject(playerid, 9);
	SetPlayerVirtualWorld(playerid, 1);
	new Float:pos[3];
	GetPlayerPos(playerid, pos[0],pos[1],pos[2]);
 	//CreateObjectsX(18728, pos[0], pos[1], pos[2] - 1.6, 0.0, 0.0, 10, 3.0, 3);
 	//SetPlayerWeather(playerid, -84);
	//SetPlayerTime(playerid,4,0);
}

fun MoveCellphone(playerid, objectid)
{
	new Float:pos[3];
	GetObjectRot(objectid, pos[0], pos[1], pos[2]);
	SetObjectRot(objectid, pos[0]+0.2, pos[1] + 0.5, pos[2] + 5.0);
	Player[playerid][PortalsUsed]++;
	if(Player[playerid][PortalsUsed] <= 99)
	{
	    SetTimerEx("MoveCellphone", 10, false, "ii", playerid, Portals[playerid]);
	}
	else
	{
	    GetObjectPos(objectid, pos[0], pos[1], pos[2]);
		//CreateObjectsX(18707, pos[0], pos[1], pos[2] - 1.6, 0.0, 0.0, 20, 10.0, 2);
		CreateObjectsX(18737, pos[0], pos[1], pos[2]-10.0, 0.0, 0.0, 10, 10.0, 3);
		
		new obj = CreateObject(18697, pos[0], pos[1], pos[2]-10.0, 0.0, 0.0, 0.0);
		SetTimerEx("RemoveObject", 1000, 0, "i", obj);
		
	    Player[playerid][PortalsUsed] = 0;
	    
	    StopObject(objectid);
	    SetObjectRot(objectid, 0.0, 0.0, 0.0);
	    AntiTPTimerEx(playerid, 4);
	    new Float:pp[3];
		GetPlayerPos(playerid, pp[0], pp[1], pp[2]);
		GetObjectPos(objectid, pos[0], pos[1], pos[2]);
		SetObjectPos(objectid, pp[0], pp[1], pp[2]);
		
		SetPlayerPosFindZ(playerid, pos[0], pos[1], pos[2]);
		
		GetObjectPos(objectid, pos[0], pos[1], pos[2]);
	 	new str[96];
		format(str, 96, "{4dff4d}[Phone station]{00CCCC} %s\n{FFF000}Health: %.0f", Player[playerid][UserName], PortalsHealth[playerid]);
		PortalsText[playerid] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2] + 0.5, 15.0, 0, 0);
	}
}

fun __check(playerid)
{
    if(gettime() < CanUseCBugTime[playerid]) return 1;
	if(GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_DUCK) return 1;
	if(IsPlayerOnDuel[playerid] && DuelRules[0][playerid] >= 1) return 0;
	if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 0;
	
 	ClearAnimations(playerid, 1);
	ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
	ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
	gLastShotTime[playerid] = GetTickCount();
	if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

	if(!IsPlayerOnDuel[playerid])
	{
		if(Player[playerid][pXP] < 2500)
		{
		    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
			return 1;
		}

		if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
		{
			foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
			SetPlayerSkinAC(playerid, 62, 1);
			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
			SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
			SetPlayerFacingAngle(playerid, 263.0160);
			SetPlayerInterior(playerid, 6);
			SetPlayerColor(playerid, 0x000000FF);
			Player[playerid][Jailed] = 60;
			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
			SetPlayerArmourAC(playerid, 0.0);
			SetPlayerHealthAC(playerid, 100.0);
			Player[playerid][Accelerated] = -1;
			if(IsPlayerAcceleratedText[playerid]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[playerid]),IsPlayerAcceleratedText[playerid]=Text3D:-1;
		}
	}
	gLastShotTime[playerid] = -1;
	return 1;
}

fun bool:IsNearMerchant(playerid)
{
	new i, Float:x, Float:y, Float:z;
 	for( i = 0; i < sizeof(Merchants); i++)
  	{
  	    if(IsValidActor(Merchants[i]))
  	    {
   			GetActorPos(Merchants[i], x, y, z);
     		if(IsPlayerInRangeOfPoint(playerid, 2.5, x, y, z)) return true;
		}
  	}
   	return false;
}

stock GetRankByID(rank, id) {
	new str[32] = "";
	switch(rank) {
	    case 0: strmid(str, Clan[id][Rank_0], 0, 32, 32);
	    case 1: strmid(str, Clan[id][Rank_1], 0, 32, 32);
	    case 2: strmid(str, Clan[id][Rank_2], 0, 32, 32);
	    case 3: strmid(str, Clan[id][Rank_3], 0, 32, 32);
	    case 4: strmid(str, Clan[id][Rank_4], 0, 32, 32);
	    case 5: strmid(str, Clan[id][Rank_5], 0, 32, 32);
	    case 6: strmid(str, "Gang Leader", 0, 32, 32);
	}
	return str;
}

fun AcceptGangAction(playerid)
{
    if(cache_num_rows())
	{
	    new str[128], n[24], r;
	    cache_get_value_name(0, "Name", n, 25);
	    cache_get_value_name_int(0, "ClanRank", r);
	    if(r <= 5)
	    {
	    	format(str, sizeof(str), "{FFFFFF}Do you really want to{ff3300} fire %s?", n);
			ShowPlayerDialog(playerid, DIALOG_GANG_MEMBERS_ACCEPTING, DIALOG_STYLE_MSGBOX, "{FF0000}WARNING", str, "Yes", "No");
			strmid(GangPanelName[playerid], n, 0, 24, 25);
		}
		else
		{
		    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{FF0000}WARNING", "{ff3300}Not enough rights, contact Gang Manager (GM)", "Ok", "");
		}
	}
	return 1;
}

fun LoadGangInfo(playerid, id)
{
	if(cache_num_rows() > 0)
	{
		new y, m, d, h, s, o, i, maps_count;
		new info[2048],
		frmt[164],
		leaders[256],
		co_leaders[256], temp_maps[1024], temp_ids[128];

        new userid, user[24], owner[24], rank;
		cache_get_value_name_int(0, "maps_count", maps_count);
		cache_get_value_name(0, "owner", owner);

		for( i = 0; i < cache_num_rows(); i++ )
		{
		    cache_get_value_name_int(i, "ID", userid);
		    cache_get_value_name_int(i, "ClanRank", rank);
			cache_get_value_name(i, "Name", user);

			if(rank == 5) {
			    format(frmt, sizeof(frmt), "- %s(%d)\n", user, userid);
			    strcat(co_leaders, frmt);
			} else if(rank == 6) {
				format(frmt, sizeof(frmt), "- %s(%d)\n", user, userid);
			    strcat(leaders, frmt);
			}
		}

        format(frmt, sizeof(frmt), "{C659B6}Gang Name:{FFFFFF} %s (%s)\n\n", Clan[id][Full], Clan[id][Short]);
	    strcat(info, frmt);
        if(Clan[id][g_OwnerID] < 1 || Clan[id][g_FoundedDate] <= 0 || strlen(owner) < 1) strcat(info, "{C659B6}Founded by {FFFFFF}(Claim the rights to the gang from Gang Manager)\n\n");
		else {
		    TimestampToDate(Clan[id][g_FoundedDate], y, m, d, h, o, s, 3);
			format(frmt, sizeof(frmt), "{C659B6}Founded by {FFFFFF}%s {C659B6}at{FFFFFF} %04d-%02d-%02d %02d:%02d:%02d\n\n", owner, y, m, d, h, o, s);
            strcat(info, frmt);
		}

		strcat(info, "{C659B6}Current Leader(s):\n{FFFFFF}");
		strcat(info, leaders);
		strcat(info, "\n");
		strcat(info, "{C659B6}Current Co-Leader(s):\n{FFFFFF}");
	    strcat(info, co_leaders);
		format(frmt, sizeof(frmt), "\n{C659B6}Maps Owned:{FFFFFF} %d\n{FFFFFF}", maps_count);
		strcat(info, frmt);
		
		cache_get_value_name(0, "list", temp_maps);
		cache_get_value_name(0, "ids", temp_ids);

		new maps_name[30][64];
		new ids[30][4];
		split(temp_maps, maps_name, ',');
		split(temp_ids, ids, ',');

		for( i = 0; i < maps_count; i++ ) {
		    format(frmt, sizeof(frmt), "- %s (ID: %s)\n", maps_name[i], ids[i]);
		    strcat(info, frmt);
		}

        format(frmt, sizeof(frmt), "\n{C659B6}Win Ratio:{FFFFFF} %.2f '/. \n", max(0.0, ((Clan[id][Wins]-Clan[id][Loses])/(Clan[id][Wins]<=0?1:Clan[id][Wins]))*100.0 ));
		strcat(info, frmt);

        strcat(info, "\n");

	    if(Clan[id][g_LastKill] > 0)
	    {
			TimestampToDate(Clan[id][g_LastKill], y, m, d, h, o, s, 3);
			format(frmt, sizeof(frmt), "{C659B6}Last Fight Date:{FFFFFF} %04d-%02d-%02d %02d:%02d:%02d\n", y, m, d, h, o, s);
			strcat(info, frmt);
	    } else strcat(info, "{C659B6}Last Fight Date:{FFFFFF} Unknown\n");

		strcat(info, "\n");
        format(frmt, sizeof(frmt), "{C659B6}Min Rank To Join:{FFFFFF} %d\n", Clan[id][g_MinExp]);
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Max EXP Per /gang pay:{FFFFFF} %d\n", Clan[id][g_MaxPayAmt]);
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Max Warns Before Kick:{FFFFFF} %d\n", Clan[id][g_MaxWarns]);
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Rank{FFFFFF} %d{C659B6} OR{FFFFFF} %s{C659B6} Can Promote Members\n", Clan[id][g_RankToPromote], GetRankByID(Clan[id][g_RankToPromote], id));
        strcat(info, frmt);
        
        format(frmt, sizeof(frmt), "{C659B6}Rank{FFFFFF} %d{C659B6} OR{FFFFFF} %s{C659B6} Can Accept Members\n", Clan[id][g_RankToAccept], GetRankByID(Clan[id][g_RankToAccept], id));
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Rank{FFFFFF} %d{C659B6} OR{FFFFFF} %s{C659B6} Can Warn Members\n", Clan[id][g_RankToWarn], GetRankByID(Clan[id][g_RankToWarn], id));
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Rank{FFFFFF} %d{C659B6} OR{FFFFFF} %s{C659B6} Can Blacklist Members\n", Clan[id][g_RankToBan], GetRankByID(Clan[id][g_RankToBan], id));
        strcat(info, frmt);
        format(frmt, sizeof(frmt), "{C659B6}Rank{FFFFFF} %d{C659B6} OR{FFFFFF} %s{C659B6} Can Give PayDays\n", Clan[id][g_RankGivePayDay], GetRankByID(Clan[id][g_RankGivePayDay], id));
        strcat(info, frmt);

	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{C659B6}Gang Info", info, "Ok", "");
	}
	else
	{
	    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{C659B6}Gang Info", "You need to capture at least 1 map to get an info", "Ok", "");
	}
	return 1;
}

fun OnPlayerKeyStateChange(playerid, newkeys, oldkeys)
{
    if(KEY(KEY_YES)) { cmd::class(playerid,""); return 1; }
	if(KEY(KEY_NO)) { cmd::settings(playerid); return 1; }
	if(KEY(KEY_WALK) && GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
		if(IsNearMerchant(playerid))
		{
		    ShowZombieShop(playerid);
		    return 1;
		}
	}
	if(KEY(KEY_WALK) && IsPlayerInRangeOfPoint(playerid, 2.5, 313.1213,-166.1391,999.6010) && InGangHouse[playerid] && Clan[Player[playerid][pClan]][g_House] >= 1)
	{
	    new id = Player[playerid][pClan], query[1024];
        mysql_format(Base, query, sizeof(query), "SELECT users.Name, users.ID, users.ClanRank, IFNULL((SELECT users.Name FROM `users` WHERE users.ID = '%d'),'') AS owner, IFNULL((SELECT GROUP_CONCAT(maps.Name SEPARATOR ',') FROM maps WHERE maps.controlled = '%d'),'') AS list, IFNULL((SELECT GROUP_CONCAT(maps.ID+1 SEPARATOR ',') FROM maps WHERE maps.controlled = '%d'),'') AS ids, count(maps.controlled) maps_count FROM `users` JOIN `maps` WHERE users.Clan = '%d' AND users.ClanRank > '4' AND maps.controlled = '%d' GROUP BY maps.controlled, users.ID, users.Name", Clan[id][g_OwnerID], id, id, id, id);
		mysql_tquery(Base, query, "LoadGangInfo", "dd", playerid, id);
		
		// Co-Leaders and Leaders Names + IDs + Ranks, Owner Name, maps names, maps ids, controlled maps count
		// SELECT users.Name, users.ID, users.ClanRank, IFNULL((SELECT users.Name FROM `users` WHERE users.ID = '%d'),'') AS owner, IFNULL((SELECT GROUP_CONCAT(maps.Name SEPARATOR ',') FROM maps WHERE maps.controlled = '%d'),'') AS list, IFNULL((SELECT GROUP_CONCAT(maps.ID SEPARATOR ',') FROM maps WHERE maps.controlled = '%d'),'') AS ids, count(maps.controlled) maps_count FROM `users` JOIN `maps` WHERE users.Clan = '%d' AND users.ClanRank > '4' AND maps.controlled = '%d' GROUP BY maps.controlled, users.ID, users.Name

		return 1;
	}
	
	if(KEY(KEY_WALK) && IsPlayerInRangeOfPoint(playerid, 0.5, 316.3654,-170.2976,999.5938) && InGangHouse[playerid])
	{
	    InGangHouse[playerid] = false;
	    SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	    SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(playerid);
		return 1;
	}
	if(KEY(KEY_SECONDARY_ATTACK) && GetPlayerSpecialAction(playerid) >= 1) SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
	if(KEY(KEY_JUMP) || KEY(KEY_SPRINT))
	{
		if(gettime() < Player[playerid][SlowWalk] && CanUseAbility(playerid)) { ApplyAnimation(playerid, "PED", "WOMAN_walkfatold", 4.1, 0, 1, 1, 0, 2500); }
		if(Player[playerid][LegBreak] && CanUseAbility(playerid) && !Player[playerid][AntiLegBreaks]) { ApplyAnimation(playerid, "PED", "getup_front", 4.1, 0, 1, 1, 0, 0); }
	}
	if(newkeys & KEY_HANDBRAKE && GetPlayerWeapon(playerid) == 34)
	{
	    for( new i; i < 4; i++ )
		{
        	if(1 <= Player[playerid][pAttID][1+(i*2)] <= 4 ||
        	Player[playerid][pAttID][1+(i*2)] == 17 || Player[playerid][pAttID][1+(i*2)] == 18)
        	{
            	RemovePlayerAttachedObject(playerid, i);
        	}
		}
		TintaApasata[playerid] = 1;
		return 1;
	}
	if((newkeys & KEY_HANDBRAKE && oldkeys & KEY_FIRE || newkeys & KEY_FIRE && oldkeys & KEY_HANDBRAKE) && GetPlayerWeapon(playerid) == 34)
    {
		for( new i; i < 4; i++ ) {
        	if(1 <= Player[playerid][pAttID][1+(i*2)] <= 4 ||
        	Player[playerid][pAttID][1+(i*2)] == 17 || Player[playerid][pAttID][1+(i*2)] == 18)
        	{
            	RemovePlayerAttachedObject(playerid, i);
        	}
		}
		TintaApasata[playerid] = 1;
		return 1;
    }
	if(newkeys & KEY_HANDBRAKE && !IsPlayerInAnyVehicle(playerid)) TintaApasata[playerid] = 1;
    else if(oldkeys & KEY_HANDBRAKE && GetPlayerWeapon(playerid) != 34) TintaApasata[playerid] = 0;
	if(oldkeys & KEY_HANDBRAKE && GetPlayerWeapon(playerid) == 34) TintaApasata[playerid] = 0;
	if(oldkeys & KEY_HANDBRAKE && GetPlayerWeapon(playerid) == 34) AttachUserObjects(playerid);
	
	if((GetTickCount() - gLastShotTime[playerid]) < 750)
    {
    	if(KEY(KEY_JUMP | KEY_SPRINT | KEY_CROUCH))
     	{
     	    if(!IsPlayerOnDuel[playerid] && GetPlayerColor(playerid) != COLOR_EVACUATED)
     	    {
     	        if(gettime() < CanUseCBugTime[playerid]) return 1;
     	        switch(GetPlayerWeapon(playerid)) {
     	            case 28, 29, 30, 31, 32: return 1;
     	        }
     	        if(Player[playerid][pXP] <= 4999)
				{
				    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                    ClearAnimations(playerid, 1);
					ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					gLastShotTime[playerid] = GetTickCount();
					return 1;
				}

	      		ClearAnimations(playerid, 1);
				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
				ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
				gLastShotTime[playerid] = GetTickCount();
				if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

				if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
				{
					foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
					SetPlayerSkinAC(playerid, 62, 1);
					SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
					SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
	    			SetPlayerFacingAngle(playerid, 263.0160);
	    			SetPlayerInterior(playerid, 6);
	    			SetPlayerColor(playerid, 0x000000FF);
	    			Player[playerid][Jailed] = 60;
	    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	    			SetPlayerArmourAC(playerid, 0.0);
	   				SetPlayerHealthAC(playerid, 100.0);
				}
				gLastShotTime[playerid] = -1;
				return 1;
			}
   		}
        if(newkeys & KEY_CROUCH)
        {
        	SetTimerEx("__check", 200, false, "i", playerid );
        }
    }
	
	if((KEY(KEY_FIRE | KEY_CROUCH) || (oldkeys & KEY_FIRE) && (newkeys & KEY_CROUCH)) && !IsPlayerOnDuel[playerid] && GetPlayerAnimationIndex(playerid) != 839)
	{
	    new LastShotDelay = GetTickCount() - LastShotTime[playerid];
		switch(GetPlayerWeapon(playerid))
		{
			case 22:
			{
				if(LastShotDelay < COLT_DELAY_HIT)
		 		{
		 		    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
				 	return 0;
				}
			}
		   	case 23:
   			{
			   	if(LastShotDelay < SILENCE_HIT_DELAY)
			   	{
			   	    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
			 		return 0;
				}
			}
		   	case 24:
   			{
			   	if(LastShotDelay < DEAGLE_HIT_DELAY)
			   	{
			   	    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
				 	return 0;
				}
			}
		   	case 25:
   			{
			   	if(LastShotDelay < SHOTGUN_HIT_DELAY)
			   	{
			   	    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
			 		return 0;
				}
			}
		   	case 33:
   			{
			   	if(LastShotDelay < RIFLE_HIT_DELAY)
			   	{
			   	    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
			 		return 0;
				}
			}
		   	case 34:
   			{
			   	if(LastShotDelay < SNIPER_HIT_DELAY)
			   	{
			   	    if(Player[playerid][pXP] < 2500)
					{
					    foreach(Player, j) if(Player[j][pAdmin] >= 1) SendClientMessageFormat(j, -1, "{6A8EE2}>> %s(%d) supposedly uses C-Bug", Player[playerid][UserName], playerid);
                        ClearAnimations(playerid, 1);
	     				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
						ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
						LastShotTime[playerid] = GetTickCount();
						return 1;
					}

		 		    ClearAnimations(playerid, 1);
	    			ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Warning", "Do not use C-Bug!", "Ok", "");
					ApplyAnimation(playerid,"GYMNASIUM","gym_tread_falloff",1.0,0,0,0,1,3000);
					LastShotTime[playerid] = GetTickCount();
					if(Player[playerid][eventMember] <= -1) CBugTimes[playerid]++;

					if(CBugTimes[playerid] >= 3 && Player[playerid][Jailed] <= 0)
					{
						foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][181], Player[playerid][UserName], "the System", 1, "C-bug");
						SetPlayerSkinAC(playerid, 62, 1);
						SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
						SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
		    			SetPlayerFacingAngle(playerid, 263.0160);
		    			SetPlayerInterior(playerid, 6);
		    			SetPlayerColor(playerid, 0x000000FF);
		    			Player[playerid][Jailed] = 60;
		    			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		    			SetPlayerArmourAC(playerid, 0.0);
		   				SetPlayerHealthAC(playerid, 100.0);
					}
			 		return 0;
				}
			}
		}
	}
	
	if(KEY(KEY_FIRE) && GetPlayerWeapon(playerid) == 9 && !Player[playerid][aDuty])
	{
		if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	    {
	        new Float:pos[3];
			foreach(Player,i)
			{
			    for( new j; j < 18; j++ )
			    {
				    if(IsValidObject(box[i][j]))
				    {
				    	GetObjectPos(box[i][j], pos[0], pos[1], pos[2]);
						if(IsPlayerInRangeOfPoint(playerid, 1.5, pos[0], pos[1], pos[2]))
						{
                            DestroyObject(box[i][j]);
                            Delete3DTextLabel(boxText[i][j]);
                            box[i][j] = INVALID_OBJECT_ID;
                            return 1;
		        		}
					}
				}
	        }
		}
	}
	
    if(KEY(KEY_WALK))
	{
	    if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == FASTZOMBIE || GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == ROCKETMAN)
	    {
	        if(!CanUseAbility(playerid)) return 0;
	        if(gettime() - 10 < Abilitys[playerid][HighJumpZombie])
	        {
				switch(Player[playerid][pLang])
			    {
					case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
			        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
			        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
				}
				return 1;
			}
			new Float:pos[3];
			GetPlayerVelocity(playerid,pos[0],pos[1],pos[2]);
			SetPlayerVelocity(playerid,pos[0]*2.0,pos[1]*2.0,pos[2]+1.8* 1.2);
			Abilitys[playerid][HighJumpZombie] = gettime();
			if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
			{
				SetPlayerAttachedObject(playerid,4,18699,9,0.396999,-0.566000,-1.521999,-16.700000,-13.200001,143.499984,1.000000,1.000000,1.000000);
				SetPlayerAttachedObject(playerid,5,18699,10,0.214999,-1.677996,-0.217999,-79.799911,-7.799998,49.200019,1.000000,1.000000,1.000000);
				SetTimerEx("RemoveRocketboots", 2000, 0, "i", playerid);
                SetAbilityTimer(playerid, 10, TEAM_HUMAN);
			}
			AntiTPTimerEx(playerid, 4);
			AntiSlap(playerid, 2);
			AntiSpeedHack(playerid, 3);
			SetAbilityTimer(playerid, 10);
			AchievementAddProgress(playerid, ach_USED_ABILITY);
			return 1;
  		}
  		
	    switch(GetPlayerTeamEx(playerid))
	    {
	        case TEAM_HUMAN:
	        {
	            if(!CanUseAbility(playerid)) return 0;
	            new player = GetClosestPlayer(playerid);
	            switch(getHumanClass(playerid))
	            {
					case ROGUEHUMAN:
					{
					    if(gettime() - 30 < Abilitys[playerid][RogueSkinChangeH])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            SetPlayerColor(playerid, COLOR_ZOMBIE);
			            SetPlayerSkinAC(playerid, 181, 1);
						ClearAnimations(playerid);
			            Abilitys[playerid][RogueSkinChangeH] = gettime();
			            SetTimerEx("RogueSkinBackH", 45000, 0, "i", playerid);
			            SetAbilityTimer(playerid, 30);
			            AchievementAddProgress(playerid, ach_USED_ABILITY);
			            return 1;
					}
					
					case MEDIC:
					{
					    if(IsPlayerConnected(player) && GetPlayerTeamEx(player) == TEAM_HUMAN)
						{
					        if(gettime() - 5 < Player[playerid][checkForUnsleep])
							{
					            switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
							        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
								}
							}
							else
							{
							    new str[5], Float:x, Float:y, Float:z;
				      			GetPlayerPos(player, x, y, z);
				                if(IsPlayerInRangeOfPoint(playerid, 1.5, x, y, z) && Player[player][IsPlayerInfected])
					            {
					                format(str, sizeof(str), "%d", player);
					                cmd::cure(playerid, str);
					            }
					        }
						}
						return 1;
					}
					
					case FIREMANIAC:
					{
					    if(gettime() > Player[playerid][FireBullet][1] && Player[playerid][FireBullet][0] < 1)
				   		{
				   		    GameTextForPlayer(playerid, "~y~Fire Bullet:~r~ ON", 1500, 5);
							Player[playerid][FireBullet][0] = 1;
				        }
				        return 1;
					}
					
					case ADVANCEDENGINEER_2:
					{
					    if(Time >= 281)
			            {
			                GameTextForPlayer(playerid,"~w~Wait",2000,5);
			                return 1;
			            }
			            if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
			     		new Float: pos[4];
						GetPlayerFacingAngle(playerid, pos[3]);
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						if(Player[playerid][UnlimitedBoxes] < 5)
						{
							GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 1.0);
							new str[46];

							switch(Player[playerid][UnlimitedBoxes])
							{
								case 0: GameTextForPlayer(playerid,"~r~~h~X  ~w~X  ~w~X~n~~w~X  ~w~X",2000,5);
								case 1: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~w~X~n~~w~X  ~w~X",2000,5);
			                    case 2: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~w~X  ~w~X",2000,5);
			                    case 3: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~r~~h~X  ~w~X",2000,5);
			                    case 4: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~r~~h~X  ~r~~h~X",2000,5);
							}

							Player[playerid][UnlimitedBoxes]++;
							format(str, 46, "{4dff4d}[BOX]{00CCCC} %s", Player[playerid][UserName]);
			                box[playerid][Player[playerid][UnlimitedBoxes]] = CreateObject(923, pos[0], pos[1], pos[2], 0.0, 0.0, pos[3]);
							boxText[playerid][Player[playerid][UnlimitedBoxes]] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2], 15.0, 0, 0);
			                SetTimerEx("RemoveBox", 30000, 0, "ii", playerid, Player[playerid][UnlimitedBoxes]);
							PlayerPlaySound(playerid,1057,0.0,0.0,0.0);
							Abilitys[playerid][newBox] = gettime();
						}
						return 1;
					}
					
					case ENGINEER:
					{
					    if(Time >= 281)
			            {
			                GameTextForPlayer(playerid,"~w~Wait",2000,5);
			                return 1;
			            }
			            if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
			     		new Float: pos[4];
						GetPlayerFacingAngle(playerid, pos[3]);
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);

						if(Player[playerid][Boxes] >= 1)
						{
							GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 1.0);
							switch(Player[playerid][Boxes])
							{
							    case 4: GameTextForPlayer(playerid,"~r~~h~X  ~w~X  ~w~X  ~w~X",2000,5);
								case 3: GameTextForPlayer(playerid,"~r~~h~X  ~w~X  ~w~X",2000,5);
			                    case 2: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~w~X",2000,5);
			                    case 1: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X",2000,5);
							}

							box[playerid][Player[playerid][Boxes]] = CreateObject(923, pos[0], pos[1], pos[2], 0.0, 0.0, pos[3]);
							SetTimerEx("RemoveBox", 30000, 0, "ii", playerid, Player[playerid][Boxes]);

							new str[46];
							format(str, 46, "{4dff4d}[BOX]{00CCCC} %s", Player[playerid][UserName]);
							boxText[playerid][Player[playerid][Boxes]] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2], 15.0, 0, 0);
							Player[playerid][Boxes]--;
							PlayerPlaySound(playerid,1057,0.0,0.0,0.0);
						}
						return 1;
					}
					
					case ADVANCEDENGINEER:
					{
					    if(Time >= 281)
			            {
			                GameTextForPlayer(playerid,"~w~Wait",2000,5);
			                return 1;
			            }
			            if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
			     		new Float: pos[4];
						GetPlayerFacingAngle(playerid, pos[3]);
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);

						if(Player[playerid][AdvancedBoxes] >= 1)
						{
							GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 1.0);
							switch(Player[playerid][AdvancedBoxes])
							{
							    case 6: GameTextForPlayer(playerid,"~r~~h~X  ~w~X  ~w~X  ~w~X~n~~w~X  ~w~X",2000,5);
								case 5: GameTextForPlayer(playerid,"~r~~h~X  ~w~X  ~w~X~n~~w~X  ~w~X",2000,5);
								case 4: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~w~X~n~~w~X  ~w~X",2000,5);
			                    case 3: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~w~X  ~w~X",2000,5);
			                    case 2: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~r~~h~X  ~w~X",2000,5);
			                    case 1: GameTextForPlayer(playerid,"~r~~h~X  ~r~~h~X  ~r~~h~X~n~~r~~h~X  ~r~~h~X",2000,5);
							}

							box[playerid][Player[playerid][AdvancedBoxes]] = CreateObject(923, pos[0], pos[1], pos[2], 0.0, 0.0, pos[3]);
							SetTimerEx("RemoveBox", 30000, 0, "ii", playerid, Player[playerid][AdvancedBoxes]);

							new str[46];
							format(str, 46, "{4dff4d}[BOX]{00CCCC} %s", Player[playerid][UserName]);
							boxText[playerid][Player[playerid][AdvancedBoxes]] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2], 15.0, 0, 0);
							Player[playerid][AdvancedBoxes]--;
							PlayerPlaySound(playerid,1057,0.0,0.0,0.0);
						}
						return 1;
					}
					
					case HUMANQUEEN, IRONMAN, SPIDERMAN:
					{
					    if(Abilitys[playerid][QueenJumps][0] >= 1)
				        {
			            	new Float:pos[3];
			            	GetPlayerCameraFrontVector(playerid, pos[0], pos[1], pos[2]);
							SetPlayerVelocity(playerid, pos[0]/1.5, pos[1]/1.5, pos[2] + 0.3);
							Abilitys[playerid][QueenJumps][0]--;
							AntiTPTimerEx(playerid, 4);
							AntiSlap(playerid, 2);
							AntiSpeedHack(playerid, 2);
							Abilitys[playerid][QueenJumps][1] = gettime()+8;
							SetAbilityTimer(playerid, 8, TEAM_HUMAN);
							AchievementAddProgress(playerid, ach_USED_ABILITY);
							if(Player[playerid][pClass][TEAM_HUMAN] == IRONMAN)
							{
								SetPlayerAttachedObject(playerid,4,18699,9,0.396999,-0.566000,-1.521999,-16.700000,-13.200001,143.499984,1.000000,1.000000,1.000000);
								SetPlayerAttachedObject(playerid,5,18699,10,0.214999,-1.677996,-0.217999,-79.799911,-7.799998,49.200019,1.000000,1.000000,1.000000);
								SetTimerEx("RemoveRocketboots", 2000, 0, "i", playerid);
							}
						}
						return 1;
					}
	            }
	            return 1;
	        }
	        
	        case TEAM_ZOMBIE:
	        {
	            if(!CanUseAbility(playerid)) return 0;
	            new victimid = GetClosestPlayer(playerid), player = victimid;
	            
	            switch(getZombieClass(playerid))
	            {
	                /// ZOMBIES
	                case KAMIKAZEZOMBIE:
	                {
	                    if(Time <= 0)
						{
							GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
							return 1;
						}
				        if(gettime() - 20 < Abilitys[playerid][KamikazeAbiility])
				        {
							GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
							return 1;
						}
			        	for( new j = 0; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) return 0;
			   			Abilitys[playerid][KamikazeAbiility] = gettime() + 20;
			   			boomersOnDeath(playerid, 2);
			   			return 1;
	                }
	                
	                case SPOREZOMBIE:
	                {
	                    if(gettime() < Abilitys[playerid][SporeZombie_CoolDown])
			 		    {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
					    GameTextForPlayer(playerid,"~g~Activated for 10 seconds",2000,5);
				    	Abilitys[playerid][SporeZombie] = gettime()+10;
				    	Abilitys[playerid][SporeZombie_CoolDown] = gettime()+45;
				    	SetAbilityTimer(playerid, 45);
				    	AchievementAddProgress(playerid, ach_USED_ABILITY);
				    	return 1;
	                }
	                
	                case GUNJAMMERZOMBIE:
	                {
	                    if(gettime() < Abilitys[playerid][GunJammer_CoolDown])
			 		    {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
					    GameTextForPlayer(playerid,"~g~Activated for 15 seconds",2000,5);
				    	Abilitys[playerid][GunJammer] = gettime()+15;
				    	Abilitys[playerid][GunJammer_CoolDown] = gettime()+45;
				    	SetAbilityTimer(playerid, 45);
				    	AchievementAddProgress(playerid, ach_USED_ABILITY);
				    	return 1;
	                }
	                
	                case FREEZERZOMBIE:
	                {
	                    if(Time <= 0) return GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
			 		    if(gettime() - 40 < Abilitys[playerid][Freeze])
			 		    {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
					    new Float:pos[3];
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						if(IsPlayerConnected(victimid))
						{
							if(IsPlayerInRangeOfPoint(victimid, 5.0, pos[0], pos[1], pos[2]) && GetPlayerTeamEx(victimid) == TEAM_HUMAN)
							{
			        			ApplyAnimation(playerid, "CARRY", "putdwn05", 3.0, 0, 1, 1, 0, 410);
			    				new count;
			     				foreach(Player, i)
						     	{
			       					if(IsPlayerInRangeOfPoint(i, 6.0, pos[0], pos[1], pos[2]) && canBeFreezed(i) && GetPlayerTeamEx(i) == TEAM_HUMAN)
							    	{
										count++;
										TogglePlayerControllable(i, false);
										SetTimerEx("UnfreezePlayer", 8000, 0, "i", i);
									}
								}
								if (count > 0)
								{
									GivePlayerXP(playerid, 2);
									Abilitys[playerid][Freeze] = gettime();
									SetAbilityTimer(playerid, 40);
									AchievementAddProgress(playerid, ach_USED_ABILITY);
			      					if (count >= 1 && count < 5) foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][93], Player[playerid][UserName], count);
			                        if (count >= 5) foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][94], Player[playerid][UserName], count);
								}
							}
						}
						return 1;
	                }
	                
	                case SPITTERZOMBIE:
	                {
	                    for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 6.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) return 0;
			            new weapname[32];
						GetWeaponName(23, weapname, sizeof(weapname));
			   			if(GetPVarInt(playerid, weapname) >= 1) return 0;
						if(gettime() - 45 < Abilitys[playerid][SpitterWeapon])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
				 		GivePlayerWeaponAC(playerid, 23, 1, false);
						Abilitys[playerid][SpitterWeapon] = gettime();
						SetAbilityTimer(playerid, 45);
						AchievementAddProgress(playerid, ach_USED_ABILITY);
						return 1;
	                }
	                
	                case SPACEBREAKERZOMBIE:
	                {
                 		if(GetPlayerVirtualWorld(playerid) == 0)
	                    {
						   	if(gettime() - 20 < Abilitys[playerid][BreakSpace])
					   		{
								switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
							        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
								}
								return 1;
							}
			    			SetPlayerAttachedObject(playerid, 9, 2780,1, 0.000000,0.000000,0.014999,0.000000,0.000000,0.000000,0.409000,0.090999,0.000000);
			       			SetTimerEx("SpaceBreaker", 3000, 0, "i", playerid);
							Abilitys[playerid][BreakSpace] = gettime();
							SetAbilityTimer(playerid, 20);
							AchievementAddProgress(playerid, ach_USED_ABILITY);
						}
						else
						{
							SetPlayerVirtualWorld(playerid, 0);
							SetPlayerWeather(playerid, 0);
							SetPlayerDrunkLevel(playerid, 0);
							SetPlayerTime(playerid,12,0);
						}
						return 1;
	                }
	                
	                case RISENDEAD:
	                {
	                    new bool:canBeDone;
			 		    for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 110.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) { canBeDone = true; break; }
			            for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 25.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) { canBeDone = false; break; }
						for( new j; j < sizeof(Map[HumanSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 25.0, Map[HumanSpawnX][j], Map[HumanSpawnY][j], Map[HumanSpawnZ][j])) { canBeDone = false; break; }

						if(!canBeDone)
						{
						    SendClientMessage(playerid, -1, "{FF0000}>> Too far or too close from Zombies/Humans Spawn Arena!");
						    return 1;
						}
						if(NewSpawnPoints[0][0] == 0.0)
			 		    {
			 		        GetPlayerPos(playerid, NewSpawnPoints[0][0], NewSpawnPoints[0][1], NewSpawnPoints[0][2]);

			 		        new nText[MAX_PLAYER_NAME + 32];
			 		        format(nText, sizeof(nText), "{ffff99}%s's\nZombie Spawn", Player[playerid][UserName]);
			 		        NewSpawnPointsText[0] = Create3DTextLabel(nText, 0xFF0000FF, NewSpawnPoints[0][0], NewSpawnPoints[0][1], NewSpawnPoints[0][2], 50.0, 0, 1);
			                NewSpawnsCreators[0] = playerid;
					 	}
				        else if(NewSpawnPoints[1][0] == 0.0)
			 		    {
			 		        GetPlayerPos(playerid, NewSpawnPoints[1][0], NewSpawnPoints[1][1], NewSpawnPoints[1][2]);
			 		        new nText[MAX_PLAYER_NAME + 32];
			 		        format(nText, sizeof(nText), "{ffff99}%s's\nZombie Spawn", Player[playerid][UserName]);
			 		        NewSpawnPointsText[1] = Create3DTextLabel(nText, 0xFF0000FF, NewSpawnPoints[1][0], NewSpawnPoints[1][1], NewSpawnPoints[1][2], 50.0, 0, 1);
			                NewSpawnsCreators[1] = playerid;
					 	}
					 	else
					 	{
					 	    SendClientMessage(playerid, -1, "{FF0000}>> Limit Exceeded!");
					 	    return 1;
					 	}
					 	return 1;
	                }
	                
	                case STOMPERZOMBIE:
	                {
                 		if(gettime() - 8 < Abilitys[playerid][StomperPushing])
				        {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
						ApplyAnimation(playerid, "CARRY", "putdwn05", 3.0, 0, 1, 1, 0, 410);
						new count, Float:pos[4], objectid;
				        GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						if(Time >= 1)
						{
							objectid = CreateObject(18675, pos[0], pos[1], pos[2] - 1.2, 0.0, 0.0, 0.0);
							SetTimerEx("RemoveObject", 1000, 0, "i", objectid);
						}
						new Float:radius = 6.0;
						foreach(Player,i)
						{
							if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2]))
			    			{
			    			    if(GetPlayerTeamEx(i) == TEAM_HUMAN && classCanBeStomped(i))
						    	{
						    	    count++;
			   						GetPlayerFacingAngle(i, pos[3]);
									GetPlayerVelocity(i, pos[0], pos[1], pos[2]);
									SetPlayerVelocity(i, pos[0]*4.0, pos[1]*4.0, pos[2]+1.5);
									SetPlayerFacingAngle(i, pos[3]);
									AntiTPTimerEx(i, 4);
									AntiSlap(i, 2);
									AntiSpeedHack(i, 3);
									Player[i][AbilityAffectedID] = playerid;
								}
							}
						}
						Abilitys[playerid][StomperPushing] = gettime();
						SetAbilityTimer(playerid, 8);
						AchievementAddProgress(playerid, ach_USED_ABILITY);
						return 1;
      				}
      				
      				case EARTHSHAKERZOMBIE:
      				{
      				    if(gettime() - 20 < Abilitys[playerid][EarthPushing])
				        {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
						ApplyAnimation(playerid, "CARRY", "putdwn05", 3.0, 0, 1, 1, 0, 410);
						new count, Float:pos[5], objectid;
				        GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
				        if(Time >= 1)
						{
					        objectid = CreateObject(18675, pos[0], pos[1], pos[2] - 1.2, 0.0, 0.0, 0.0);
							SetTimerEx("RemoveObject", 1000, 0, "i", objectid);
						}

						new Float:radius = 16.0;
						foreach(Player,i)
						{
							if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2]))
			    			{
			    			    if(GetPlayerTeamEx(i) == TEAM_HUMAN && classCanBeStomped(i))
						    	{
						    	    count++;
			   						GetPlayerFacingAngle(i, pos[3]);
									GetPlayerVelocity(i, pos[0], pos[1], pos[2]);
									SetPlayerVelocity(i, pos[0]*4.0, pos[1]*4.0, pos[2]+1.5);
									SetPlayerFacingAngle(i, pos[3]);
									GetPlayerHealth(i, pos[4]);
									SetPlayerHealthAC(i, pos[4] - 3.0);
									AntiTPTimerEx(i, 4);
									AntiSlap(i, 2);
									AntiSpeedHack(i, 3);
									Player[i][AbilityAffectedID] = playerid;
								}
							}
						}
						if(count >= 1) GivePlayerXP(playerid, 2);
						Abilitys[playerid][EarthPushing] = gettime();
						AchievementAddProgress(playerid, ach_USED_ABILITY);
						SetAbilityTimer(playerid, 20);
						return 1;
      				}
      				
      				case REMOVER:
      				{
      				    if(gettime() - 10 < Abilitys[playerid][RemoverRemove])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
						new Float:pos[3];
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);

						new Float:radius = 1.5;
						if(IsPlayerInRangeOfPoint(player, radius, pos[0], pos[1], pos[2]))
						{
				            if(IsPlayerConnected(player))
							{
							    new Float: Arm;
							    GetPlayerArmour(player, Arm);
							    if(GetPlayerTeamEx(player) == TEAM_HUMAN && Arm >= 0.1 && classCanBeArmourRemoved(player))
				       			{
				       			    ApplyAnimation(playerid, "CARRY", "putdwn05", 3.0, 0, 1, 1, 0, 410);
				       			    SetPlayerArmourAC(player, -0.0);
				         			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][73], Player[playerid][UserName], Player[player][UserName]);
									Player[player][AbilityAffectedID] = playerid;
									AchievementAddProgress(playerid, ach_USED_ABILITY);
							    }
							}
							Abilitys[playerid][RemoverRemove] = gettime();
							SetAbilityTimer(playerid, 10);
					    }
					    return 1;
      				}
      				
      				case SLENDERZOMBIE:
      				{
      				    if(gettime() - 40 < Abilitys[playerid][SlenderBlind])
						{
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
						SeekerHunting(playerid, 1);
						return 1;
      				}
      				
      				case SEEKERZOMBIE:
      				{
      				    if(gettime() - 35 < Abilitys[playerid][SeekerFound])
						{
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
						SeekerHunting(playerid, 0);
						return 1;
      				}
      				
      				case BLINDZOMBIE:
      				{
			            if(gettime() - 7 < Abilitys[playerid][InfectionBlind])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						    if(!Player[player][AntiBlind])
			       			{
								if(InfectPlayer(1.5, player, playerid))
								{
								    ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,450);
								    BlindPlayer(player, 8);
			         				foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][27], Player[player][UserName], Player[playerid][UserName]);
									GivePlayerXP(playerid, 2);
									AchievementAddProgress(playerid, ach_USED_ABILITY);
								}
						    }
						    else
						    {
								switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
							        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
								}
								return 1;
							}
						    Abilitys[playerid][InfectionBlind] = gettime();
							SetAbilityTimer(playerid, 7);
						}
						return 1;
      				}
      				
      				case ROGUEZOMBIE:
      				{
      				    if(gettime() - 30 < Abilitys[playerid][RogueSkinChangeZ])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			         	SetPlayerColor(playerid, COLOR_HUMAN);
      				    new skin = random(sizeof(civilRandomSkins));
		        		SetPlayerSkinAC(playerid, civilRandomSkins[skin], 1);
		        		ClearAnimations(playerid);
			            Abilitys[playerid][RogueSkinChangeZ] = gettime();
			            SetTimerEx("RogueSkinBackZ", 15000, 0, "i", playerid);
			            SetAbilityTimer(playerid, 30);
			            AchievementAddProgress(playerid, ach_USED_ABILITY);
			            return 1;
      				}
      				
      				case SLOWZOMBIE:
      				{
      				    if(gettime() - 10 < Abilitys[playerid][InfectionSlow])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						    if(GetPlayerTeamEx(player) == TEAM_HUMAN)
						    {
						        new Float:pos[3], Float:radius = 2.5;
						        GetPlayerPos(player, pos[0], pos[1], pos[2]);
						        if(IsPlayerInRangeOfPoint(playerid, radius, pos[0], pos[1], pos[2]))
						        {
								    if(InfectPlayer(radius, player, playerid))
					       			{
					       			    ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,450);
					       			    if(Player[player][pXP] >= 2500) Player[player][SlowWalk] = gettime()+360;

					         			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][97], Player[player][UserName], Player[playerid][UserName]);
										GivePlayerXP(playerid, 2);
										Player[player][AbilityAffectedID] = playerid;
										AchievementAddProgress(playerid, ach_USED_ABILITY);
								    }
								    else
								    {
										switch(Player[playerid][pLang])
									    {
											case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
									        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
									        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
										}
										return 1;
									}
								}

							}
						}
						Abilitys[playerid][InfectionSlow] = gettime();
						SetAbilityTimer(playerid, 15);
						return 1;
      				}
      				
      				case LEGBREAKER:
      				{
      				    if(Time <= 0) return GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
			            if(gettime() - 40 < Abilitys[playerid][LegBreaks])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}

						new Float:pos[3];
						GetPlayerPos(playerid, pos[0], pos[1], pos[2]);

						new Float:radius = 2.0;
						if(IsPlayerInRangeOfPoint(player, radius, pos[0], pos[1], pos[2]))
						{
				            if(IsPlayerConnected(player) && canBeLegBreaked(player))
							{
							    foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][98], Player[playerid][UserName], Player[player][UserName]);
							    Player[player][LegBreak] = true;
							    ApplyAnimation(playerid, "CARRY", "putdwn05", 3.0, 0, 1, 1, 0, 410);
								GivePlayerXP(playerid, 2);
								Abilitys[playerid][LegBreaks] = gettime();
								SetAbilityTimer(playerid, 40);
								AchievementAddProgress(playerid, ach_USED_ABILITY);
							}
					    }
					    return 1;
      				}
      				
      				case STANDARDZOMBIE:
      				{
			            if(gettime() - 7 < Abilitys[playerid][InfectionNormal])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						    if(InfectPlayer(2.0, player, playerid))
			       			{
			       			    ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,450);
			         			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][27], Player[player][UserName], Player[playerid][UserName]);
								GivePlayerXP(playerid, 2);

								Player[player][AbilityAffectedID] = playerid;
								AchievementAddProgress(playerid, ach_USED_ABILITY);
						    }
						    else
						    {
								switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
							        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
								}
								return 1;
							}
						    Abilitys[playerid][InfectionNormal] = gettime();
							SetAbilityTimer(playerid, 7);
						}
						return 1;
      				}
      				
      				case PUNKZOMBIE:
      				{
      				    if(gettime() - 10 < Abilitys[playerid][InfectionNormal])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						   	if(InfectPlayer(2.5, player, playerid, 4.0) && Player[player][pXP] >= 2500)
			       			{
			         			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][27], Player[player][UserName], Player[playerid][UserName]);
								GivePlayerXP(playerid, 2);
								ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,450);
								Player[player][AbilityAffectedID] = playerid;
								AchievementAddProgress(playerid, ach_USED_ABILITY);
						    }
						    else
						    {
								switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
							        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
								}
								return 1;
							}
						    Abilitys[playerid][InfectionNormal] = gettime();
							SetAbilityTimer(playerid, 10);
						}
						return 1;
      				}
      				
      				case ADVANCEDMUTATED:
      				{
      				    if(gettime() - 15 < Abilitys[playerid][AdvancedMutated])
				        {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
				        if(InfectPlayer(2.0, player, playerid, 3.5, 15000, true))
						{
						    ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,490);
							foreach(Player, j) SendClientMessageFormat(j,-1,serverLang[Player[j][pLang]][27], Player[player][UserName], Player[playerid][UserName]);
							GivePlayerXP(playerid, 2);
							AchievementAddProgress(playerid, ach_USED_ABILITY);
						}
						else
						{
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
						        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
							}
							return 1;
						}
						Abilitys[playerid][AdvancedMutated] = gettime();
						SetAbilityTimer(playerid, 15);
						return 1;
      				}
      				
      				case REAPERZOMBIE:
      				{
			            if(gettime() - 7 < Abilitys[playerid][InfectionNormal])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						    new Float:pos[3];
						    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
						    if(IsPlayerInRangeOfPoint(player, 2.0, pos[0], pos[1], pos[2]) && GetPlayerTeamEx(player) == TEAM_HUMAN)
						    {
						        new Float:h;
						        GetPlayerHealthEx(player, h);
						        SetPlayerHealthAC(player, h - 5.0);
			       			    ApplyAnimation(playerid, "BIKELEAP", "BK_RDY_IN", 4.1, false, false, false, false, 0, false);
								GivePlayerXP(playerid, 2);
								AchievementAddProgress(playerid, ach_USED_ABILITY);
						    }
						    Abilitys[playerid][InfectionNormal] = gettime();
							SetAbilityTimer(playerid, 7);
						}
						return 1;
      				}
      				
      				case MUTATEDZOMBIE:
      				{
			            if(gettime() - 7 < Abilitys[playerid][InfectionNormal])
			            {
							switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
			            if(IsPlayerConnected(player))
						{
						    if(InfectPlayer(2.0, player, playerid, _, 5000))
			       			{
			       			    ApplyAnimation(playerid,"BIKELEAP","bk_jmp",3.1,0,0,0,0,450);
			         			foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][27], Player[player][UserName], Player[playerid][UserName]);
								GivePlayerXP(playerid, 2);

								Player[player][AbilityAffectedID] = playerid;
								AchievementAddProgress(playerid, ach_USED_ABILITY);
						    }
						    else
						    {
								switch(Player[playerid][pLang])
							    {
									case 0: GameTextForPlayer(playerid, "~r~Cannot infect", 2000, 5);
							        case 1: GameTextForPlayer(playerid,RusToGame("~r~НЕЛЬЗЯ ЗАРАЗИТЬ"), 2000, 5);
							        case 2: GameTextForPlayer(playerid,"~r~No puede infectar", 2000, 5);
								}
								return 1;
							}
						    Abilitys[playerid][InfectionNormal] = gettime();
							SetAbilityTimer(playerid, 7);
						}
						return 1;
      				}
      				
      				case MEGAJUMPERZOMBIE:
      				{
      				    if(Abilitys[playerid][ZombieJumps][0] >= 1)
				        {
			            	new Float:pos[3];
			           		GetPlayerVelocity(playerid,pos[0],pos[1],pos[2]);
							SetPlayerVelocity(playerid,pos[0]*2.0,pos[1]*2.0,pos[2]+1.8* 1.2);
							Abilitys[playerid][ZombieJumps][0]--;
							AntiTPTimerEx(playerid, 4);
							AntiSlap(playerid, 2);
							AntiSpeedHack(playerid, 3);
							Abilitys[playerid][ZombieJumps][1] = gettime()+5;
							SetAbilityTimer(playerid, 5);
							AchievementAddProgress(playerid, ach_USED_ABILITY);
						}
						return 1;
      				}
      				
      				case RADIOACTIVEZOMBIE:
      				{
      				    Player[playerid][RadioctiveField] =! Player[playerid][RadioctiveField];
				        if(Player[playerid][RadioctiveField]) GameTextForPlayer(playerid, "~y~Radioactive field:~g~ ON", 1500, 5);
				        else GameTextForPlayer(playerid, "~y~Radioactive field:~r~ OFF", 1500, 5);
				        return 1;
      				}
      				
      				case SCREAMERZOMBIE:
      				{
      				    if(gettime() - 20 < Abilitys[playerid][ScreamerZombieAb])
						{
						   	switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
						        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
						        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
							}
							return 1;
						}
				        if(Time <= 0)
						{
						    switch(Player[playerid][pLang])
						    {
								case 0: GameTextForPlayer(playerid,"~r~Time is up", 4000, 5);
								case 1: GameTextForPlayer(playerid,RusToGame("~r~УЖЕ КОНЕЦ"), 4000, 5);
								case 2: GameTextForPlayer(playerid,"~r~El tiempo ha terminado", 4000, 5);
							}
							return 1;
						}
				        new Float:pos[4];
				        GetPlayerPos(playerid,pos[0], pos[1], pos[2]);
				        GetPlayerFacingAngle(playerid, pos[3]);
						foreach(Player,i)
						{
							if(IsPlayerInRangeOfPoint(i, 6.0, pos[0], pos[1], pos[2]))
							{
						    	if(i != playerid && canBeScreamed(i))
								{
								   	switch(Player[i][pLang])
								    {
										case 0: GameTextForPlayer(i,"~r~ Screamer Attack", 1000, 5);
								        case 1: GameTextForPlayer(i,RusToGame("~r~ПРИСТУП СТРАХА"), 1000, 5);
								        case 2: GameTextForPlayer(i,"~r~Chillon Ataque", 1000, 5);
									}
									ApplyAnimation(i, "PED", "BIKE_fall_off", 4.1, 0, 1, 1, 1, 4000, 1);
									if(GetPlayerTeamEx(i) != GetPlayerTeamEx(playerid)) Player[i][AbilityAffectedID] = playerid;
								}
							}
						}
						Abilitys[playerid][ScreamerZombieAb] = gettime();
						SetAbilityTimer(playerid, 20);
						AchievementAddProgress(playerid, ach_USED_ABILITY);
						return 1;
      				}
	            }
	            return 1;
			}
		}
	}
	return 1;
}

fun OnRconLoginAttempt( ip[], password[], success)
{
    if(!success)
    {
        new pip[21];
        for(new i = GetPlayerPoolSize(); i != -1; --i)
        {
            GetPlayerIp(i, pip, sizeof(pip));
            if(!strcmp(ip, pip, true))
            {
                Ban(i);
            }
        }
    }
	return 1;
}

fun RemoveObject(objectid)
{
	if(IsValidObject(objectid))
	{
		DestroyObject(objectid);
		objectid = INVALID_OBJECT_ID;
	}
}

fun RemoveBox(playerid, boxid)
{
	if(IsValidObject(box[playerid][boxid]))
    {
    	DestroyObject(box[playerid][boxid]);
  		Delete3DTextLabel(boxText[playerid][boxid]);
  		box[playerid][boxid] = INVALID_OBJECT_ID;
	}
}

fun OnPlayerUpdate(playerid)
{
	////////////////////////////// EVENT ///////////////////////
	
	if(GetPlayerSpeed(playerid) >= 1 && !IsPlayerInAnyVehicle(playerid) && Achievements[playerid][ach_RUNNED] <= 199.99999)
	{
        Achievements[playerid][ach_RUNNED] += 0.00001;
        AchievementAddProgress(playerid, ach_RUNNED);
	}
	
    if(gettime() >= 1606780800 && gettime() <= 1609545600) /// From 1 december to 2 junary
    {
        SetPlayerAttachedObject(playerid, 6, 19066, 2, 0.16499, 0.03100, 0.00000, -65.70002, 65.70001, 156.00000, 1.00000, 1.00000, 1.00000);
    }
    
 	if(Player[playerid][GunJammerAttack] && GetPlayerWeapon(playerid) > 0 && GetPlayerTeamEx(playerid) == TEAM_HUMAN && PlayerGuitarTime[playerid] <= 1)
    {
    	GameTextForPlayer(playerid,"~r~Gun Jammer Attack", 2000, 5);
		SetPlayerArmedWeapon(playerid, 0);
	}

	if(Player[playerid][HeroField] && GetPlayerWeapon(playerid) > 0 && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
    {
    	GameTextForPlayer(playerid,"~g~Hero Field", 2000, 5);
		SetPlayerArmedWeapon(playerid, 0);
	}
	
    static Keys, lr, ud;

	GetPlayerKeys(playerid, Keys, ud, lr);
    
	if(AFK[playerid] >= 15 && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    if(!Player[playerid][aDuty] && !Player[playerid][pInGangMatch])
	    {
		    SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		    SpawnPlayer(playerid);
		    AFK[playerid] = -5;
		    Player[playerid][Killstreak] = 0;
		    SortKillstreakList();
		    DeleteFromKillstreakList(playerid);
	        if(Player[playerid][eventMember] > -1)
			{
			    new bool:something = false, str[64], p;
			    for(p = 0; p < 10; p++) if(EventInfo[Player[playerid][eventMember]][e_Rulers][p] == Player[playerid][pAccountID]) { something = true; break; }

				new eventID = Player[playerid][eventMember];
			    if(strlen(EventInfo[eventID][e_Name]) >= 1)
			    {
					if(!something) {
						EventInfo[Player[playerid][eventMember]][e_curPlayers]--;
						format(str, sizeof(str), "{ff6600}[EVENT] %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						SendEventMessage(str);
					} else {
					    format(str, sizeof(str), "{bf00ff}[EVENT] Ruler %s has left the event (%s #%d)", Player[playerid][UserName], EventInfo[Player[playerid][eventMember]][e_Name], Player[playerid][eventMember]+1);
						SendEventMessage(str);
					}

					if(EventInfo[eventID][e_curPlayers] < EventInfo[eventID][e_minPlayers] && !EventInfo[eventID][e_IsStarted] && EventInfo[eventID][e_IsJoinsClosed])
			        {
			            EventInfo[eventID][e_IsJoinsClosed] = false;
						format(str, sizeof(str), "{bf00ff}[EVENT] Join requests auto opened (%s #%d)", EventInfo[eventID][e_Name], eventID+1);
						SendEventMessage(str);
			        }
				}
			    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
				Player[playerid][eventMember] = -1;
				SetPlayerGravity(playerid, 0.008);
			}
	    }
	}
	
	if(IsJumping(playerid) || IsRunning(playerid)) SetPVarInt(playerid, "Slide", 0);
    if(GetPlayerAnimationIndex(playerid) == 1161 && GetPlayerSpeed(playerid) > 15 && GetPlayerSkin(playerid) != 92 && GetPlayerSkin(playerid) != 99)
    {
        SetPlayerArmedWeapon(playerid, 0);
        ClearAnimations(playerid);
    }
	if(GetPlayerAnimationIndex(playerid) == 1161 && GetPlayerSpeed(playerid) > 9 && GetPlayerSkin(playerid) != 92 && GetPlayerSkin(playerid) != 99 && GetPVarInt(playerid, "Slide") > 0)
	{
		SetPlayerArmedWeapon(playerid, 0);
        ClearAnimations(playerid);
	}
	
    if(Player[playerid][GunJammerAttack] && GetPlayerWeapon(playerid) > 0 && GetPlayerTeamEx(playerid) == TEAM_HUMAN && PlayerGuitarTime[playerid] <= 1)
    {
    	GameTextForPlayer(playerid,"~r~Gun Jammer Attack", 2000, 5);
		SetPlayerArmedWeapon(playerid, 0);
	}
	
	//if(AFK[playerid] >= -3) uAFK
    AFK[playerid] = -5;
    
    static Float:xw, Float:yw, Float:zw;
	GetPlayerVelocity(playerid,xw,yw,zw);
	if((xw >= 0.4 || yw >= 0.4 || zw >= 0.4) && Player[playerid][Accelerated] <= 0 && gettime() > AntiPlayerSlap[playerid] && !(GetPlayerAnimationIndex(playerid) >= 1061 && GetPlayerAnimationIndex(playerid) <= 1067) && p_FallingCheck{playerid} <= 1 && GetPlayerSurfingVehicleID(playerid) == INVALID_PLAYER_ID && !Player[playerid][aDuty]) //&& !IgnoreThisClass(playerid))
	{
		if(GetPVarInt(playerid, "Pizdorvanka") <= 1) SetPVarInt(playerid, "Pizdorvanka", GetPVarInt(playerid, "Pizdorvanka") + 1);
		if(GetPVarInt(playerid, "Pizdorvanka") == 1)
		{
			SetPVarInt(playerid, "Pizdorvanka", 0);
			if(gettime() > AntiCheat[playerid][ac_Tick])
			{
				if(!IsJumping(playerid))
				{
					foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Slap Hack", Player[playerid][UserName], playerid);
		            SetPVarInt(playerid, "Pizdorvanka", GetPVarInt(playerid, "Pizdorvanka") + 1);
		            strmid(AC_Requests[playerid][ac_reason], "Slap Hack", 0, 128, 128);
					AC_Requests[playerid][ac_time] = gettime();
					AC_Requests[playerid][ac_type] = 0;
					AC_Requests[playerid][ac_additional] = 0;
					AC_Requests[playerid][ac_pl] = NetStats_PacketLossPercent(playerid);
					AntiCheat[playerid][ac_Tick] = (gettime()+1);
					
					if(AntiCheatAlertMode)
					{
					    ++AntiCheat[playerid][ac_jumps];
					    if(AntiCheat[playerid][ac_jumps] > AX_MAX_JUMPS && AntiCheat[playerid][ac_jump_hack] >= AC_MAX_REPORTS) BanPlayer(playerid, "Slap Hack - Consensus");
					}
				}
				else
				{
				    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Jump Hack", Player[playerid][UserName], playerid);
		            SetPVarInt(playerid, "Pizdorvanka", GetPVarInt(playerid, "Pizdorvanka") + 1);
		            strmid(AC_Requests[playerid][ac_reason], "Jump Hack", 0, 128, 128);
					AC_Requests[playerid][ac_time] = gettime();
					AC_Requests[playerid][ac_type] = 0;
					AC_Requests[playerid][ac_additional] = 0;
					AC_Requests[playerid][ac_pl] = NetStats_PacketLossPercent(playerid);
					AntiCheat[playerid][ac_Tick] = (gettime()+1);
					
					if(AntiCheatAlertMode)
					{
					    ++AntiCheat[playerid][ac_jumps];
					    if(AntiCheat[playerid][ac_jumps] > AX_MAX_JUMPS && AntiCheat[playerid][ac_jump_hack] >= AC_MAX_REPORTS) BanPlayer(playerid, "Jump Hack - Consensus");
					}
				}
			}
		}
		if(GetPVarInt(playerid, "Pizdorvanka") >= 3 && AntiCheatAlertMode && AntiCheat[playerid][ac_jump_hack] >= AC_MAX_REPORTS)
		{
		    foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Possible slap hack (Limit exceeded)]", Player[playerid][UserName]);
			BanPlayer(playerid, "Slap Hack - Consensus");
		}
	}
	
	if((IsJumping(playerid) || IsFalling(playerid)) && JumpTimes[playerid] <= 2)
	{
	    GetPlayerVelocity(playerid,xw,yw,zw);
		if(zw <= -0.15) if(AntiCheat[playerid][ac_OldHP] <= 0.0) GetPlayerHealthEx(playerid, AntiCheat[playerid][ac_OldHP]);
    }
    
    if(AntiCheat[playerid][ac_OldHP] != 0.0 && (GetPlayerAnimationIndex(playerid) == 1155 || GetPlayerAnimationIndex(playerid) == 1156) && !Player[playerid][aDuty] && AFK[playerid] <= -3)
	{
	    GetPlayerHealthEx(playerid, zw);
		if(zw >= AntiCheat[playerid][ac_OldHP])
		{
		    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Health Hack (Collision)", Player[playerid][UserName], playerid);
            strmid(AC_Requests[playerid][ac_reason], "Health Hack", 0, 128, 128);
			AC_Requests[playerid][ac_time] = gettime();
			AC_Requests[playerid][ac_type] = 0;
			AC_Requests[playerid][ac_additional] = 0;
			AC_Requests[playerid][ac_pl] = NetStats_PacketLossPercent(playerid);
			AntiCheat[playerid][ac_Tick] = (gettime()+1);

			if(AntiCheatAlertMode)
			{
				++AntiCheat[playerid][ac_cs_warns];
				if(AntiCheat[playerid][ac_cs_warns] > AC_MAX_COLLISION_PROOF_WARNINGS && AntiCheat[playerid][ac_health_hack] >= AC_MAX_REPORTS) BanPlayer(playerid, "Health Hack - Consensus");
			}
		}
		AntiCheat[playerid][ac_OldHP] = 0.0;
  	}
	
//	static Keys, lr, ud;
	//GetPlayerKeys(playerid, Keys, lr, ud);
	
	if(Keys & KEY_SPRINT && GetPlayerAnimationIndex(playerid) >= 1222 && GetPlayerAnimationIndex(playerid) <= 1236 && !IsFalling(playerid) && Player[playerid][Accelerated] >= 1)
	{
		GetPlayerVelocity(playerid,xw,yw,zw);
		if(zw >= 0.01 || zw <= -0.01 || xw >= 0.15 || xw <= -0.15 || yw >= 0.15 || yw <= -0.15) {} //SendClientMessageFormat(playerid, -1, "%.2f | %.2f", xw, yw);
		else
		{
			static Float:a, Float:vx, Float:vy;
			GetPlayerFacingAngle(playerid, a);
			vx = 0.5 * floatcos(-(a+90), degrees);
			vy = 0.5 * floatsin(-(a-90), degrees);
			SetPlayerVelocity(playerid, vx, vy, 0.00);
		}
	}
    
	if(Player[playerid][aDuty] || GetPlayerTeamEx(playerid) == 254) SetPlayerHealthAC(playerid, 200.0);

    switch(GetPlayerWeapon(playerid))
	{
		case 44, 45:
      	{
      		if((Keys & KEY_FIRE) && (!IsPlayerInAnyVehicle(playerid)))
       		{
        		return 0;
        	}
    	}
	}
    
	return 1;
}

fun OnVehicleStreamIn(vehicleid, forplayerid)
{
	return 1;
}

fun OnVehicleStreamOut(vehicleid, forplayerid)
{
	return 1;
}

fun OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
	//if(listitem <= -1) return 0;
	
    new query[800], scs[2][128];
    
 	switch(dialogid)
	{
	    case DIALOG_MATCH_CLASS:
	    {
     		SetGangMatchClass(playerid, 0, Clan[Player[playerid][pClan]][g_WarType]);
	        if(response) {
	            SetGangMatchClass(playerid, listitem, Clan[Player[playerid][pClan]][g_WarType]);
	        }
	        return 1;
	    }
	    case DIALOG_ACCEPT_MATCH:
	    {
	        if(response) {
	            
	            new gid = Player[playerid][pClan],
					id = Clan[gid][g_WeeksToKick];
					
                Clan[gid][g_ForMapID] = Clan[id][g_ForMapID];

                if(Clan[id][g_WarForCup] <= 0)
                {
                    Clan[gid][g_WarType] = 0;
			    	Clan[id][g_WarType] = 1;
			    	
	    			SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: %s agreed to a match with %s", Clan[gid][Full], Clan[id][Full]);
	    			
	    			for( new j = 0; j < sizeof(Clan); j++ ) {
	    			    if(Clan[gid][g_AllianceWith][j] >= 2) SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: Leader of %s get up your ass, your alliance needs help! (/gang match)", Clan[j][Full]);
	    			    if(Clan[id][g_AllianceWith][j] >= 2) SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: Leader of %s get up your ass, your alliance needs help! (/gang match)", Clan[j][Full]);
	    			}

                    Clan[gid][g_ObjectHealth] = 1000.0;
					Clan[gid][g_TimesPlayed] = gettime()+99000;
					Clan[id][g_TimesPlayed] = gettime()+99000;
			    	Clan[gid][g_Emblem] = 100 + gid;
			    	Clan[id][g_Emblem] = 100 + gid;
			    	Clan[id][g_WarForCup] = 1;
			    	Clan[gid][g_WarForCup] = 1;
			    	Clan[gid][g_TimeToJoin] = 1;
			    	Clan[id][g_TimeToJoin] = 1;
			    	
			    	foreach(Player, i) {
				        if(Player[i][pClan] == gid || Player[i][pClan] == id) {
				            if(Player[i][pClanRank] < 5) {
								SendClientMessage(i, -1, "{C659B6}>> Your gang leader has accepted a match join by /gang match");
								SendClientMessage(i, -1, "{C659B6}>> You have 1 minute to join!");
							}
							else SetGangMatchClass(i, 0, Clan[Player[i][pClan]][g_WarType]);
						}
				    }
			    	
			    	SetTimerEx("GangWarGo", 60000, 0, "ddd", gid, id, Clan[gid][g_ForMapID]);
			    	Delete3DTextLabel(Clan[gid][g_ObjectStatus]);
					new str[128];
					format(str, sizeof(str), "{FFF000}%s's OBJECT\n\nHealth: %.2f", Clan[gid][Full], Clan[gid][g_ObjectHealth]);
					Clan[gid][g_ObjectStatus] = Create3DTextLabel(str, 0xFF0000FF, 2787.05493, 1160.48682, 13.42287, 30.0, Clan[gid][g_Emblem], 0);
			    	
	            } else {
	                SendClientMessage(playerid, -1, "{FFF000}>> This gang has already played a match or choose another opponent!");
	                return 1;
	            }
	        }
	        return 1;
	    }
	    case DIALOG_VIP_MENU:
	    {
	        if(response)
	        {
	            if(Player[playerid][pVip] <= 2) return 1;
	            switch(listitem)
	            {
	                case 0: { VipTeamSelected[playerid] = TEAM_HUMAN; SendClientMessage(playerid, -1, "{FFF000}>> Now you will spawn as a Human every round"); }
	                case 1: { VipTeamSelected[playerid] = TEAM_ZOMBIE; SendClientMessage(playerid, -1, "{FFF000}>> Now you will spawn as a Zombie every round"); }
	                case 2: { VipTeamSelected[playerid] = -1; SendClientMessage(playerid, -1, "{FFF000}>> Now you will spawn for a random team"); }
	            }
	        }
	        return 1;
	    }
	    
	    case DIALOG_JOIN_GANG:
	    {
			return 1;
		}
		
	    case DIALOG_CHANNELS:
	    {
	        return 1;
	    }
	    
    	case DIALOG_INFO_ACH:
    	{
 	       	return 1;
    	}

		case DIALOG_TROPHYS_DROP:
		{
		    return 1;
		}

	    case DIALOG_TROPHYS:
	    {
			return 1;
	    }
	    
	    case DIALOG_SHOW_OFFLINE_MEMBERS:
	    {
	        if(response)
	        {
	            if(AccountsToAccept[playerid][listitem] > -1)
	            {
					new found = -5;
					foreach(Player, i)
					{
					    if(Player[i][pAccountID] == AccountsToAccept[playerid][listitem])
					    {
					        if(Player[i][pClan] > 0)
					        {
					            mysql_format(Base, query, sizeof(query), "DELETE FROM `applications` WHERE `ID` = '%d'", Player[i][pAccountID]);
								mysql_tquery(Base, query);
					            AccountsToAccept[playerid][listitem] = -1;
					            SendClientMessage(playerid, -1, "{0099ff}>> The player is already in the gang");
					        }
					        else
					        {
					            Player[i][pClan] = Player[playerid][pClan];
								Player[i][pClanRank] = 1;
								Player[i][pLastGangJoin] = (gettime() + (86400*8));
								
						        foreach(Player, j)
					            {
					                if(Player[j][pClan] == Player[playerid][pClan])
					                {
					                    SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][129], Player[i][UserName], Player[playerid][UserName]);
					                }
					            }
					            
					            mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='%d',`ClanRank`='%d' WHERE `ID` = '%d'", Player[i][pClan], Player[i][pClanRank], Player[i][pAccountID]);
								mysql_tquery(Base, query, "", "", "");
					            
					            mysql_format(Base, query, sizeof(query), "DELETE FROM `applications` WHERE `ID` = '%d'", Player[i][pAccountID]);
								mysql_tquery(Base, query);
								
					            Player[i][GangRequest] = 0;
						        AccountsToAccept[playerid][listitem] = -1;
							}
							found = 1;
							break;
					    }
					}
					if(found <= 0)
					{
					    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='%d',`ClanRank`='%d' WHERE `ID` = '%d' AND `Clan` = '0'", Player[playerid][pClan], 1, AccountsToAccept[playerid][listitem]);
						mysql_tquery(Base, query, "", "", "");
						SendClientMessage(playerid, -1, "{0099ff}>> The rank will be set if the player has not joined another gang");
						
						mysql_format(Base, query, sizeof(query), "DELETE FROM `applications` WHERE `ID` = '%d'", AccountsToAccept[playerid][listitem]);
						mysql_tquery(Base, query);
					}
				}
				else
				{
				    SendClientMessage(playerid, -1, "{0099ff}>> Unknown error");
				}
	        }
	        for( new j = 0; j < 30; j++ ) AccountsToAccept[playerid][j] = -1;
	        return 1;
	    }
	    
	    case DIALOG_CARDS:
	    {
     		return 1;
	    }
	    
	    case DIALOG_UNLOCK_CARD_EFFECT:
	    {
	        return 1;
	    }
	    
	    case DIALOG_TROPHY_SHOW:
	    {
	        return 1;
	    }
	    
	    case DIALOG_TROPHY_SELL:
	    {
     		return 1;
	    }
	    
	    case DIALOG_TROPHYS_DO:
	    {
	        return 1;
	    }
	    
	    case DIALOG_TROPHYS_UPGRADE:
	    {
	        return 1;
	    }
	    
		case DIALOG_COLLECTIONS:
		{
	 		return 1;
		}

        case DIALOG_COLLECTIONS_EXCHANGE:
        {
            return 1;
        }

		case DIALOG_AUCTION_BUY_COUNT:
		{
  			return 1;
		}

        case DIALOG_AUCTION_BUY_COMFIRM:
        {
            return 1;
        }

		case DIALOG_AUCTION_BUY:
		{
  			return 1;
		}

		case DIALOG_AUCTION_SELL_COUNT:
		{
		    return 1;
		}
		
		case DIALOG_AUCTION_SELL_PRICE:
		{
			return 1;
		}

		case DIALOG_AUCTION_CONFRIM:
		{
  			return 1;
		}

		case DIALOG_WEAPON_RESET_BUFFS:
		{
		    return 1;
		}
		
		case DIALOG_AUCTION_SELL:
		{
		    return 1;
		}

	    case DIALOG_INV:
	    {
	        return 1;
	    }
	    
	    case DIALOG_INV_DROP:
	    {
	        return 1;
	    }
	    
	    case DIALOG_INV_SELECT:
	    {
	        return 1;
		}
		
		case DIALOG_OPEN_ITEM:
		{
			return 1;
		}
	    
		case DIALOG_CRAFT:
		{
			return 1;
		}
		
		case DIALOG_CRAFT_ACCEPT:
		{
		    return 1;
		}
		
		case DIALOG_USE_VIP_STONE:
		{
  			return 1;
		}
		
		case DIALOG_CRAFT_DO1:
		{
		    return 1;
		}
		
		case DIALOG_CRAFT_DO2:
		{
		    return 1;
		}
		
		case DIALOG_CRAFT_DO3:
		{
		    return 1;
		}
		
        case DIALOG_CRAFT_BERSERKER:
		{
  			return 1;
		}
		
		case DIALOG_CRAFT_DO4:
		{
		    return 1;
		}
		
	    case DIALOG_ATTACH_INDEX_SELECTION:
        {
            if(response)
            {
                if(IsPlayerAttachedObjectSlotUsed(playerid, listitem))
                {
                    ShowPlayerDialog(playerid, DIALOG_ATTACH_EDITREPLACE, DIALOG_STYLE_MSGBOX, \
                    "{FF0000}Attachment Modification", "Do you wish to edit the attachment in that slot, or delete it?", "Edit", "Delete");
                }
                else
                {
                    new string[4000+1], index = 0;
                    
                    if(Player[playerid][e_Days] < 299) index = 2;
                    if(Player[playerid][e_Days] < 249) index = 3;
                    if(Player[playerid][e_Days] < 149) index = 4;
                    if(Player[playerid][e_Days] < 99) index = 5;
                    if(Player[playerid][e_Days] < 49) index = 6;
                    if(Player[playerid][e_Days] < 24) index = 7;

                    for(new x = index; x< sizeof(AttachmentObjects); x++) format(string, sizeof(string), "%s%s\n", string, AttachmentObjects[x][attachname]);
                    for(new x = 0; x< 32; x++) if(Player[playerid][pNewAttachments][x] > -1) format(string, sizeof(string), "%s%s\n", string, newAttachement[Player[playerid][pNewAttachments][x]][attachname]);
                    
					ShowPlayerDialog(playerid, DIALOG_ATTACH_MODEL_SELECTION, DIALOG_STYLE_LIST,"{FF0000}Attachment Modification - Model Selection", string, "Select", "Cancel");
                    
				}
                SetPVarInt(playerid, "AttachmentIndexSel", listitem);
            }
            return 1;
        }
        
        case DIALOG_ATTACH_EDITREPLACE:
        {
            if(response) EditAttachedObject(playerid, GetPVarInt(playerid, "AttachmentIndexSel"));
            else
			{
				RemovePlayerAttachedObject(playerid, GetPVarInt(playerid, "AttachmentIndexSel"));
				Player[playerid][pAttID][0+(GetPVarInt(playerid, "AttachmentIndexSel")*2)] = 0;
			}
			DeletePVar(playerid, "AttachmentIndexSel");
            return 1;
        }
        
        case DIALOG_ATTACH_MODEL_SELECTION:
        {
            if(response)
            {
                if(GetPVarInt(playerid, "AttachmentUsed") == 1) EditAttachedObject(playerid, listitem);
                else
                {
                    new index = 0;
	                if(Player[playerid][e_Days] < 299) index = 2;
	                if(Player[playerid][e_Days] < 249) index = 3;
	                if(Player[playerid][e_Days] < 149) index = 4;
	                if(Player[playerid][e_Days] < 99) index = 5;
	                if(Player[playerid][e_Days] < 49) index = 6;
	                if(Player[playerid][e_Days] < 24) index = 7;
					
					if(listitem+index < sizeof(AttachmentObjects))
					{
						SetPVarInt(playerid, "AttachmentModelSel", AttachmentObjects[listitem+index][attachmodel]);
					}
					else
					{
					    new aid = abs(sizeof(AttachmentObjects) - (listitem+index));
					    new ID = Player[playerid][pNewAttachments][aid];
						SetPVarInt(playerid, "AttachmentModelSel", newAttachement[ID][attachmodel]);
					}
					
					new string[256+1];
                    for(new x;x<sizeof(AttachmentBones);x++)
                    {
                        format(string, sizeof(string), "%s%s\n", string, AttachmentBones[x]);
                    }
                    ShowPlayerDialog(playerid, DIALOG_ATTACH_BONE_SELECTION, DIALOG_STYLE_LIST, \
                    "{FF0000}Attachment Modification - Bone Selection", string, "Select", "Cancel");
                }
            }
            else DeletePVar(playerid, "AttachmentIndexSel");
            return 1;
        }
        
        case DIALOG_ATTACH_BONE_SELECTION:
        {
            if(response)
            {
                SetPlayerAttachedObject(playerid, GetPVarInt(playerid, "AttachmentIndexSel"), GetPVarInt(playerid, "AttachmentModelSel"), listitem + 1);
				EditAttachedObject(playerid, GetPVarInt(playerid, "AttachmentIndexSel"));
                SendClientMessage(playerid, 0xFFFFFFFF, "Hint: Use {FFFF00}~k~~PED_SPRINT~{FFFFFF} to look around.");
            }
            DeletePVar(playerid, "AttachmentIndexSel");
            DeletePVar(playerid, "AttachmentModelSel");
            return 1;
        }
        
        case DIALOG_PETS_ACTIONS:
        {
			return 1;
        }
        
        case DIALOG_PETS_ACTIONS_SELL:
        {
        	return 1;
        }
        
        case DIALOG_PETS:
        {
	        return 1;
        }
        
        case DIALOG_PET_NAME:
		{
			return 1;
		}
        
        case DIALOG_SECURITY:
        {
            return 1;
        }
        
        case DIALOG_GANG_FOREMAN:
        {
			return 1;
        }
        
        case DIALOG_GANG_TROPHY:
        {
            if(response)
	        {
	        
	        }
	        else return 1;
        }
        
        case DIALOG_WARNED:
        {
            if(response) cmd::rules(playerid);
			else cmd::rules(playerid);
            return 1;
        }
        
        case DIALOG_GANG_MEMBERS_LIST:
        {
            if(response)
            {
                if(GangPanelIDs[playerid][listitem] > 0)
                {
                    GangPanelIDSelected[playerid] = GangPanelIDs[playerid][listitem];
                    ShowPlayerDialog(playerid, DIALOG_GANG_MEMBERS_ACTION, DIALOG_STYLE_LIST, "{FF0000}Members List - Action", "{FF0000}Fire member", "Select", "Cancel");
                    return 1;
                }
            }
            return 1;
        }
        
        case DIALOG_GANG_MEMBERS_ACTION:
        {
            if(response)
            {
                switch(listitem)
                {
					case 0:
					{
						foreach(Player, i)
						{
							if(Player[i][pAccountID] == GangPanelIDSelected[playerid] && i != playerid)
							{
							    new str[128];
							    format(str, sizeof(str), "{FFFFFF}Do you really want to{ff3300} fire %s?", Player[i][UserName]);
								ShowPlayerDialog(playerid, DIALOG_GANG_MEMBERS_ACCEPTING, DIALOG_STYLE_MSGBOX, "{FF0000}WARNING", str, "Yes", "No");
						        return 1;
							}
						}
						
						if(GangPanelIDSelected[playerid] != Clan[Player[playerid][pClan]][g_OwnerID]) {
    						mysql_format(Base, query, sizeof(query), "SELECT `Name`,`ClanRank` FROM `users` WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", GangPanelIDSelected[playerid]);
							mysql_tquery(Base, query, "AcceptGangAction", "i", playerid);
						} else {
						    SendClientMessage(playerid, -1, "{FFFF00}>> The founder of the gang can decide when to leave");
						}
					    return 1;
					}
                }
            }
        }
        
        case DIALOG_GANG_MEMBERS_ACCEPTING:
        {
            if(response)
            {
				new s[25], bool:e;
	            foreach(Player, i)
				{
					if(Player[i][pAccountID] == GangPanelIDSelected[playerid])
					{
					    if(Player[i][pClanRank] <= 5)
					    {
						    Clan[Player[i][pClan]][g_MaxMembers]--;
						    format(s, sizeof(s), "%s", Player[i][UserName]);
							Player[i][pClanRank] = 0;
							Player[i][pClan] = 0;
							mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `ClanRank`='0',`Clan`='0' WHERE `ID` = '%d'", GangPanelIDSelected[playerid]);
							mysql_tquery(Base, query, "", "", "");
							e = true;
						}
						else
						{
						    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{FF0000}WARNING", "{ff3300}Not enough rights, contact Gang Manager (GM)", "Ok", "");
						    return 1;
						}
					}
				}
				if(e) { foreach(Player, i) if(Player[i][pClan] == Player[playerid][pClan]) SendClientMessageFormat(i, -1, "{C659B6}>> %s has been kicked from the gang by %s", s, Player[playerid][UserName]); }
				else
				{
				    if(strlen(GangPanelName[playerid]))
				    {
				        Clan[Player[playerid][pClan]][g_MaxMembers]--;
					    foreach(Player, j) if(Player[j][pClan] == Player[playerid][pClan]) SendClientMessageFormat(j, -1, "{C659B6}>> %s has been kicked from the gang by %s", GangPanelName[playerid], Player[playerid][UserName]);
					    mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `ClanRank`='0',`Clan`='0' WHERE `ID` = '%d'", GangPanelIDSelected[playerid]);
						mysql_tquery(Base, query, "", "", "");
						GangPanelName[playerid][0] = '\0';
						return 1;
					}
					else
					{
					    SendClientMessage(playerid, -1, "{FFFFFF}SYSTEM: Error.");
					    GangPanelName[playerid][0] = '\0';
					    return 1;
					}
				}
			}
			return 1;
        }
        
        case DIALOG_GANG_TYPE:
        {
            if(response)
            {
                if(strlen(inputtext) <= 0) {
                    cmd::gang(playerid, "panel");
                    SendClientMessage(playerid, -1, "{FFFF00}>> Type a value!");
					return 1;
				}
				
				new value = strval(inputtext), gid = Player[playerid][pClan];
				
				if(value < 0) {
				    cmd::gang(playerid, "panel");
            		SendClientMessage(playerid, -1, "{FFFF00}>> Invalid value!");
					return 1;
				}
				
                switch(GangAction[playerid])
				{
                    case 0:
					{
						if(value >= sizeof(rank_names)) {
						    cmd::gang(playerid, "panel");
                    		SendClientMessage(playerid, -1, "{FFFF00}>> Invalid rank value!");
							return 1;
						}
						Clan[gid][g_MinExp] = value;
						SendClientMessageFormat(playerid, -1, "{990000}>> MIN Rank Changed To %d!", value);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 1:
					{
						Clan[gid][g_MaxPayAmt] = min(value, 50000);
						SendClientMessageFormat(playerid, -1, "{990000}>> LIMIT per /gang pay Changed To %d!", Clan[gid][g_MaxPayAmt]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 2:
					{
						Clan[gid][g_MaxWarns] = min(value, 1000);
						SendClientMessageFormat(playerid, -1, "{990000}>> MAX warnings Changed To %d!", Clan[gid][g_MaxWarns]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 3:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToPromote] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Promote/Demote Changed To %d!", Clan[gid][g_RankToPromote]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 4:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToAccept] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Accept Requests Changed To %d!", Clan[gid][g_RankToAccept]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 5:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToWarn] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Warn Members Changed To %d!", Clan[gid][g_RankToWarn]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 6:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToBan] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Blacklist Members Changed To %d!", Clan[gid][g_RankToBan]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 7:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankGivePayDay] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Give PayDays Changed To %d!", Clan[gid][g_RankGivePayDay]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 8:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToEdit] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Edit Gang Changed To %d!", Clan[gid][g_RankToEdit]);
						cmd::gang(playerid, "panel");
						return 1;
					}
					case 9:
					{
					    if(value <= 0) value = 1;
						Clan[gid][g_RankToEditReq] = min(value, 6);
						SendClientMessageFormat(playerid, -1, "{990000}>> Rank That Can Use Gang Panel Changed To %d!", Clan[gid][g_RankToEditReq]);
						cmd::gang(playerid, "panel");
						return 1;
					}
                }
			}
            return 1;
        }
        
       	case DIALOG_GANG_SETTINGS:
	    {
	        if(response)
	        {
	            if(listitem > 0) {
		            GangAction[playerid] = listitem-1;
		            static const str_to_edit[][] =
		            {
		                {"MIN Rank To Join"},
		                {"LIMIT per /gang pay"},
		                {"MAX warnings"},
		                {"Rank That Can Promote/Demote"},
		                {"Rank That Can Accept Requests"},
		                {"Rank That Can Warn Members"},
		                {"Rank That Can Blacklist Members"},
		                {"Rank That Can Give PayDays"},
		                {"Rank That Can Edit Gang"},
		                {"Rank That Can Use Gang Panel"}
		            };
		            ShowPlayerDialog(playerid, DIALOG_GANG_TYPE, DIALOG_STYLE_INPUT, "Gang Panel", str_to_edit[listitem-1], "Confirm", "Close");
	    			return 1;
				} else {
				    Clan[Player[playerid][pClan]][g_isClosed] =! Clan[Player[playerid][pClan]][g_isClosed];
					if(Clan[Player[playerid][pClan]][g_isClosed]) SendClientMessage(playerid, -1, "{990000}>> Gang Closed"); else SendClientMessage(playerid, -1, "{990000}>> Gang Opened");
					cmd::gang(playerid, "panel");
					return 1;
				}
			}
			return 1;
		}
        
	    case DIALOG_SETTINGS:
	    {
	        if(response)
	        {
	            if(GetUnlockedSlot(Player[playerid][pSettings], listitem) == 1) SetUnlockedSlot(Player[playerid][pSettings], listitem, 0);
            	else SetUnlockedSlot(Player[playerid][pSettings], listitem, 1);
	    	}
	    	return 1;
		}
	    
	    case DIALOG_SHOP_ITEMS:
	    {
	        new stype = GetPVarInt(playerid, "stype");
			new inx = GetPVarInt(playerid, "inx");
			new pr = GetPVarInt(playerid, "pr");
			//new ct = GetPVarInt(playerid, "ct");
			new pl = GetPVarInt(playerid, "pl");
			new buyt = GetPVarInt(playerid, "buyt");
	        if(response)
			{
			    ClearPlayerShopInfo(playerid);
				SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase");
				return 1;
			}
			else
			{
				if(!IsPlayerConnected(pl) || pl >= MAX_PLAYERS || pl <= -1)
				{
					ClearPlayerShopInfo(playerid);
					return SendClientMessage(playerid, -1, "{FFFFFF}SYSTEM: Processing problem (Internal, retry again)") && 0 || 0;
				}

				switch(stype)
				{
				    case 2:
					{
					    new Float:vpr[] = {4.0, 7.0, 10.0};
					    if(gettime() > buyt || buyt <= 0)
						{
						    ClearPlayerShopInfo(playerid);
							return SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase") && SendClientMessage(playerid, -1, "{FFFFFF}SYSTEM: Processing problem (Time is up, retry command again)") && 0 || 0;
						}
						if(Player[pl][pBalance] < vpr[inx])
						{
						    ClearPlayerShopInfo(playerid);
							return SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase") && SendClientMessage(playerid, -1, "{FFFFFF}SYSTEM: Processing problem (No value)") && 0 || 0;
						}
						if(pr > Player[playerid][pXP])
						{
						    ClearPlayerShopInfo(playerid);
							return SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase") && SendClientMessage(playerid, -1, "{FFF000}>> You do not have enough exp for buying") && 0 || 0;
						}
						if((inx+1) <= -1)
						{
						    ClearPlayerShopInfo(playerid);
							return SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase") && SendClientMessage(playerid, -1, "{FFFFFF}SYSTEM: Processing problem (Invalid data)") && 0 || 0;
						}
						if(Player[playerid][pVip] >= (inx+1))
						{
						    ClearPlayerShopInfo(playerid);
							return SendClientMessage(pl, -1, "{FF0000}>> Player refused purchase") && SendClientMessage(playerid, -1, "{FFF000}>> Canceled for account's security reasons") && 0 || 0;
						}
						#if debug_mode == 0
						new __action[128], y, m, d, h, mts, s;
						new vsn[3][] = {"Bronze VIP", "Silver VIP", "Gold VIP"};
						TimestampToDate(gettime(), y, m, d, h, mts, s, 3);
						DiscordChannel = DCC_FindChannelById("655076938209165315");
						format(__action, sizeof __action, "```\n(%02dD/%02dM/%04dY) (%02d:%02d) %s(%d) bought %s from %s(%d) / Price: %d EXP\n```", d, m, y, h, mts, Player[playerid][RealName], Player[playerid][pAccountID], vsn[inx], Player[pl][RealName], Player[pl][pAccountID], pr);
						DCC_SendChannelMessageEx(DiscordChannel, __action);
						#endif
                        Player[playerid][pVipTime] = (gettime() + (86400*30));
                        Player[playerid][pVip] = (inx+1);
					    Player[playerid][pXP] -= pr;

						mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `VIP` = '%d',`VipTime` = '%d' WHERE `ID` = '%d'", Player[playerid][pVip], Player[playerid][pVipTime], Player[playerid][pAccountID]);
						mysql_tquery(Base, query, "", "", "");

						if(pr > 20) Player[pl][pXP] += (pr - floor(pr*TAXES));
	    				else Player[pl][pXP] += pr;

	    				Player[pl][pBalance] -= vpr[inx];
				    	new str[16];
						format(str, sizeof(str), "-%d EXP", pr);
		    			GameTextForPlayer(playerid, str, 3000, 1);
					    if(pr > 20) format(str, sizeof(str), "+%d EXP", (pr - floor(pr*TAXES)));
					    else format(str, sizeof(str), "+%d EXP", pr);
					    GameTextForPlayer(pl, str, 3000, 1);
					    ClearPlayerShopInfo(playerid);
					    return 1;
					}
				}
			}
			ClearPlayerShopInfo(playerid);
			return 1;
	    }
	    
	    case DIALOG_VALIENTINE_QUEST:
	    {
	        return 1;
	    }
	
	    case DIALOG_VALIENTINE_DAY:
	    {
    		return 1;
	    }
	    
	    case DIALOG_VALIENTINE_QUEST_2:
	    {
	        return 1;
	    }
	    
	    case DIALOG_CHAOS_BUY:
	    {
    		return 1;
	    }
	    
	    case DIALOG_CHAOS_BUY_OFCOURSE:
	    {
			return 1;
		}
	    case DIALOG_CHAOS:
	    {
			return 1;
	    }
	    
	    case DIALOG_DONATE_ACTIONS:
	    {
	        if(response)
	        {
        		SendClientMessage(playerid, -1, "{FFFFFF}PayPal: sveta81238@yandex.ru");

			    new str[1024];
				strcat(str, DonateInfo);
				strcat(str, "\n\n");

                strcat(str, "1 ZAP = 1 EURO\n\n");
                strcat(str, "PayPal: sveta81238@yandex.ru\n");
                strcat(str, "{FF0000}When buying, INDICATE THE {FFFFFF}ACCOUNT ID (/stats){FF0000}\nAfter your payment, you need to {FFFFFF}wait from 1 minute to 3 days\nOr contact Taxa / Kioko with the screen of your payment\n\n");

				ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "{BEBEBE}Donate", str, "Ok", "");
				return 1;
	        }
	        else
	        {
	            ShowVIPShop(playerid);
	        }
	        return 1;
	    }
	    
	    case DIALOG_SPECIALITES:
	    {
     		return 1;
	    }
	    
	    case DIALOG_SPECIALITES_LEVEL_UP:
	    {
	    	return 1;
	    }
	    
	    case DIALOG_SPECIALITES_CONFIRM:
	    {
	        return 1;
	    }

	    case DIALOG_UPGRADE_CHAR:
	    {
	        if(response) {
	            switch(listitem)
	            {
	                case 0,3:
	                {
	                    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Upgrade", "{FFFF00}[WARNING]:\n\tThis functionality is still in testing, so far you can see only a preview\n\n{FFFFFF}This component of equipment gives a chance to dodge enemy attacks\nThe higher the level, the higher the chance to dodge", "Ok", "");
						return 1;
					}
					case 1:
					{
					    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Upgrade", "{FFFF00}[WARNING]:\n\tThis functionality is still in testing, so far you can see only a preview\n\n{FFFFFF}This component of equipment gives damage absorption\nThe higher the level, the higher the absorption", "Ok", "");
						return 1;
					}
					case 2:
					{
					    ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Upgrade", "{FFFF00}[WARNING]:\n\tThis functionality is still in testing, so far you can see only a preview\n\n{FFFFFF}This component of equipment gives an increase in accuracy\nThe higher the level, the higher the accuracy of the weapon", "Ok", "");
						return 1;
					}
	            }
	        }
	        return 1;
	    }
	    
	    case DIALOG_UPGRADE_WEAPONS:
	    {
	        if(response) {
                ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "Upgrade", "{FFFF00}[WARNING]:\n\tThis functionality is still in testing, so far you can see only a preview\n\n{FFFFFF}As the level of the weapon increases, its accuracy and damage increase", "Ok", "");
				return 1;
	        }
	        return 1;
	    }
	    
	    case DIALOG_SELL_CHAR_CONFIRM:
	    {
     		return 1;
	    }
	    
	    case DIALOG_SELL_WEAPON_CONFIRM:
	    {
     		return 1;
	    }
	    
	    case DIALOG_SELL_WEAPON:
	    {
	        return 1;
	    }
	    
	    case DIALOG_SELL_CHAR:
	    {
     		return 1;
	    }
	    
	    case DIALOG_UPGRADE_WEAPONS_CONFIRM:
	    {
	        return 1;
	    }
	    
     	case DIALOG_UPGRADE_CHAR_CONFIRM:
	    {
	        return 1;
	    }
	    
	    case DIALOG_UPGRADE_CHAR_SELECT:
	    {
	        if(response)
			{
			    return 1;
			}
	        return 1;
	    }
	    
	    case DIALOG_UPGRADE_WEAPONS_SELECT:
	    {
			return 1;
	    }
	    
	    case DIALOG_BUY_FROM_MERCHANT:
	    {
			return 1;
	    }
	    
	    case DIALOG_ZOMBIE_SHOP:
	    {
	        if(response)
		    {
		        if(Player[playerid][pXP] < ShopPrices[listitem]) {
                    ShowExpError(playerid, ShopPrices[listitem]);
		            return 1;
		        }
		        
			    switch(listitem)
			    {
                    case 0:
					{
						if(!Player[playerid][AntiSeeker])
						{
							Player[playerid][AntiSeeker] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Anti-Seeker");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 1:
					{
						if(!Player[playerid][AntiFreeze])
						{
							Player[playerid][AntiFreeze] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Anti-Freezer");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 2:
					{
						if(!Player[playerid][AntiRadioctive])
						{
							Player[playerid][AntiRadioctive] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Armour");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							SetPlayerArmourAC(playerid, 50.0);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 3:
					{
						if(!Player[playerid][AntiBuring])
						{
							Player[playerid][AntiBuring] = true;
							Player[playerid][IsBurned][0] = 0;
    						Player[playerid][IsBurned][1] = 0;
							TextDrawHideForPlayer(playerid, Stun[playerid]);
							RemovePlayerAttachedObject(playerid, 9);
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Anti-Burning");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 4:
					{
						if(!Player[playerid][AntiLegBreaks])
						{
							Player[playerid][AntiLegBreaks] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Morphine");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 5:
					{
					    /*if(!Player[playerid][AntiScreamer])
						{
							Player[playerid][AntiScreamer] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Anti-Screamer");
							Player[playerid][pXP] -= ShopPrices[listitem];
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
                            return cmd::shop(playerid);
						}*/
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 6:
					{
					    if(!Player[playerid][AntiBlind])
						{
							Player[playerid][AntiBlind] = true;
							TextDrawHideForPlayer(playerid, Blind[playerid]);
							SetPlayerWeather(playerid, Map[m_Weather]);
							Player[playerid][Blidness] = 0;
							KillTimer(Player[playerid][BlidnessTimer]);
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Anti-Blind");
							Player[playerid][pXP] -= ShopPrices[listitem];
							AchievementAddProgress(playerid, ach_SHOP_TIMES);
							if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 7:
					{
					    if(!Player[playerid][Helmet])
						{
							Player[playerid][Helmet] = true;
							SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][159], "Helmet");
							Player[playerid][pXP] -= ShopPrices[listitem];
							SetPlayerAttachedObject(playerid, 9, 18936, 2, 0.129999,0.030000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);
                            if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
							return cmd::shop(playerid);
						}
						if(GetPlayerTeamEx(playerid) == TEAM_HUMAN) return ShowZombieShop(playerid);
						return cmd::shop(playerid);
					}
					case 8:
					{
					    if(Map[m_GangControll] <= 0 || Player[playerid][pPlayerKills] <= 0) return cmd::shop(playerid);
					    
					    Player[playerid][pPlayerKills]--;
					    setHumanColor(playerid);
					    GivePlayerXP(playerid, 50);
					    SendClientMessage(playerid, -1, "{FFF000}>> You traded your Conquest Reward for EXP (+50 EXP)");
					    return cmd::shop(playerid);
					}
					case 9:
					{
					    if(Map[m_GangControll] <= 0 || GetPlayerTeamEx(playerid) != TEAM_HUMAN) return cmd::shop(playerid);
					    
					    new gid = Map[m_GangControll];
					    new mygid = Player[playerid][pClan];
					    
					    if(mygid == Map[m_GangControll] || Clan[gid][g_AllianceWith][mygid] >= 2) {
					        new ar_price = max(15, 40 - Clan[gid][g_OwnedMaps]),
							ar_bonus = max(50, 50+(floor(float(min(Clan[gid][g_OwnedMaps], 15))*1.67)));

							if(Player[playerid][pXP] < ar_price) {
							    SendClientMessageFormat(playerid, -1, "{FFF000}>> Not enough exp, %d need", ar_price);
							    return cmd::shop(playerid);
							}
							
							Player[playerid][pXP] -= ar_price;
							SetPlayerArmourAC(playerid, ar_bonus);
					    }
                        return cmd::shop(playerid);
					}
					case 10:
					{
					    if(Map[m_GangControll] <= 0 || GetPlayerTeamEx(playerid) != TEAM_HUMAN) return cmd::shop(playerid);

					    new gid = Map[m_GangControll];
					    new mygid = Player[playerid][pClan];

					    if(mygid == Map[m_GangControll] || Clan[gid][g_AllianceWith][mygid] >= 2) {
					        new damage_price = 30 + (min(Clan[gid][g_OwnedMaps], 15)*12),
	            				Float:damage_deals = (30 + (min(Clan[gid][g_OwnedMaps], 15)*12))/30.0;
					        

							if(Player[playerid][pXP] < damage_price) {
							    SendClientMessageFormat(playerid, -1, "{FFF000}>> Not enough exp, %d need", damage_price);
							    return cmd::shop(playerid);
							}

							Player[playerid][pXP] -= damage_price;
							Player[playerid][pAdditionalDamage] = damage_deals;
					    }
                        return cmd::shop(playerid);
                        
					    
					}
			    }
			}
			return 1;
	    }
	    
		case DIALOG_VALIENTINE_SHOP:
		{
			return 1;
		}
	    
	    case DIALOG_AUCTION_EDIT:
		{
			return 1;
		}

		case DIALOG_AUCTION_DELETE:
		{
			return 1;
		}
	    
	    case DIALOG_AUCTION_START:
	    {
    		return 1;
	    }
	    
	    case DIALOG_VIP_SHOP:
		{
		    if(response)
		    {
		        switch(listitem)
		        {
			        case 0: return ShowVIPShop(playerid);
					case 1:
					{
					    if(Player[playerid][pBalance] >= float(BRONZE_VIP_PRICE))
						{
						    if(Player[playerid][pVip] <= 1)
						    {
							    Player[playerid][pVip] = 1;
								Player[playerid][pVipTime] = gettime() + (86400*30);
								Player[playerid][pBalance] -= float(BRONZE_VIP_PRICE);
								SendClientMessage(playerid, -1, "{FFF000}>> The purchase was successful!");
								SendClientMessage(playerid, -1, "{FFF000}>> You are given Bronze VIP status!");
                                #if debug_mode == 0
							 	new __action[128], y, m, d, h, i, s;
								TimestampToDate(gettime(), y, m, d, h, i, s, 3);
								DiscordChannel = DCC_FindChannelById("655076938209165315");
								format(__action, sizeof __action, "```\n(%02dD/%02dM/%04dY) (%02d:%02d) %s(%d) bought a Bronze VIP (30 days)```", d, m, y, h, s, Player[playerid][UserName], Player[playerid][pAccountID]);
								DCC_SendChannelMessageEx(DiscordChannel, __action);
								#endif
								return 1;
							}
							else
							{
							    SendClientMessage(playerid, -1, "{FFF000}>> Your VIP status is better than this!");
							    return 1;
							}
						}
						else
						{
						    SendClientMessage(playerid, -1, "{FFF000}>> You do not have enough of this currency");
						    return 1;
						}
					}
					case 2:
					{
					    if(Player[playerid][pBalance] >= float(SILVER_VIP_PRICE))
						{
						    if(Player[playerid][pVip] <= 2)
						    {
							    Player[playerid][pVip] = 2;
								Player[playerid][pVipTime] = gettime() + (86400*30);
								Player[playerid][pBalance] -= float(SILVER_VIP_PRICE);
								SendClientMessage(playerid, -1, "{FFF000}>> The purchase was successful!");
								SendClientMessage(playerid, -1, "{FFF000}>> You are given Silver VIP status!");
                                #if debug_mode == 0
								new __action[128], y, m, d, h, i, s;
								TimestampToDate(gettime(), y, m, d, h, i, s, 3);
								DiscordChannel = DCC_FindChannelById("655076938209165315");
								format(__action, sizeof __action, "```\n(%02dD/%02dM/%04dY) (%02d:%02d) %s(%d) bought a Silver VIP (30 days)```", d, m, y, h, s, Player[playerid][UserName], Player[playerid][pAccountID]);
								DCC_SendChannelMessageEx(DiscordChannel, __action);
								#endif
								return 1;
							}
							else
							{
							    SendClientMessage(playerid, -1, "{FFF000}>> Your VIP status is better than this!");
							    return 1;
							}
						}
						else
						{
						    SendClientMessage(playerid, -1, "{FFF000}>> You do not have enough of this currency");
						    return 1;
						}
					}
					case 3:
					{
					    if(Player[playerid][pBalance] >= float(GOLD_VIP_PRICE))
						{
						    if(Player[playerid][pVip] <= 3)
						    {
							    Player[playerid][pVip] = 3;
								Player[playerid][pVipTime] = gettime() + (86400*30);
								Player[playerid][pBalance] -= float(GOLD_VIP_PRICE);
								SendClientMessage(playerid, -1, "{FFF000}>> The purchase was successful!");
								SendClientMessage(playerid, -1, "{FFF000}>> You are given Gold VIP status!");
                                #if debug_mode == 0
								new __action[128], y, m, d, h, i, s;
								TimestampToDate(gettime(), y, m, d, h, i, s, 3);
								DiscordChannel = DCC_FindChannelById("655076938209165315");
								format(__action, sizeof __action, "```\n(%02dD/%02dM/%04dY) (%02d:%02d) %s(%d) bought a Gold VIP (30 days)```", d, m, y, h, s, Player[playerid][UserName], Player[playerid][pAccountID]);
								DCC_SendChannelMessageEx(DiscordChannel, __action);
								#endif
								return 1;
							}
							else
							{
							    SendClientMessage(playerid, -1, "{FFF000}>> Your VIP status is better than this!");
							    return 1;
							}
						}
						else
						{
						    SendClientMessage(playerid, -1, "{FFF000}>> You do not have enough of this currency");
						    return 1;
						}
					}
	    		}
			}
		    return 1;
		}

		case DIALOG_SHOP:
	    {
  			return 1;
		}
		
		case DIALOG_REGISTER_LANGUAGE:
		{
		    if(response)
		    {
		        Player[playerid][pLang] = listitem;
		        new Head[48], mess[410];
				format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 1);
				strcat(mess, ServerRegisters[Player[playerid][pLang]][1]);
				strcat(mess, ServerRegisters[Player[playerid][pLang]][2]);
				ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_0, DIALOG_STYLE_INPUT, Head, mess, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
				new playerIP[16];
				GetPlayerIp(playerid, playerIP, sizeof(playerIP));
				strmid(Player[playerid][pIP], playerIP, false, 16, 16);
		    }
		    else
		    {
		        foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Unregistered]", Player[playerid][UserName]);
				PlayerKick(playerid);
		    }
		    return 1;
		}
		
 	    case DIALOG_REGISTER_STEP_0:
		{
		    if(response)
		    {
		    	if(strlen(inputtext) < 6 || strlen(inputtext) > 64)
		    	{
	    			new Head[48],str[410];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 1);
					strcat(str, ServerRegisters[Player[playerid][pLang]][1]);
					strcat(str, ServerRegisters[Player[playerid][pLang]][2]);
					ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_0, DIALOG_STYLE_INPUT, Head, str, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
					return 1;
				}
				
				if(!strcmp(inputtext, "password", true) || !strcmp(inputtext, "qwerty", true) || !strcmp(inputtext, "123456", true) || !strcmp(inputtext, "000000", true) || !strcmp(inputtext, "111111", true) || !strcmp(inputtext, "666666", true))
				{
					new Head[48],str[410];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 1);
					strcat(str, ServerRegisters[Player[playerid][pLang]][3]);
					strcat(str, ServerRegisters[Player[playerid][pLang]][1]);
					strcat(str, ServerRegisters[Player[playerid][pLang]][2]);
					ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_0, DIALOG_STYLE_INPUT, Head, str, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
					return 1;
				}
				
				new IP[16];
				GetPlayerIp(playerid, IP, 16);
				mysql_format(Base, query, sizeof(query), "INSERT INTO `users` (`Kills`,`Killstreak`,`RoundWins`,`DuelWins`,`DuelLoses`,`VIP`, `Admin`,`Rank`,`EXP`,`Clan`,`ClanRank`,`Password`,`Salt`,`Email`,`Name`,`Language`,`Secret`,`ZombieList`,`HumanList`,`IP`,`build`) VALUES (0,0,0,0,0,0,0,0,0,0,0,'%e','%e','%e','%e',0,'%e','0,0','0,0','%e','"SERVER_BUILD"')",inputtext," "," ",Player[playerid][UserName], " ", IP);
				mysql_tquery(Base, query, "CreateNewUserInDB", "is", playerid, IP);
				
				SignCreate(playerid);
		     	playerOnline++;
		     	configureClass(playerid);
				setupZombie(playerid);
				SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
				SpawnPlayer(playerid);
				Registered{playerid} = true;
				Player[playerid][pLogged] = true;
				cmd::help(playerid);
				
				//strmid(Player[playerid][pPass], inputtext, 0, strlen(inputtext), strlen(inputtext)+1);
				
				//new Head[48];
				//format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
				//ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
			}
			else
			{
			    foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Unregistered]", Player[playerid][UserName]);
				PlayerKick(playerid);
			}
		}
		
		case DIALOG_CREATE_MAIL:
		{
		    if(response)
		    {
		        if(strlen(Player[playerid][pEmail]) >= 1) return 1;
		        if(strlen(inputtext) <= 0)
		        {
          			ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account", "Ok", "Back");
             		return 1;
		        }
		        if(strfind(inputtext, "@") >= 3)
				{
				    mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Email` = '%e' AND `build`='"SERVER_BUILD"'", inputtext);
        			mysql_tquery(Base, query, "OnSetPlayerEmail", "is", playerid, inputtext);
					return 1;
				}
				else
				{
				    ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account", "Ok", "Back");
             		return 1;
				}
		    }
			return 1;
		}
		
		case DIALOG_REGISTER_STEP_1:
		{
		    if(response)
		    {
		        if(strlen(inputtext) <= 0)
		        {
                    new Head[48];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
					ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}
				if(strfind(inputtext, "@") >= 3 && strfind(inputtext, ".com") >= 4 || strfind(inputtext, ".ru") >= 4)
				{
				    mysql_format(Base, query, sizeof(query), "SELECT * FROM `users` WHERE `Email` = '%e' AND `build`='"SERVER_BUILD"'", inputtext);
        			mysql_tquery(Base, query, "OnCheckForRegisterOrRecovery", "is", playerid, inputtext);
					return 1;
				}
				else
				{
				    new Head[48];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
					ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}
		    }
		    else
		    {
		    	new Head[48],str[410];
				format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 1);
				strcat(str, ServerRegisters[Player[playerid][pLang]][1]);
				strcat(str, ServerRegisters[Player[playerid][pLang]][2]);
				ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_0, DIALOG_STYLE_INPUT, Head, str, serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][5]);
                return 1;
			}
		}
		
		case DIALOG_REGISTER_STEP_3:
		{
		    if(response)
		    {
		        if(strlen(inputtext) <= 0)
		        {
		            new Head[48];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 4);
	    			ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_3, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][11], ServerRegisters[Player[playerid][pLang]][10], ServerRegisters[Player[playerid][pLang]][12]);
					return 1;
				}
				mysql_format(Base, query, sizeof(query), "SELECT promo.*, u.Name FROM promo JOIN users u WHERE u.ID = promo.ID AND `code` = '%e'", inputtext);
				mysql_tquery(Base, query, "OnCheckForPromocode", "i", playerid);
			}
			else
			{
			    SignCreate(playerid);
		     	playerOnline++;
		     	configureClass(playerid);
				setupZombie(playerid);
				SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
				SpawnPlayer(playerid);
				Registered{playerid} = true;
				Player[playerid][pLogged] = true;
				cmd::help(playerid);
			}
			return 1;
		}
		
		case DIALOG_REGISTER_STEP_2:
		{
		    if(response)
		    {
		        if(strlen(inputtext) <= 0)
		        {
		            new Head[48];
					format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 3);
	    			ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_2, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][5], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}

				new IP[16];
				GetPlayerIp(playerid, IP, 16);
				mysql_format(Base, query, sizeof(query), "INSERT INTO `users` (`Kills`,`Killstreak`,`RoundWins`,`DuelWins`,`DuelLoses`,`VIP`, `Admin`,`Rank`,`EXP`,`Clan`,`ClanRank`,`Password`,`Salt`,`Email`,`Name`,`Language`,`Secret`,`ZombieList`,`HumanList`,`IP`,`build`) VALUES (0,0,0,0,0,0,0,0,0,0,0,'%e','%e','%e','%e',0,'%e','0,0','0,0','%e','"SERVER_BUILD"')",Player[playerid][pPass],Player[playerid][pSalt],Player[playerid][pEmail],Player[playerid][UserName], inputtext, IP);
				mysql_tquery(Base, query, "CreateNewUserInDB", "is", playerid, IP);
				return 1;
		    }
		    else
		    {
		        new Head[48];
				format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
				ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
				return 1;
		    }
		}
		
		case DIALOG_RESTORE_ACCESS_0:
		{
		    if(response)
		    {
                if(strlen(inputtext) <= 0)
		        {
                	format(scs[0], 128, serverLang[Player[playerid][pLang]][53], 1);
 					format(scs[1], 128, serverLang[Player[playerid][pLang]][54], NM[playerid]);
  					ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_0, DIALOG_STYLE_INPUT, scs[0], scs[1], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}
				
		        //SHA256_PassHash(inputtext, Player[playerid][pSalt], hash, sizeof(hash));
		        if(!strcmp(inputtext, Player[playerid][pKey]))
		        {
		            format(scs[0], 128, serverLang[Player[playerid][pLang]][53], 2);
		            ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_1, DIALOG_STYLE_INPUT, scs[0], serverLang[Player[playerid][pLang]][57], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][56]);
					return 1;
		        }
		        else
                {
		        	attemptsToLog[playerid]--;
		        	if(attemptsToLog[playerid] > 0)
		        	{
		        	    format(scs[0], 128, serverLang[Player[playerid][pLang]][53], 1);
     					format(scs[1], 128, serverLang[Player[playerid][pLang]][54], NM[playerid]);
	    				ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_0, DIALOG_STYLE_INPUT, scs[0], scs[1], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
						return 1;
					}
					if(attemptsToLog[playerid] <= 0)
	    			{
		        		foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][46], Player[playerid][UserName]);
					    PlayerKick(playerid);
					}
				}
		    }
		    else
		    {
     			new Head[48];
				format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
				ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
				return 1;
		    }
		}
		
		case DIALOG_RESTORE_ACCESS_1:
		{
		    if(response)
		    {
		        if(strlen(inputtext) < 6 || strlen(inputtext) > 64)
		        {
		        	format(scs[0], 128, serverLang[Player[playerid][pLang]][53], 2);
		            ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_1, DIALOG_STYLE_INPUT, scs[0], serverLang[Player[playerid][pLang]][57], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}
				if(!strcmp(inputtext, "password", true) || !strcmp(inputtext, "qwerty", true) || !strcmp(inputtext, "123456", true) || !strcmp(inputtext, "000000", true) || !strcmp(inputtext, "111111", true) || !strcmp(inputtext, "666666", true))
				{
				    format(scs[0], 128, serverLang[Player[playerid][pLang]][53], 2);
		            ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_1, DIALOG_STYLE_INPUT, scs[0], serverLang[Player[playerid][pLang]][57], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][56]);
					return 1;
				}
				//SHA256_PassHash(inputtext, Player[playerid][pSalt], hash, sizeof(hash));
				mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Password` = '%e' WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", inputtext, NM[playerid]);
				SetPlayerName(playerid, NM[playerid]);
				GetPlayerName(playerid, Player[playerid][RealName], 25);
				GetPlayerName(playerid, Player[playerid][UserName], 25);
			
    			mysql_tquery(Base, query, "", "");
    			Player[playerid][pLogged] = true;
    			KillTimer(RegisterTimer[playerid]);
   			 	SignCreate(playerid);
   			 	
   			 	playerOnline++;
				setupZombie(playerid);
				SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
				SpawnPlayer(playerid);
		    }
		    else
		    {
		        new Head[48];
				format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 2);
				ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_1, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
				return 1;
			}
		}
		
		case DIALOG_LOGIN:
		{
			if(response)
		    {
		        new dlg[264];
		        if(strlen(inputtext) <= 0)
		        {
		            if(Player[playerid][pLang] == 1)
		            {
			            format(dlg, 264, ServerRegisters[Player[playerid][pLang]][8], attemptsToLog[playerid]);
			            ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][7], dlg, ServerRegisters[Player[playerid][pLang]][9], serverLang[Player[playerid][pLang]][5]);
					}
					else
					{
					    format(dlg, sizeof(dlg), ServerRegisters[Player[playerid][pLang]][7], attemptsToLog[playerid]);
						ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][6], dlg, ServerRegisters[Player[playerid][pLang]][9], serverLang[Player[playerid][pLang]][5]);
					}
					return 1;
				}
				
		        if(!strcmp(inputtext, Player[playerid][pPass]))
                {
                    SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][45]);
    				Player[playerid][pLogged] = true;
					KillTimer(RegisterTimer[playerid]);
				 	SignCreate(playerid);
				 	
				 	playerOnline++;
				 	Registered{playerid} = true;
				 	
				 	new ip[16];
				 	GetPlayerIp(playerid, ip, sizeof(ip));
				 	mysql_format(Base, query, sizeof(query), "DELETE FROM `autolog` WHERE `Name` = '%e' OR `IP` = '%e' AND `build`='"SERVER_BUILD"'", Player[playerid][UserName], ip);
			 		mysql_tquery(Base, query, "", "");
				    GetPlayerIp(playerid, ip, sizeof(ip));
			        mysql_format(Base, query, sizeof(query), "INSERT INTO `autolog` (`IP`,`time`,`Name`,`build`) VALUES ('%e',NOW(),'%e','"SERVER_BUILD"')", ip, Player[playerid][UserName]);
			 		mysql_tquery(Base, query, "", "", "");
			 		
					mysql_format(Base, query, sizeof(query), "SELECT * FROM `paydays` WHERE `acc` = '%d' AND `build`='"SERVER_BUILD"'", Player[playerid][pAccountID]);
					mysql_tquery(Base, query, "CheckForEXP", "i", playerid);
					
					mysql_format(Base, query, sizeof(query), "SELECT * FROM `userinfo` WHERE `id` = '%d'", Player[playerid][pAccountID]);
					mysql_tquery(Base, query, "CheckForRegs", "i", playerid);
					
					/*if(UserTankInWarState[playerid] <= 0) // Event*/
					
					//cmd::help(playerid);
					return 1;
                }
                else
                {
		        	attemptsToLog[playerid]--;
		        	if(attemptsToLog[playerid] > 0)
		        	{
		        	    if(Player[playerid][pLang] == 1)
		            	{
			        	    format(dlg, 264, ServerRegisters[Player[playerid][pLang]][8], attemptsToLog[playerid]);
	                    	ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][7], dlg, ServerRegisters[Player[playerid][pLang]][9], serverLang[Player[playerid][pLang]][5]);
							return 1;
						}
						else
						{
						    format(dlg, 264, ServerRegisters[Player[playerid][pLang]][7], attemptsToLog[playerid]);
	                    	ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, ServerRegisters[Player[playerid][pLang]][6], dlg, ServerRegisters[Player[playerid][pLang]][9], serverLang[Player[playerid][pLang]][5]);
							return 1;
						}
					}
					if(attemptsToLog[playerid] <= 0)
	    			{
	    			    new g[41], y, m, d, h, i, s, ip[16];
						gpci(playerid, g, sizeof(g));
						GetPlayerIp(playerid, ip, sizeof(ip));
			  			TimestampToDate(gettime(), y, m, d, h, i, s, 3);
			            mysql_format(Base, query, sizeof(query), "INSERT INTO `security` (`acc`,`ip`,`date`,`reg`,`sign`,`type`) VALUES ('%d','%e','%d','%e','%e', '3')", Player[playerid][pAccountID], ip, gettime(), Player[playerid][pIP], g);
						mysql_tquery(Base, query, "", "", "");
                        #if debug_mode == 0
                        new mess[164];
						DiscordChannel = DCC_FindChannelById("614265642966843404");
			    		format(mess, sizeof mess, "%04d-%02d-%02d %02d:%02d:%02d Login Error: %s(%d) failed to log in (REG: %s | CUR: %s)", y, d, m, h, i, s, Player[playerid][UserName], Player[playerid][pAccountID], Player[playerid][pIP], ip);
						DCC_SendChannelMessageEx(DiscordChannel, mess);
				        #endif
		        		foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[i][pLang]][46], Player[playerid][UserName]);
						PlayerKick(playerid);
						return 1;
					}
				}
		    }
			else
			{
			    foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: Not logged in]", Player[playerid][UserName]);
				PlayerKick(playerid);
			}
			return 1;
		}
		
		case DIALOG_GAME_HELP_GANGS:
		{
            return 1;
		}
		
		case DIALOG_GAME_HELP_GPROCESS:
		{
      		return 1;
		}
		
		case DIALOG_GAME_HELP:
		{
		    return 1;
		}
		
		case DIALOG_UPGRADE_SKILLS:
		{
			return 1;
		}
		
	    case DIALOG_UPGRADE_SKILL:
	    {
			return 1;
		}
		
	 	case DIALOG_CLASSES:
 	    {
 	        new cls[4096], tmps[128];
 	        if(response)
 	        {
				switch(listitem)
				{
			    	case 0:
					{
					    for( new i = 0; i < sizeof(svrCLHXP); i++ ) // sizeof(svrCLHRK)
						{
			   				if(i % 2 == 0)
			 				{
			 				    if(Player[playerid][pXP] < svrCLHXP[i])
				 		        {
				 		            format(tmps, 128, "{EC3013}%s{FFFFFF} - %s -{FF0000} %d %s\n", humanClassesListNames[Player[playerid][pLang]][i], svrCLH[Player[playerid][pLang]][i], svrCLHXP[i], serverLang[Player[playerid][pLang]][64]);
									strcat(cls, tmps);
				 		        }
				 		        else
				 		        {
 		            				format(tmps, 128, "{009900}%s{FFFFFF} - %s\n", humanClassesListNames[Player[playerid][pLang]][i], svrCLH[Player[playerid][pLang]][i]);
									strcat(cls, tmps);
				 		        }
			 				}
			 				else
			 				{
                                if(Player[playerid][pXP] < svrCLHXP[i])
				 		        {
				 		            format(tmps, 128, "{FF4D55}%s{A7A5A5} - %s -{FF0000} %d %s\n", humanClassesListNames[Player[playerid][pLang]][i], svrCLH[Player[playerid][pLang]][i], svrCLHXP[i], serverLang[Player[playerid][pLang]][64]);
									strcat(cls, tmps);
				 		        }
				 		        else
				 		        {
 		            				format(tmps, 128, "{75F0B0}%s{A7A5A5} - %s\n", humanClassesListNames[Player[playerid][pLang]][i], svrCLH[Player[playerid][pLang]][i]);
									strcat(cls, tmps);
								}
							}
						}
						for( new i = 0; i < sizeof(humanVIPClXP); i++ )
						{
						    format(tmps, 128, "{faf06d}%s - %s - VIP\n", humanVIPCl[Player[playerid][pLang]][i], humanVIPClAb[Player[playerid][pLang]][i]);
							strcat(cls, tmps);
						}
						ShowPlayerDialog(playerid, DIALOG_HUMAN_CLASSES, DIALOG_STYLE_LIST, serverLang[Player[playerid][pLang]][7], cls, serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);
						return 1;
					}
					
					case 1:
					{
					    for( new i = 0; i < sizeof(svrCLZXP); i++ )
						{
			   				if(i % 2 == 0)
			 				{
			 				    if(Player[playerid][pXP] < svrCLZXP[i])
				 		        {
				 		            format(tmps, 128, "{EC3013}%s{FFFFFF} - %s -{FF0000} %d %s\n", zombieClassesListNames[Player[playerid][pLang]][i], svrCLZ[Player[playerid][pLang]][i], svrCLZXP[i], serverLang[Player[playerid][pLang]][64]);
									strcat(cls, tmps);
				 		        }
				 		        else
				 		        {
 		            				format(tmps, 128, "{009900}%s{FFFFFF} - %s\n", zombieClassesListNames[Player[playerid][pLang]][i], svrCLZ[Player[playerid][pLang]][i]);
									strcat(cls, tmps);
				 		        }
			 				}
			 				else
			 				{
			 				    if(Player[playerid][pXP] < svrCLZXP[i])
				 		        {
				 		            format(tmps, 128, "{FF4D55}%s{A7A5A5} - %s -{FF0000} %d %s\n", zombieClassesListNames[Player[playerid][pLang]][i], svrCLZ[Player[playerid][pLang]][i], svrCLZXP[i], serverLang[Player[playerid][pLang]][64]);
									strcat(cls, tmps);
				 		        }
				 		        else
				 		        {
 		            				format(tmps, 128, "{75F0B0}%s{A7A5A5} - %s\n", zombieClassesListNames[Player[playerid][pLang]][i], svrCLZ[Player[playerid][pLang]][i]);
									strcat(cls, tmps);
				 		        }
							}
						}
						for( new i = 0; i < sizeof(zombieVIPClXP); i++ )
						{
						    format(tmps, 128, "{faf06d}%s - %s - VIP\n", zombieVIPCl[Player[playerid][pLang]][i], zombieVIPClAb[Player[playerid][pLang]][i]);
							strcat(cls, tmps);
						}
						ShowPlayerDialog(playerid, DIALOG_ZOMBIE_CLASSES, DIALOG_STYLE_LIST, serverLang[Player[playerid][pLang]][7], cls, serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][5]);
						return 1;
					}
				}
  			}
  			else
  			{

			}
 	    }
 	    case DIALOG_ZOMBIE_CLASSES:
	 	{
	 		if(response)
		 	{
		 	    if(listitem < sizeof(svrCLZXP))
		 	    {
			 		if(Player[playerid][pXP] >= svrCLZXP[listitem] || gettime() < PlayerClassUnlocked[playerid][TEAM_ZOMBIE][listitem])
			 		{
			 		    NewbieChangedClass[playerid] = true;
				 		setPlayerClass(playerid, listitem, TEAM_ZOMBIE);
			 		}
			 		else ShowExpError(playerid, svrCLZXP[listitem]);
				}
				else
				{
					if(Player[playerid][pVip] >= zombieVIPClXP[listitem-sizeof(svrCLZXP)])
					{
					    NewbieChangedClass[playerid] = true;
				    	setPlayerClass(playerid, zombieVipClIDs[listitem-sizeof(svrCLZXP)], TEAM_ZOMBIE);
					}
					else ShowVipError(playerid, zombieVIPClXP[listitem-sizeof(svrCLZXP)]);
				}
			}
			if(!response) cmd::class(playerid,"");
		}
		
		case DIALOG_HUMAN_CLASSES:
		{
			if(response)
			{
			    if(listitem < sizeof(svrCLHXP))
			    {
					if(Player[playerid][pXP] >= svrCLHXP[listitem] || gettime() < PlayerClassUnlocked[playerid][TEAM_HUMAN][listitem])
					{
					    NewbieChangedClass[playerid] = true;
					    if(!Player[playerid][pWasGangAffected]) setPlayerClass(playerid, listitem, TEAM_HUMAN);
		 		    	else SendClientMessage(playerid, -1, "{FFF000}>> You are too wounded to change class");
					}
					else ShowExpError(playerid, svrCLHXP[listitem]);
				}
				else
				{
				    if(Player[playerid][pVip] >= humanVIPClXP[listitem-sizeof(svrCLHXP)])
					{
					    NewbieChangedClass[playerid] = true;
				    	if(!Player[playerid][pWasGangAffected]) setPlayerClass(playerid, humanVipClIDs[listitem-sizeof(svrCLHXP)], TEAM_HUMAN);
                        else SendClientMessage(playerid, -1, "{FFF000}>> You are too wounded to change class");
					}
					else ShowVipError(playerid, humanVIPClXP[listitem-sizeof(svrCLHXP)]);
				}
			}
            if(!response) cmd::class(playerid,"");
		}
		case DIALOG_LANGUAGE:
 	    {
 	        if(response) Player[playerid][pLang] = listitem,SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][6]);
 	    }
 	}
	return 1;
}

fun OnPlayerClickPlayer(playerid, clickedplayerid, source)
{
	if(!Player[playerid][pLogged]) return 0;
	if(Player[playerid][pAdmin] < 1)
	{
	    new s[4];
	    format(s, sizeof(s), "%d", clickedplayerid);
		cmd::stats(playerid, s);
	}
	else
	{
		if(!Player[playerid][aDuty]) return 0;
		if(clickedplayerid == playerid)
		{
		    cmd::specoff(playerid);
		    return 1;
		}
		if(GetPlayerState(clickedplayerid) == PLAYER_STATE_SPECTATING)
		{
		    SendClientMessage(playerid, -1, " /spec (id)");
		    return 1;
		}
		SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
		TogglePlayerSpectating(playerid, 1);
		SetPlayerVirtualWorld(playerid,GetPlayerVirtualWorld(clickedplayerid));
		SetPlayerInterior(playerid,GetPlayerInterior(clickedplayerid));
		PlayerSpectatePlayer(playerid,clickedplayerid);
		IsSpecing[playerid] = true;
		IsBeingSpeced[clickedplayerid] = true;
		spectatorid[playerid] = clickedplayerid;
		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][116], Player[playerid][UserName], Player[clickedplayerid][UserName], clickedplayerid);
	 	SendClientMessage(playerid, -1, "/specoff");
	}
	return 1;
}

fun ShowExpError(const playerid, const exp)
{
	SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][14], exp);
	return 1;
}

fun ShowVipError(const playerid, const exp)
{
	SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][151], exp);
	return 1;
}

stock setPlayerClass(const playerid, classid, const cteam)
{
    /*if(classid == FIREMANIAC && cteam == TEAM_HUMAN && GetWeekDay() == GANG_WARS_DAY)
 	{
	 	classid = CIVILIAN;
	 	SendClientMessage(playerid, -1, "{FF0000}>> You cannot select this class, select it tomorrow");
	}*/

	if(cteam == TEAM_HUMAN) Player[playerid][pClass][TEAM_HUMAN+1] = classid;
	else Player[playerid][pClass][TEAM_ZOMBIE+2] = classid;
	
	if(!Player[playerid][aDuty] && Time >= 285)
	{
		if(GetPlayerTeamEx(playerid) == cteam)
		{
		    //if(classid != LEATHERFACE && Player[playerid][LeatherFace][0]) Player[playerid][LeatherFace][0]=0;
		    configureClass(playerid);
			setClass(playerid);
			SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][23]);
		}
		else SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][24]);
	}
	else SendClientMessage(playerid, -1, serverLang[Player[playerid][pLang]][24]);
}

stock getPlayerClass(const playerid, const cteam) return Player[playerid][pClass][(cteam*2)+1];
stock configureClass(const playerid)
{
	Player[playerid][pClass][TEAM_HUMAN] = Player[playerid][pClass][TEAM_HUMAN+1];
    Player[playerid][pClass][TEAM_ZOMBIE+1] = Player[playerid][pClass][TEAM_ZOMBIE+2];
}
stock setClassStartUp(const playerid) { Player[playerid][pClass][TEAM_HUMAN+1] = CIVILIAN; Player[playerid][pClass][TEAM_ZOMBIE+1] = STANDARDZOMBIE; }

fun setupHuman(playerid)
{
    if(Player[playerid][pInGangMatch]) return 1;
	setHumanColor(playerid);
	SetPlayerTeamEx(playerid, TEAM_HUMAN);
    SetPlayerHealthAC(playerid, 100.0);
    return 1;
}

fun setupZombie(playerid)
{
    if(Player[playerid][pInGangMatch]) return 1;
	SetPlayerColor(playerid, COLOR_ZOMBIE);
	SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	SetPlayerHealthAC(playerid, 100.0);
	if(Player[playerid][pClass][TEAM_ZOMBIE+1] == TANKZOMBIE) SetPlayerHealthAC(playerid, 350.0);
    return 1;
}

fun StartupZombie(playerid)
{
    SetPlayerColor(playerid, COLOR_ZOMBIE);
	SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	SetPlayerHealthAC(playerid, 100.0);
	if(Player[playerid][pClass][TEAM_ZOMBIE+1] == TANKZOMBIE) SetPlayerHealthAC(playerid, 350.0);
	
	SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
	SpawnPlayer(playerid);
	SendClientMessage(playerid, -1, "{FFF000}>> You must constantly move in order to have a chance to be human in the next round!");
}

fun Float:GetDistanceBetweenPlayers(p1,p2)
{
    new Float:x1,Float:y1,Float:z1,Float:x2,Float:y2,Float:z2;
    if(!IsPlayerConnected(p1) || !IsPlayerConnected(p2)) {
        return -1.00;
    }
    GetPlayerPos(p1,x1,y1,z1);
    GetPlayerPos(p2,x2,y2,z2);
    return floatsqroot(floatpower(floatabs(floatsub(x2,x1)),2)+floatpower(floatabs(floatsub(y2,y1)),2)+floatpower(floatabs(floatsub(z2,z1)),2));
}

fun SeekerHunting(playerid, type)
{
	if(Time >= 275)
	{
		switch(Player[playerid][pLang])
	    {
			case 0: GameTextForPlayer(playerid, "~w~Too early", 1000, 5);
	        case 1: GameTextForPlayer(playerid,RusToGame("~w~РАНО"), 1000, 5);
	        case 2: GameTextForPlayer(playerid,"~w~Demasiado temprano", 1000, 5);
		}
		return 0;
	}
	
	new victimid = -1, LastID = -1;
	new Float:MyPos[3];
	GetPlayerPos(playerid, MyPos[0], MyPos[1], MyPos[2]);
	
	foreach(Player, i)
	{
    	if(IsPlayerInRangeOfPoint(i, 4096.0, MyPos[0], MyPos[1], MyPos[2]) && GetPlayerTeamEx(i) == TEAM_HUMAN)
    	{
    	    LastID = i;
            if(random(3) == 0 && !ItsNewbie(i) && !Player[i][AntiSeeker] && !IsPlayerOnDuel[i] && Player[i][Jailed] <= 0 && Player[i][pLogged] && Player[i][eventMember] <= -1)
			{
				victimid = i;
            	break;
			}
    	}
	}
	
	if(victimid == -1) victimid = LastID;
	
	if(victimid > -1 && !Player[victimid][AntiSeeker] && !ItsNewbie(victimid) && !IsPlayerOnDuel[victimid] && Player[victimid][Jailed] <= 0 && Player[victimid][pLogged] && Player[victimid][eventMember] <= -1)
	{
	    ZombieSpawnProtection[playerid] = 0;
	    switch(type)
	    {
	        case 0:
	        {
			    new Float:pos[3];
			    if(!Player[victimid][AntiSeeker] && Player[victimid][pClass][TEAM_HUMAN] != VIPHUMAN && !IsEvacuated[victimid])
			    {
			   		GetPlayerPos(victimid, pos[0], pos[1], pos[2]);
					SetPlayerPosAC(playerid, pos[0]+0.4, pos[1]+0.4, pos[2]+0.3);
					foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][85], Player[victimid][UserName], Player[playerid][UserName]);
			        Abilitys[playerid][SeekerFound] = gettime();
			        
			       	SetAbilityTimer(playerid, 35);
					AchievementAddProgress(playerid, ach_USED_ABILITY);
					
			        GivePlayerXP(playerid, 2);
					return 1;
			    }
			}
			case 1:
			{
			    new Float:pos[5], Float:radius = 3.5;
			    if(!Player[victimid][AntiSeeker] && !IsEvacuated[victimid] && classCanBeFrighted(victimid))
			    {
			     	GetPlayerPos(victimid, pos[0], pos[1], pos[2]);
	        		SetPlayerPosAC(playerid, pos[0]+0.4, pos[1]+0.4, pos[2] - 0.3);
	        		foreach(Player,i)
					{
					    if(IsPlayerInRangeOfPoint(i, radius, pos[0], pos[1], pos[2]) && GetPlayerTeamEx(i) == TEAM_HUMAN && !IsEvacuated[i] && classCanBeFrighted(i))
					    {
					        GetPlayerFacingAngle(i, pos[3]);
	        				GetPlayerHealth(i, pos[4]);
	            			SetPlayerHealthAC(i, pos[4] - 5.00);
	            			ShowDamageTaken(i, 5.0);
					    	GetPlayerVelocity(i, pos[0], pos[1], pos[2]);
				  			SetPlayerVelocity(i, pos[0] + 0.5, pos[1] + 0.5, pos[2] + 0.3);
				  			SetPlayerFacingAngle(i, pos[3]);
						  	BlindPlayer(i, 8);
						  	AntiTPTimerEx(i, 4);
							AntiSlap(i, 4);
							AntiSpeedHack(i, 4);
						  	foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][70], Player[i][UserName], Player[playerid][UserName]);
					    }
					}
					RemovePlayerAttachedObject(playerid, 9);
	                SetPlayerAttachedObject(playerid,4,18641,2,-0.032000,0.014000,0.325000,0.000000,37.599998,0.000000,1.000000,1.000000,3.642001);
					SetPlayerAttachedObject(playerid,5,18641,1,0.376999,0.029000,-0.280999,0.000000,133.300018,0.000000,1.000000,1.000000,3.867000);
					SetPlayerAttachedObject(playerid,6,18641,1,-0.351000,0.005999,0.362999,-0.800000,-44.900005,0.000000,1.000000,1.000000,4.524999);
					SetPlayerAttachedObject(playerid,7,18641,1,-0.369000,-0.003000,-0.409000,-4.400001,-140.099822,0.000000,1.000000,1.000000,4.718002);
					SetPlayerAttachedObject(playerid,8,18641,1,0.000000,0.000000,0.500999,0.000000,0.000000,0.000000,1.000000,1.000000,4.641000);
					SetPlayerAttachedObject(playerid,9,18641,1,0.000000,0.000000,-0.500000,0.000000,-179.999847,0.000000,1.000000,1.000000,4.709000);
					SetTimerEx("HideSlenderObjects", 3000, false, "i", playerid);
				    //GivePlayerXP(playerid, 2);
				    Abilitys[playerid][SlenderBlind] = gettime();
				    SetAbilityTimer(playerid, 40);
				    AchievementAddProgress(playerid, ach_USED_ABILITY);
				    
					return 1;
				}
			}
		}
	}
    return 0;
}

fun GetClosestPlayer(p1)
{
    new x, Float:dis, Float:dis2, player;
    player = -1;
    dis = 999999.99;
    for(x = 0;x < MAX_PLAYERS; x++)
	{
        if(IsPlayerConnected(x))
		{
            if(x != p1)
			{
                dis2 = GetDistanceBetweenPlayers(x,p1);
                if(dis2 < dis && dis2 != -1.00)
				{
                    dis = dis2;
                    player = x;
                }
            }
        }
    }
    return player;
}

fun setClass(playerid)
{
    Player[playerid][pWasGangAffected] = false;
    CockroachAbility[playerid] = false;
    Player[playerid][hasBleedEffect] = false;
	KillTimer(Player[playerid][InfectedTimer]);
   	KillTimer(Player[playerid][PoisionTimer]);
   	KillTimer(Player[playerid][BleedingTimer]);
    TextDrawHideForPlayer(playerid, Poision[playerid]);
    TextDrawHideForPlayer(playerid, GreenScreen[playerid]);
    TextDrawHideForPlayer(playerid, Stun[playerid]);
    TextDrawHideForPlayer(playerid, Blidnes[playerid]);
    TextDrawHideForPlayer(playerid, Infected[playerid]);
	Player[playerid][Poisioned] = false;
 	Player[playerid][IsBurned][0] = 0;
 	Player[playerid][IsBurned][1] = 0;
	Player[playerid][LegBreak] = false;
	Player[playerid][AbilityAffectedID] = INVALID_PLAYER_ID;
	
	TextDrawHideForPlayer(playerid, Blidnes[playerid]);
   	TextDrawHideForPlayer(playerid, Infected[playerid]);
   	TextDrawHideForPlayer(playerid, Poision[playerid]);
   	TextDrawHideForPlayer(playerid, Stun[playerid]);
   	Player[playerid][Blidness] = 0;
   	Player[playerid][Tasered] = false;
    KillTimer(Player[playerid][BlidnessTimer]);
	CurePlayer(playerid);
	SetPlayerArmourAC(playerid, 0.0);
	
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    SetPlayerHealthAC(playerid, 100.0);
	}
	else SetPlayerHealthAC(playerid, 100.0);
	
	if(Player[playerid][pClass][TEAM_ZOMBIE+1] == TANKZOMBIE) SetPlayerHealthAC(playerid, 350.0);
	
	RemovePlayerAttachedObject(playerid, 4);
   	RemovePlayerAttachedObject(playerid, 5);
   	RemovePlayerAttachedObject(playerid, 6);
    RemovePlayerAttachedObject(playerid, 7);
   	RemovePlayerAttachedObject(playerid, 8);
   	RemovePlayerAttachedObject(playerid, 9);
   	SetPlayerFightingStyle(playerid, FIGHT_STYLE_GRABKICK);
   	ResetWeapons(playerid);

	if(GangName[playerid]>Text3D:-1) {
   		Delete3DTextLabel(GangName[playerid]);
	   	GangName[playerid]=Text3D:-1;
	}
   	
   	foreach(Player, i)
 	{
	   	ShowPlayerNameTagForPlayer(i, playerid, 1);
  		SetPlayerMarkerForPlayer(i, playerid, (GetPlayerColor(playerid) & 0xFFFFFF00));
  		
  		/*ShowPlayerNameTagForPlayer(playerid, i, 1);
  		SetPlayerMarkerForPlayer(playerid, i, (GetPlayerColor(i) & 0xFFFFFF00));*/
	}
	

    for( new i = 0; i < sizeof(svrCLHXP); i++)
	{
		if(gettime() > PlayerClassUnlocked[playerid][TEAM_HUMAN][i] && PlayerClassUnlocked[playerid][TEAM_HUMAN][i] > 0)
		{
			PlayerClassUnlocked[playerid][TEAM_HUMAN][i] = 0;
			if(Player[playerid][pClass][TEAM_HUMAN] == i) Player[playerid][pClass][TEAM_HUMAN] = CIVILIAN;
		}
	}
	
	for( new i; i < sizeof(svrCLZXP); i++)
	{
		if(gettime() > PlayerClassUnlocked[playerid][TEAM_ZOMBIE][i] && PlayerClassUnlocked[playerid][TEAM_ZOMBIE][i] > 0)
		{
			PlayerClassUnlocked[playerid][TEAM_ZOMBIE][i] = 0;
			if(Player[playerid][pClass][TEAM_ZOMBIE+1] == i) Player[playerid][pClass][TEAM_ZOMBIE+1] = STANDARDZOMBIE;
		}
	}
	
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && gettime() < LasDeadTime[playerid] && LasDeadTime[playerid] > 0) SetPlayerTeamEx(playerid, TEAM_ZOMBIE);

	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    setupHuman(playerid);
	    ResetWeapons(playerid);
	    SetPlayerArmourAC(playerid, 0.0);
	    
	    for( new j; j < 18; j++ )
	    {
		    if(IsValidObject(box[playerid][j]))
		    {
		        //SendClientMessageFormat(playerid, -1, "(Set Class) (ID: %d) >> %d", j, IsValidObject(box[playerid][j]));
		    	DestroyObject(box[playerid][j]);
	      		Delete3DTextLabel(boxText[playerid][j]);
			}
			box[playerid][j] = INVALID_OBJECT_ID;
		}
	    
	    SetPlayerFightingStyle(playerid, FIGHT_STYLE_GRABKICK);
		switch(Player[playerid][pClass][TEAM_HUMAN])
		{

		    case ADVANCEDHERO:
		    {
		    	GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
			    SetPlayerArmourAC(playerid, 50.0);
			    SetPlayerSkinAC(playerid, 267);
			    
			    HeroFieldTime[playerid][0] = (gettime() + 65);
			    HeroFieldTime[playerid][1] = (gettime() + 110);
		    }

			case HUMANQUEEN:
			{
			    // Deagle 70, M4 250, Rifle 20, Armour

			    GivePlayerWeaponAC(playerid, 31, 250);
			    GivePlayerWeaponAC(playerid, 25, 50);
		        GivePlayerWeaponAC(playerid, 24, 50);
			    SetPlayerArmourAC(playerid, 50.0);
			    Abilitys[playerid][QueenJumps][0] = 1;
			    SetPlayerSkinAC(playerid, 92);
			}

			case ADVANCEDENGINEER_2:
            {
                // Deagle 70, M4 250, Sniper 50, Armour
                GivePlayerWeaponAC(playerid, 34, 50);
			    GivePlayerWeaponAC(playerid, 24, 70);
			    GivePlayerWeaponAC(playerid, 31, 250);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 153);
		        Player[playerid][UnlimitedBoxes] = 0;
            }

			case IRONMAN:
			{
			    // 70 Deagle, 30 Shotgun, 20 Rifle, 1 Long Jump, Armour
			    GivePlayerWeaponAC(playerid, 25, 70);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 33, 20);
			    SetPlayerArmourAC(playerid, 50.0);

			    SetPlayerAttachedObject(playerid,8,19141,2,0.100999,0.010000,0.000999,0.000000,0.000000,0.000000,1.347001,1.021000,1.096000);
				SetPlayerAttachedObject(playerid,9,19142,1,0.101000,0.047999,0.013000,0.000000,0.000000,0.000000,1.102001,1.046999,1.009000);
				SetPlayerAttachedObject(playerid,7,18641,1,0.206999,0.089000,0.000000,93.299972,-21.300020,0.000000,1.000000,1.000000,1.000000);
			    SetPlayerSkinAC(playerid, 0);
			    Abilitys[playerid][Fuel] = 100.0;
			}

		    case POISONER:
		    {
		        // Rifle 20, Shotgun 50, Spraycan 3000, Deagle 50, Armour
     			GivePlayerWeaponAC(playerid, 31, 250);
			    GivePlayerWeaponAC(playerid, 24, 70);
			    GivePlayerWeaponAC(playerid, 25, 50);
			    GivePlayerWeaponAC(playerid, 33, 20);
			    GivePlayerWeaponAC(playerid, 41, 3000);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 143);
		    }

		    case SPIDERMAN:
			{
			    // Tec9 1200, Deagle 70, 1 Long Jump
			    GivePlayerWeaponAC(playerid, 24, 70);
			    GivePlayerWeaponAC(playerid, 32, 600, false);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 170);
		        Abilitys[playerid][QueenJumps][0] = 1;
			}

		    case SHARPSHOOTER:
			{
			    // 50 Sniper, Armour, Immunity
			    GivePlayerWeaponAC(playerid, 34, 150);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 286);
			}

		    case ADVANCEDPOLICEMAN:
		    {
		        // 100 deagle, Armour
			    GivePlayerWeaponAC(playerid, 24, 100);
		        SetPlayerArmourAC(playerid, 50.0);
		       	SetPlayerSkinAC(playerid, 280);
		       	Player[playerid][TaserReady] = true;
		    }

		    case ROCKETMAN:
			{
			    // M4 250, Deagle 70
   				GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
			    SetPlayerSkinAC(playerid, 50);
			}

		    case ADVANCEDSAMURAI:
		    {
			    // M4 250, Katana, Fighting style
			    GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 8, 1);
		        SetPlayerArmourAC(playerid, 30.0);
		        SetPlayerFightingStyle(playerid, FIGHT_STYLE_KUNGFU);
		        SetPlayerSkinAC(playerid, 204);
		    }

		    case ADVANCEDBOXER:
			{
			    // M4 250, Armour, Fighting style
			    GivePlayerWeaponAC(playerid, 31, 250);
			    SetPlayerArmourAC(playerid, 30.0);
		        SetPlayerFightingStyle(playerid, FIGHT_STYLE_BOXING);
		        SetPlayerSkinAC(playerid, 80);
			}

		    case ADVANCEDZOMBIEFAN:
		    {
		        GivePlayerWeaponAC(playerid, 9, 1);
		        SetPlayerColor(playerid, COLOR_ZOMBIE);
		        SetPlayerSkinAC(playerid, 1);
		    }

  			case COPIER:
			{
			    // Dildo, Ignore VIP classes
		        GivePlayerWeaponAC(playerid, 10, 1);
		        SetPlayerSkinAC(playerid, 252);
			}

 			case TOURIST:
			{
			    // M4 250, Deagle (70)
		        GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 26);
			}

		    case ROGUEHUMAN:
			{
			    // M4 250, Deagle (70)
		        GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerSkinAC(playerid, 97);
			}

		    case ADVANCEDSCOUT:
			{
			    // Sniper 50, Deagle (70)
		        GivePlayerWeaponAC(playerid, 34, 100);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 29);
			}

		    case TERRORIST:
			{
			    // M4 250, Dealge 70, Armour
			    GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 39, 25, false);
		        GivePlayerWeaponAC(playerid, 40, 1000);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 3);
			}

			case RUNNER:
			{
			    // M4 250, Deagle 70, Armour
			    GivePlayerWeaponAC(playerid, 24, 70);
			    GivePlayerWeaponAC(playerid, 31, 250);
			    SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 0);
			}

  			case ROLLERSKATER:
			{
			    // M4 250, Dealge 50, Armour

		        GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 31, 250);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 99);
			}

		    case SAPPER:
		    {
		        // M4 250, Dealge 70, Armour
		        GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 101);
		    }

		    case ADVANCEDMEDIC, SENIORMEDIC, NURSE:
		    {
		        // Rifle 20, Deagle 70, M4 250, Armour, Curing Rifle, /cure
   				if(getHumanClass(playerid) != NURSE) GivePlayerWeaponAC(playerid, 33, 20);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 31, 250);
		        SetPlayerArmourAC(playerid, 50.0);

				if(getHumanClass(playerid) == ADVANCEDMEDIC || getHumanClass(playerid) == SENIORMEDIC) SetPlayerSkinAC(playerid, 276);
				else SetPlayerSkinAC(playerid, 308);
				
		        SetPlayerAttachedObject(playerid, 9, 11738, 7, 0.24300, 0.00000, -0.11999, 0.00000, -88.40001, 88.00001, 1.00000, 1.00000, 1.00000);
		    }

			case TOUGHIE:
			{
			    // M4 250, Dealge 70, Armour
		        GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 110);
			}

			case SWAT:
			{
			    // SMG 200, Deagle (70), Armour, Immunity
   				GivePlayerWeaponAC(playerid, 29, 200);
		        GivePlayerWeaponAC(playerid, 24, 70);
				SetPlayerArmourAC(playerid, 50.0);
				SetPlayerSkinAC(playerid, 285);
			}

            case ADVANCEDENGINEER:
			{
			    // M4 (250), Dealge (70), Armour, 5 Boxes
   				GivePlayerWeaponAC(playerid, 24, 70);
		        GivePlayerWeaponAC(playerid, 31, 250);
				SetPlayerArmourAC(playerid, 50.0);
				SetPlayerSkinAC(playerid, 27);
				Player[playerid][AdvancedBoxes] = 5;
			}

			case FIREMANIAC:
			{
			    // Shotgun 50, Flamethwoer 20, 	Fire extinguisher (2500)
		        GivePlayerWeaponAC(playerid, 37, 200);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        GivePlayerWeaponAC(playerid, 42, 2500);
		        SetPlayerArmourAC(playerid, 40.0);
		        SetPlayerSkinAC(playerid, 277);
			}

		    case SCAVENGER:
			{
		        GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 8);
			}

		    case MI7:
			{
   				GivePlayerWeaponAC(playerid, 31, 250);
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 50.0);
		        SetPlayerSkinAC(playerid, 165);
			}

		    case ZOMBIEFAN:
		    {
		        // Chainsaw, Immunity
		        GivePlayerWeaponAC(playerid, 9, 1);
		        SetPlayerSkinAC(playerid, 181);
		    }

		    case WARMPERSON:
		    {
		        // Deagle (70), Armour
		        GivePlayerWeaponAC(playerid, 24, 70);
		        SetPlayerArmourAC(playerid, 40.0);
		        SetPlayerSkinAC(playerid, 249);
		    }

		    case ENGINEER:
			{
			    // AK 200, Silinced 100, Rifle 20, 3 Boxes

		        GivePlayerWeaponAC(playerid, 30, 200);
		        GivePlayerWeaponAC(playerid, 33, 20);
		        GivePlayerWeaponAC(playerid, 23, 100);
		        SetPlayerSkinAC(playerid, 260);

				Player[playerid][Boxes] = 3;
			}

		    case HERO:
		    {
		        // AK47 (250), Shotgun 50
		        GivePlayerWeaponAC(playerid, 30, 250);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerArmourAC(playerid, 30.0);
		        SetPlayerSkinAC(playerid, 34);
		    }

		    case HEAVYMEDIC:
		    {
		        // 100 Silinced, 50 Shotgun, /cure
   				GivePlayerWeaponAC(playerid, 24, 50);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerArmourAC(playerid, 30.0);
		        SetPlayerSkinAC(playerid, 274);
		        SetPlayerAttachedObject(playerid, 9, 11738, 7, 0.24300, 0.00000, -0.11999, 0.00000, -88.40001, 88.00001, 1.00000, 1.00000, 1.00000);
		    }

		    case HEAVYSUPPORT:
			{
			    GivePlayerWeaponAC(playerid, 30, 250);
			    GivePlayerWeaponAC(playerid, 23, 100);
			    SetPlayerArmourAC(playerid, 30.0);
			    SetPlayerSkinAC(playerid, 179);
			    Abilitys[playerid][CanGiveAmmo] = 5;
			}

		    case SCOUT:
			{
			    // 50 Sniper
   				GivePlayerWeaponAC(playerid, 34, 50, false);
		        SetPlayerSkinAC(playerid, 230);
			}

		    case MEDIC:
			{
			    // 100 Silinced, 50 Shotgun, /cure
   				GivePlayerWeaponAC(playerid, 23, 100);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerArmourAC(playerid, 30.0);
		        SetPlayerSkinAC(playerid, 275);
		        SetPlayerAttachedObject(playerid, 9, 11738, 7, 0.24300, 0.00000, -0.11999, 0.00000, -88.40001, 88.00001, 1.00000, 1.00000, 1.00000);
			}

		    case ADVANCEDCIVILIAN:
			{
				 // AK47 (150), 100 Silinced
		 		GivePlayerWeaponAC(playerid, 23, 100);
		        GivePlayerWeaponAC(playerid, 30, 150);
		        GivePlayerWeaponAC(playerid, 33, 20);
		        new skin = random(sizeof(civilRandomSkins));
		        SetPlayerSkinAC(playerid, civilRandomSkins[skin]);
			}

		    case GANGSTER:
			{
		 		// 50 Deagle, 2000 Spraycan
				GivePlayerWeaponAC(playerid, 24, 50);
   				GivePlayerWeaponAC(playerid, 41, 2000);
       			SetPlayerSkinAC(playerid, 107);
			}

		    case POLICEMAN:
			{
			    // 50 deagle, 50 shotgun, Armour
			    GivePlayerWeaponAC(playerid, 24, 50);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerArmourAC(playerid, 30.0);
		       	SetPlayerSkinAC(playerid, 280);
			}

		    case BOXER:
			{
			    // 35 Deagle, 50 Shotgun, Fighting style
			    GivePlayerWeaponAC(playerid, 24, 35);
			    GivePlayerWeaponAC(playerid, 25, 50);
		        SetPlayerFightingStyle(playerid, FIGHT_STYLE_BOXING);
		        SetPlayerSkinAC(playerid, 81);
			}

		    case SAMURAI:
			{
			    // 50 Deagle, Katana, Fighting style
			    GivePlayerWeaponAC(playerid, 24, 50);
		        GivePlayerWeaponAC(playerid, 8, 1);
		        SetPlayerFightingStyle(playerid, FIGHT_STYLE_KUNGFU);
		        SetPlayerSkinAC(playerid, 203);
			}

		    case CIVILIAN:
		    {
		        // 100 Silinced, 50 - shotgun
		        GivePlayerWeaponAC(playerid, 23, 200);
		        GivePlayerWeaponAC(playerid, 25, 100);
		        new skin = random(sizeof(civilRandomSkins));
		        SetPlayerSkinAC(playerid, civilRandomSkins[skin]);
			}

			// -----------------------------------------------------------------

			case VIPHUMAN:
			{
			    GivePlayerWeaponAC(playerid, 31, 350);
		        GivePlayerWeaponAC(playerid, 24, 50);
		        GivePlayerWeaponAC(playerid, 25, 50);
		        GivePlayerWeaponAC(playerid, 29, 150);
		        GivePlayerWeaponAC(playerid, 33, 10, false);
			    SetPlayerArmourAC(playerid, 50.0);
			    SetPlayerSkinAC(playerid, 119);
			}

			case ASSASSIN:
			{
			    GivePlayerWeaponAC(playerid, 31, 350);
		        GivePlayerWeaponAC(playerid, 24, 50);
		        GivePlayerWeaponAC(playerid, 33, 10, false);
			    SetPlayerArmourAC(playerid, 50.0);
			    SetPlayerSkinAC(playerid, 294);
			}
		}
		
		if(Player[playerid][pClass][TEAM_HUMAN] < sizeof(humanClassesListNames[])) SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][25], humanClassesListNames[Player[playerid][pLang]][Player[playerid][pClass][TEAM_HUMAN]]);
		else SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][25], humanVIPCl[Player[playerid][pLang]][Player[playerid][pClass][TEAM_HUMAN]-5000]);
		if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
		{
			if(Player[playerid][pVip] >= 1)
			{
   				SetPlayerArmourAC(playerid, 50.0);
			}
		}
		
		if(Player[playerid][pClan] > 0 && canBeGangTaged(playerid)) AttachGangName(playerid);
	}
	else if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    setupZombie(playerid);
	    ResetWeapons(playerid);
    	GivePlayerWeaponAC(playerid, 9, 1, false);
    	
    	for( new j; j < 2; j++ )
	   	{
	   		if(NewSpawnPoints[j][0] != 0.0 && NewSpawnsCreators[j] == playerid && Player[playerid][pClass][TEAM_ZOMBIE+1] != RISENDEAD)
			{
		 		NewSpawnsCreators[j] = INVALID_PLAYER_ID;
		 		Delete3DTextLabel(NewSpawnPointsText[j]);
		 		NewSpawnPoints[j][0] = 0.0;
			}
		}
    	
    	switch(Player[playerid][pClass][TEAM_ZOMBIE+1])
		{
		    case STANDARDZOMBIE: SetPlayerSkinAC(playerid, 181);
		    case MUTATEDZOMBIE: SetPlayerSkinAC(playerid, 1);
		    case TORNADOZOMBIE: SetPlayerSkinAC(playerid, 79);
		    case PIRATEZOMBIE: SetPlayerSkinAC(playerid, 32), ResetWeapons(playerid), GivePlayerWeaponAC(playerid, 8, 1);
		    case KAMIKAZEZOMBIE: SetPlayerSkinAC(playerid, 149), SetPlayerHealthAC(playerid, 15.0, true, 15.0);
		    case FREEZERZOMBIE: SetPlayerSkinAC(playerid, 137), SetPlayerHealthAC(playerid, 45.0, true, 45.0);
		    case SEEKERZOMBIE: SetPlayerSkinAC(playerid, 142);
		    case ADVANCEDMUTATED: SetPlayerSkinAC(playerid, 200);
		    case UNDEADBOXER: { SetPlayerSkinAC(playerid, random(2) == 0 ? 80 : 81); SetPlayerFightingStyle(playerid, FIGHT_STYLE_BOXING); }
		    case EARTHSHAKERZOMBIE: SetPlayerSkinAC(playerid, 133);
		    case PUNKZOMBIE: SetPlayerSkinAC(playerid, 134);
            case LEGBREAKER: SetPlayerSkinAC(playerid, 30);
			case ENFORCER: SetPlayerSkinAC(playerid, 60);
            case SPOREZOMBIE: SetPlayerSkinAC(playerid, 144);
            case GUNJAMMERZOMBIE: SetPlayerSkinAC(playerid, 285);
            case CAMOUFLAGEZOMBIE:
			{
				SetPlayerSkinAC(playerid, 123);
			}
			case DEMONZOMBIE: SetPlayerSkinAC(playerid, 130), SetPlayerHealthAC(playerid, 15.0, true, 15.0);
		    case FASTZOMBIE: SetPlayerSkinAC(playerid, 162);
	        case REAPERZOMBIE: SetPlayerSkinAC(playerid, 168);
	        case BOOMERZOMBIE: SetPlayerSkinAC(playerid, 264), SetPlayerHealthAC(playerid, 15.0, true, 15.0);
	        case STOMPERZOMBIE: SetPlayerSkinAC(playerid, 239);
			case BLINDZOMBIE: SetPlayerSkinAC(playerid, 213);
			case FLESHERZOMBIE: SetPlayerSkinAC(playerid, 77);
            case ROGUEZOMBIE: SetPlayerSkinAC(playerid, 135);
            case MEGAJUMPERZOMBIE: SetPlayerSkinAC(playerid, 162), Abilitys[playerid][ZombieJumps][0] = 3;
            case RADIOACTIVEZOMBIE: SetPlayerSkinAC(playerid, 146);
            case SPITTERZOMBIE:
			{
				SetPlayerSkinAC(playerid, 96);
				GivePlayerWeaponAC(playerid, 23, 1, false);
				Abilitys[playerid][SpitterWeapon] = gettime();
				SetAbilityTimer(playerid, 45);
			}
            case SLOWZOMBIE: SetPlayerSkinAC(playerid, 160);
            case RISENDEAD: SetPlayerSkinAC(playerid, 177);
            case SPACEBREAKERZOMBIE: SetPlayerSkinAC(playerid, 180);
            case REMOVER: SetPlayerSkinAC(playerid, 28);
            case SLENDERZOMBIE: SetPlayerSkinAC(playerid, 165), SetPlayerAttachedObject(playerid,9,19036,2,0.084999,0.037999,0.001000,0.000000,82.699966,98.799995,1.000000,1.070001,1.000000);
            case TANKZOMBIE: { SetPlayerHealthAC(playerid, 350.0); SetPlayerSkinAC(playerid, 155); }
            case SCREAMERZOMBIE: SetPlayerSkinAC(playerid, 212);
		}
		if(Player[playerid][Helmet]) SetPlayerAttachedObject(playerid, 9, 18936, 2, 0.129999,0.030000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);
		if(Player[playerid][pClass][TEAM_ZOMBIE+1] < sizeof(zombieClassesListNames[])) SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][25], zombieClassesListNames[Player[playerid][pLang]][Player[playerid][pClass][TEAM_ZOMBIE+1]]);
		else SendClientMessageFormat(playerid, -1, serverLang[Player[playerid][pLang]][25], zombieVIPCl[Player[playerid][pLang]][Player[playerid][pClass][TEAM_ZOMBIE+1]-5000]);

        new Float:hp;
    	GetPlayerHealthEx(playerid, hp);
    	hp = max(hp, hp*(Map[m_GangControll]==0?1.5:0.0));
   	 	SetPlayerHealthAC(playerid, hp, true, hp);

	}
	if(GetWeekDay() == GANG_WARS_DAY)
	{
	    static hours, minutes, seconds;
	    gettime(hours, minutes, seconds);
		if(gettime() > Map[m_LastCapturedTime] && hours >= 15 && hours < 20) SendClientMessage(playerid,-1,"{77d4b2}[CASTLE]: THIS CASTLE CAN BE CAPTURED! [NOT PROTECTED]");
	}
}

stock Float:GetDistanceBetweenPoints3D(Float:x1,Float:y1,Float:z1,Float:x2,Float:y2,Float:z2) { return VectorSize(x1-x2,y1-y2,z1-z2); }

stock BadFloat(Float:x)
{
	if(x >= 10.0 || x <= -10.0) return 1;
	return 0;
}

fun OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, Float: fX, Float: fY, Float: fZ)
{
	if(hittype == BULLET_HIT_TYPE_VEHICLE) if(hitid <= -1 || !IsValidVehicle(hitid)) return 0;
    if(hittype == BULLET_HIT_TYPE_PLAYER) if(!IsPlayerConnected(hitid)) return 0;
	
	if(hittype == BULLET_HIT_TYPE_OBJECT) {
     	new model_id = GetPlayerObjectModel(playerid, hitid);
		if(model_id == 18876 && Clan[Player[playerid][pClan]][g_WarType] == 1)
		{
		    if(hitid == castle_object[0] && Clan[Player[playerid][pClan]][g_WarType] == 1) return 0;
		    if(hitid == castle_object[1] && Clan[Player[playerid][pClan]][g_WarType] == 0) return 0;
		    
		    new war_id = Clan[Player[playerid][pClan]][g_Emblem] - 100;
			switch(weaponid)
			{
				case 34: Clan[war_id][g_ObjectHealth] -= 49.5;
				case 30,31: Clan[war_id][g_ObjectHealth] -= 10.0;
				case 24: Clan[war_id][g_ObjectHealth] -= 42.5;
				case 25: Clan[war_id][g_ObjectHealth] -= 8.0;
				case 22: Clan[war_id][g_ObjectHealth] -= 5.0;
        	}
        	new str[128];
			format(str, sizeof(str), "{FFF000}%s's OBJECT\n\nHealth: %.2f", Clan[war_id][Full], Clan[war_id][g_ObjectHealth]);
        	Update3DTextLabelText(Clan[war_id][g_ObjectStatus], -1, str);
        	
        	if(Clan[war_id][g_ObjectHealth] <= 0.0) {
        	    if(IsValidTimer(Clan[war_id][g_GWTimer])) KillTimerEx(Clan[war_id][g_GWTimer]);
				EndMatch(Player[playerid][pClan], war_id, Clan[Player[playerid][pClan]][g_ForMapID]);
			}
        	return 1;
        }
	}
	
	
	
    new Float:capos[3];
	GetPlayerCameraPos(playerid, capos[0], capos[1], capos[2]);
	if(floatcmp(capos[0], 7000.0) == 1 || floatcmp(capos[1], 7000.0) == 1 || floatcmp(capos[2], 7000.0) == 1 || floatcmp(capos[0], -7000.0) == -1 || floatcmp(capos[1], -7000.0) == -1 || floatcmp(capos[2], -7000.0) == -1)
	{
	    foreach(Player, i)
	    {
	        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Weapon Crasher #1", Player[playerid][UserName], playerid);
		}
		return 0;
	}
	
	GetPlayerPos(playerid, capos[0], capos[1], capos[2]);
	if(!(-20000.0 <= capos[2] <= 20000.0))
	{
	    foreach(Player, i)
	    {
	        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) - Invalid AIM data", Player[playerid][UserName], playerid);
		}
		return 0;
	}
	
	if(hittype == BULLET_HIT_TYPE_PLAYER)
	{
		if(fX == -0.009999 && fY == -0.019999 && fZ == 0.039999)
		{
			foreach(Player, i)
		    {
		        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Eclipse Crasher #1", Player[playerid][UserName], playerid);
			}
			return 0;
		}
	}
	
    if(GetPlayerState(playerid) != 2 && weaponid != 38 && !(21 < weaponid < 35))
	{
	    foreach(Player, i)
	    {
	        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Weapon Crasher #2", Player[playerid][UserName], playerid);
		}
		return 0;
	}
	
	if(hittype == BULLET_HIT_TYPE_PLAYER && (BadFloat(fX) || BadFloat(fY) || BadFloat(fZ)) )
	{
	    foreach(Player, i)
	    {
	        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Bullet Crasher", Player[playerid][UserName], playerid);
		}
        return 0;
	}

    new weapname[32];
	GetWeaponName(weaponid, weapname, sizeof(weapname));
	SetPVarInt(playerid, weapname, GetPVarInt(playerid, weapname) - 1);
    
	if(playerid != INVALID_PLAYER_ID)
	{
	    if(IsPlayerOnDuel[playerid] && DuelRules[0][playerid] <= 0)
        {
	        gLastShotTime[playerid] = GetTickCount();
		    new LastShotDelay = GetTickCount() - LastShotTime[playerid];
			switch(weaponid)
			{
				 case 22: if(LastShotDelay < COLT_DELAY_HIT) return 0;
			     case 23: if(LastShotDelay < SILENCE_HIT_DELAY) return 0;
			     case 24: if(LastShotDelay < DEAGLE_HIT_DELAY) return 0;
			     case 25: if(LastShotDelay < SHOTGUN_HIT_DELAY) return 0;
			     case 33: if(LastShotDelay < RIFLE_HIT_DELAY) return 0;
			     case 34: if(LastShotDelay < SNIPER_HIT_DELAY) return 0;
			}
			LastShotTime[playerid] = GetTickCount();
		}
		else
		{
		    gLastShotTime[playerid] = GetTickCount();
		    new LastShotDelay = GetTickCount() - LastShotTime[playerid];
			switch(weaponid)
			{
				 case 22: if(LastShotDelay < COLT_DELAY_HIT) return 0;
			     case 23: if(LastShotDelay < SILENCE_HIT_DELAY) return 0;
			     case 24: if(LastShotDelay < DEAGLE_HIT_DELAY) return 0;
			     case 25: if(LastShotDelay < SHOTGUN_HIT_DELAY) return 0;
			     case 33: if(LastShotDelay < RIFLE_HIT_DELAY) return 0;
			     case 34: if(LastShotDelay < SNIPER_HIT_DELAY) return 0;
			}
			LastShotTime[playerid] = GetTickCount();
		}
		
		if(GetPVarInt(playerid, weapname) <= -5 && strlen(weapname) >= 2 && GetPlayerWeapon(playerid) > 0)
		{
		    //printf("%d", GetPVarInt(playerid, weapname));
		    if(AdminOnline())
		    {
			    if(gettime() > AntiCheat[playerid][ac_Tick])
        		{
				    foreach(Player, p)
				    {
				        if(Player[p][pAdmin] > 0 && Player[p][pLogged])
				        {
				            SendClientMessageFormat(p, -1, "{6A8EE2}>> %s(%d) supposedly uses Weapon Hack", Player[playerid][UserName], playerid);
				        }
					}
					AntiCheat[playerid][ac_Tick] = gettime()+2;
			    }
			}
			else
			{
			    if(gettime() > AntiCheat[playerid][ac_Tick])
        		{
			    	SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Weapon Hacks? Type:{FFFFFF} /report %d WH{FFF000} if he/she is.", Player[playerid][UserName], playerid, playerid);
                    AntiCheat[playerid][ac_Tick] = gettime()+2;
				}
			}
			return 0;
		}
		
		if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && weaponid == 23 && hittype == BULLET_HIT_TYPE_PLAYER && GetPlayerTeamEx(hitid) == TEAM_HUMAN)
		{
		    for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 15.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) return 0;
            if(getHumanClass(hitid) == SHARPSHOOTER) return 0;
            
			ZombieSpawnProtection[playerid] = 0;
	        if(InfectPlayer(60.0, hitid, playerid))
            {
                foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][182], Player[hitid][UserName], Player[playerid][UserName]);
				GivePlayerXP(playerid, 2);
				Abilitys[playerid][SpitterWeapon] = gettime();
			}
			return 0;
		}
		
		if(hittype == BULLET_HIT_TYPE_PLAYER && GetPlayerTeamEx(hitid) == TEAM_ZOMBIE)
		{
		    if(gettime() < ZombieSpawnProtection[hitid])
			{
			    SetPlayerChatBubble(hitid, "MISS", 0xd6d6c2FF, 20.0, 1000);
			    
			    for( new j; j < sizeof(Map[ZombieSpawnX]); j++ )
				{
					if(IsPlayerInRangeOfPoint(hitid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j]))
					{
					    new Float:hp;
					    GetPlayerHealthEx(playerid, hp);
					    SetPlayerHealthAC(playerid, hp - 20.0);
					    GameTextForPlayer(playerid,"~r~Spawn Damage", 4000, 5);
					}
				}
				return 0;
			}
			
			for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(hitid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) { SetPlayerChatBubble(hitid, "MISS", 0xd6d6c2FF, 20.0, 1000); return 0; }

			if(Player[hitid][pClass][TEAM_ZOMBIE+1] == ENFORCER && GetPlayerTeamEx(playerid) == TEAM_HUMAN && weaponid != 0 && weaponid != 23 && weaponid != 25 && weaponid != 24 && weaponid != 30 && weaponid <= 31) return 0;
		}
		
		if(hittype != 1 && ProAimCount[playerid] > 0)
	    {
	        ProAimCount[playerid] = 0;
	    }
		
		if(hittype == BULLET_HIT_TYPE_OBJECT && (Player[playerid][pClass][TEAM_HUMAN] == ENGINEER || Player[playerid][pClass][TEAM_HUMAN] == ADVANCEDENGINEER || Player[playerid][pClass][TEAM_HUMAN] == ADVANCEDENGINEER_2)) // Check for class
		{
		    //SendClientMessageFormat(playerid, -1, "(Shoot) (ID: %d)", hitid);
		    
		    for( new i = 0; i < 18; i++ )
			{
	            if(hitid == box[playerid][i])
				{
					DestroyObject(box[playerid][i]);
					Delete3DTextLabel(boxText[playerid][i]);
					//SendClientMessageFormat(playerid, -1, "(Shoot) (ID: %d) >> %d", hitid, IsValidObject(box[playerid][i]));
					box[playerid][i] = INVALID_OBJECT_ID;
					//SendClientMessageFormat(playerid, -1, "Valid: %d", box[playerid][i]);
					//return 1;
				}
			}
		}
		
	    if(hittype != BULLET_HIT_TYPE_NONE) 
		{
			if((fX <= -1000.0 || fX >= 1000.0) || (fY <= -1000.0 || fY >= 1000.0) || (fZ <= -1000.0 || fZ >= 1000.0) || ((hittype != BULLET_HIT_TYPE_PLAYER) && (hittype != BULLET_HIT_TYPE_VEHICLE) && (hittype != BULLET_HIT_TYPE_OBJECT) && (hittype != BULLET_HIT_TYPE_PLAYER_OBJECT)))
			{
				return 0;
			}
		}
	}
	return 1;
}

fun CanBeWeaponRemoved(playerid)
{
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun canBeFreezed(playerid)
{
    if(Player[playerid][AntiFreeze]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN, WARMPERSON: return 0;
	}
	if(Player[playerid][pVip] >= 1) return 0;
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun CanBeInExplosion(playerid)
{
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN, SAPPER: return 0;
	}
	return 1;
}

fun canBeLegBreaked(playerid)
{
    if(Player[playerid][AntiLegBreaks]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun canBeScreamed(playerid)
{
    if(Player[playerid][AntiScreamer]) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    switch(Player[playerid][pClass][TEAM_HUMAN])
		{
		    case VIPHUMAN: return 0;
		}
	}
	if(Player[playerid][pXP] < 2500) return 0;
	return 1;
}

fun canBeGangTaged(playerid) {
    if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case SCOUT, ADVANCEDSCOUT, COPIER, ROGUEHUMAN, ADVANCEDZOMBIEFAN: return 0;
	}
	return 1;
}

fun canBeBlinded(playerid)
{
    if(Player[playerid][AntiBlind]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN, SWAT, ADVANCEDZOMBIEFAN: return 0;
	}
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun canBeBurned(playerid, bool:ignore_zombies)
{
    if(Player[playerid][AntiBuring]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(ignore_zombies) if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun canBeInRadioactiveField(playerid)
{
    if(Player[playerid][AntiRadioctive]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN, IRONMAN: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun classCanBeFrighted(playerid)
{
    if(Player[playerid][AntiSeeker]) return 0;
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN, TOUGHIE: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun classCanBeArmourRemoved(playerid)
{
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case VIPHUMAN: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun classCanBeStomped(playerid)
{
    switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case HUMANQUEEN, VIPHUMAN, IRONMAN, TOUGHIE, ADVANCEDENGINEER_2, ADVANCEDHERO: return 0;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun classCanBeInfected(playerid)
{
	switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case SWAT, HUMANQUEEN, ZOMBIEFAN, VIPHUMAN, ADVANCEDENGINEER_2, ADVANCEDHERO: return 0;
	}
	
	if(GetPlayerSpeed(playerid) <= 2)
	{
		new Float:pos[3];
		GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
		foreach(Player, i) if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == NURSE && GetPlayerSpeed(i) <= 2 && IsPlayerInRangeOfPoint(i, 7.0, pos[0], pos[1], pos[2])) return 0;
	}
	
	if(Player[playerid][IsPlayerInfected]) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	if(Player[playerid][eventMember] > -1) return 0;
	return 1;
}

fun IsCamperClass(playerid)
{
	switch(Player[playerid][pClass][TEAM_HUMAN])
	{
	    case SCOUT, ROCKETMAN, SHARPSHOOTER: return 1;
	}
	if(Player[playerid][pXP] < 2500) return 0;
	if(Player[playerid][IsPlayerInfected]) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 0;
}

//stock

stock InfectPlayer(Float:distance, playerid, infectedid, Float:hp = 1.5, drankLevel = 0, bool:canInfectHumans = false)
{
	if(Player[playerid][aDuty]) return 0;
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && classCanBeInfected(playerid))
	{
        new Float:pos[3];
  		GetPlayerPos(infectedid, pos[0], pos[1], pos[2]);
  		if(IsPlayerInRangeOfPoint(playerid, distance, pos[0], pos[1], pos[2]))
  		{
  		    switch(Player[playerid][pLang])
		    {
				case 0: GameTextForPlayer(playerid, "~r~You have been infected!", 2000, 5);
		        case 1: GameTextForPlayer(playerid,RusToGame("~r~ВЫ ЗАРАЖЕНЫ"), 2000, 5);
		        case 2: GameTextForPlayer(playerid,"~r~Has estado infectado!", 2000, 5);
			}
			if(drankLevel <= 0) drankLevel = 500;
			
			SetPlayerDrunkLevel(playerid, drankLevel);
	  		Player[playerid][InfectedTimer] = SetTimerEx("Infection", 2000, 1, "ifii", playerid, hp, drankLevel, infectedid);
	  		
	  		if(!Player[playerid][IsCursed]) SetPlayerColor(playerid,COLOR_INFECTED);
	  		
			TextDrawShowForPlayer(playerid, Infected[playerid]);
			Player[playerid][IsPlayerInfected] = true;
			if(canInfectHumans) Player[playerid][IsPlayerAdvancedInfected] = true;
			foreach(Player, i)
			{
			    if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == MEDIC)
				{
				    SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][26], Player[playerid][UserName]);
				}
			}
			return 1;
		}
		return 0;
	}
	return 0;
}

stock InfectPlayerWithAbility(playerid, Float:hp = 0.0, effect, provoked = INVALID_PLAYER_ID)
{
	if(hp > 0.0 && !Player[playerid][Poisioned])
	{
	    Player[playerid][PoisionTimer] = SetTimerEx("PoisionFunction", 2000, 1, "ifi", playerid, hp, effect);
     	Player[playerid][Poisioned] = true;
     	TextDrawShowForPlayer(playerid, Poision[playerid]);
      	if(provoked != INVALID_PLAYER_ID) Player[playerid][AbilityAffectedID] = provoked;
	}
}

fun BlindPlayer(playerid, time)
{
    if(canBeBlinded(playerid))
	{
		TextDrawShowForPlayer(playerid, Blind[playerid]);
		SetTimerEx("HideBlind", time*1000, false, "i", playerid);
		SetPlayerWeather(playerid, 999);
	}
}

fun HideBlind(playerid) { TextDrawHideForPlayer(playerid, Blind[playerid]); SetPlayerWeather(playerid, Map[m_Weather]); }

stock InfectPlayerBlidness(playerid, provoked = INVALID_PLAYER_ID)
{
    Player[playerid][BlidnessTimer] = SetTimerEx("StartBlidnes", 5000, 1, "i", playerid);
    if(provoked != INVALID_PLAYER_ID) Player[playerid][AbilityAffectedID] = provoked;
}

fun StartBlidnes(playerid)
{
	if(Player[playerid][Blidness])
	{
		TextDrawHideForPlayer(playerid, Blidnes[playerid]);
		switch(Player[playerid][Blidness])
		{
			case 0: TextDrawBoxColor(Blidnes[playerid], 0x00000000);
			case 1: TextDrawBoxColor(Blidnes[playerid], 0x00000011);
			case 2: TextDrawBoxColor(Blidnes[playerid], 0x00000022);
			case 3: TextDrawBoxColor(Blidnes[playerid], 0x00000033);
			case 4: TextDrawBoxColor(Blidnes[playerid], 0x00000044);
			case 5: TextDrawBoxColor(Blidnes[playerid], 0x00000055);
			case 6: TextDrawBoxColor(Blidnes[playerid], 0x00000066);
			case 7: TextDrawBoxColor(Blidnes[playerid], 0x00000077);
			case 8: TextDrawBoxColor(Blidnes[playerid], 0x00000088);
			case 9: TextDrawBoxColor(Blidnes[playerid], 0x00000099);
			case 10: TextDrawBoxColor(Blidnes[playerid], 0x000000AA);
			case 11: TextDrawBoxColor(Blidnes[playerid], 0x000000BB);
			case 12: TextDrawBoxColor(Blidnes[playerid], 0x000000CC);
			case 13: TextDrawBoxColor(Blidnes[playerid], 0x000000DD);
			case 14: TextDrawBoxColor(Blidnes[playerid], 0x000000EE);
			case 15: { TextDrawBoxColor(Blidnes[playerid], 0x000000FF); SetPlayerWeather(playerid, 999); }
		}
		TextDrawShowForPlayer(playerid, Blidnes[playerid]);
		if(Player[playerid][Blidness] < 15) Player[playerid][Blidness]++;
	}
	else
	{
	    KillTimer(Player[playerid][BlidnessTimer]);
	    TextDrawHideForPlayer(playerid, Blidnes[playerid]);
		Player[playerid][Blidness] = 0;
	}
}

fun PoisionFunction(playerid, Float: hp, effect)
{
    if(Player[playerid][Poisioned])
    {
	    new Float:health;
	    if(effect == 0) GameTextForPlayer(playerid,"~p~Poison", 1000, 5);
	    if(effect == 1) GameTextForPlayer(playerid,"~y~Stung", 1000, 5);
	    if(effect == 2)
		{
		    new Float:h;
		    GetPlayerArmour(playerid, h);
		    if( h <= 0.0 ) GameTextForPlayer(playerid,"~p~Radiation", 1000, 5);
	        else hp = 0.0;
		}
	    
		GetPlayerHealth(playerid, health);
		SetPlayerHealthAC(playerid, health - hp);
		ShowDamageTaken(playerid, hp);
	}
}

fun Infection(playerid, Float: hp, drankLevel, from)
{
	if(hp <= 0.0) hp = 1.5;
    if(from > -1)
    {
		switch(Player[playerid][pLang])
	    {
			case 0: GameTextForPlayer(playerid, "~r~Infected", 2000, 5);
	        case 1: GameTextForPlayer(playerid,RusToGame("~r~ЗАРАЖЕН"), 2000, 5);
	        case 2: GameTextForPlayer(playerid,"~r~Infectado", 2000, 5);
		}
		new Float:health;
		GetPlayerHealth(playerid, health);
		SetPlayerHealthAC(playerid, health - hp);
		SetPlayerDrunkLevel(playerid, drankLevel);
		ShowDamageTaken(playerid, hp);
	}
	else if(Player[playerid][hasBleedEffect])
	{
	    switch(Player[playerid][pLang])
	    {
			case 0: GameTextForPlayer(playerid, "~r~Bleeding", 2000, 5);
	        case 1: GameTextForPlayer(playerid,RusToGame("~r~КРО_В_ОТЕЧЕНИЕ"), 2000, 5);
	        case 2: GameTextForPlayer(playerid, "~r~Sangrado", 2000, 5);
		}
		new Float:health;
		GetPlayerHealth(playerid, health);
		SetPlayerHealthAC(playerid, health - hp);
		SetPlayerDrunkLevel(playerid, drankLevel);
		ShowDamageTaken(playerid, hp);
	}
}

stock CurePlayer(playerid, healerid = INVALID_PLAYER_ID)
{
    if(healerid != INVALID_PLAYER_ID)
    {
        new Float:pos[3];
		GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
		foreach(Player, i) if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pClass][TEAM_ZOMBIE+1] == CUREBLOCKER && IsPlayerInRangeOfPoint(i, 15.0, pos[0], pos[1], pos[2])) return 0;
		AchievementAddProgress(healerid, ach_CURED_HUMANS);
    }
    
	if(Player[playerid][IsPlayerInfected])
	{
    	KillTimer(Player[playerid][InfectedTimer]);
	    Player[playerid][IsPlayerInfected] = false;
	    Player[playerid][IsPlayerAdvancedInfected] = false;
	    setHumanColor(playerid);
		SetPlayerDrunkLevel(playerid, 0);
		TextDrawHideForPlayer(playerid, Infected[playerid]);
		TextDrawHideForPlayer(playerid, Blind[playerid]);
		Player[playerid][SlowWalk] = 0;
		Player[playerid][AbilityAffectedID] = INVALID_PLAYER_ID;
		return 1;
	}
	return 0;
}

stock GetPlayerHealthEx(playerid, &Float:hp) { hp = playerStats[playerid][0]; }
stock GetPlayerArmourEx(playerid, &Float:hp) { hp = playerStats[playerid][1]; }

stock SetPlayerHealthAC(playerid, Float: Health, bool:ignore = false, Float:def = 100.0)
{
    new Float:ad = 0.0;

	if(!ignore)
    {
	    playerStats[playerid][2] = 3;
	    playerStats[playerid][0] = Health + ad;
	    LastHealth[playerid][0] = ((Health+ad) - 100.0);
	    SetPlayerHealth(playerid, Health+ad);
    }
    else
    {
        playerStats[playerid][2] = 3;
	    playerStats[playerid][0] = def + ad;
	    LastHealth[playerid][0] = ((def+ad) - 100.0);
	    SetPlayerHealth(playerid, def+ad);
    }
    AntiCheat[playerid][ac_OldHP] = 0.0;
    AntiCheat[playerid][ex_OldHP] = 0.0;
    AntiCheat[playerid][weap_OldHP] = -100.0;
    return 1;
}

stock SetPlayerArmourAC(playerid, Float: Armour, bool:ignore_limit = false)
{
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    playerStats[playerid][3] = 3;
		playerStats[playerid][1] = 0.0;
		LastHealth[playerid][1] = -100.0;
		SetPlayerArmour(playerid, 0.0);
		return 1;
	}
	
	new Float:ad = 0.0;
	playerStats[playerid][3] = 3;
	playerStats[playerid][1] = Armour + ad;
	
	if(!ignore_limit) playerStats[playerid][1] = float(min(floor(playerStats[playerid][1]), 85));
	LastHealth[playerid][1] = ((playerStats[playerid][1]) - 100.0);
	SetPlayerArmour(playerid, playerStats[playerid][1]);
	
    return 1;
}

stock SetPlayerTeamEx(playerid, team)
{
    Player[playerid][pTeam] = team;
	if(team == TEAM_HUMAN || team == TEAM_ZOMBIE) SetPlayerTeam(playerid, 0); else SetPlayerTeam(playerid, team);
}

stock GetPlayerTeamEx(playerid) return Player[playerid][pTeam];


stock ResetWeapons(playerid)
{
    new gunname[32];
	for(new i; i<46; i++)
	{
		GetWeaponName(i, gunname, sizeof(gunname));
		SetPVarInt(playerid, gunname, -4);
	}
    SetPlayerArmedWeapon(playerid, 0);
    ResetPlayerWeapons(playerid);
}

stock GivePlayerWeaponAC(playerid, weapid, ammo, bool:candouble = true)
{
    new gunname[32];
    GetWeaponName(weapid, gunname, sizeof(gunname));
    SetPVarInt(playerid, gunname, 0);
    //SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname) + ammo);
    if(candouble)
	{
	    new addAmo = 0;
	    
	    GetWeaponName(weapid, gunname, sizeof(gunname));
	    if(Player[playerid][pVip] >= 1 && weapid != 27 && weapid != 26 && weapid != 16 && weapid <= 32 && GetPlayerTeamEx(playerid) == TEAM_HUMAN)
		{
		    if((ammo*2)+addAmo < 1000)
		    {
				SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname) + (ammo*2)+addAmo);
				GivePlayerWeapon(playerid, weapid, (ammo * 2)+addAmo);
			}
			else
			{
			    SetPVarInt(playerid, gunname, 1000);
				GivePlayerWeapon(playerid, weapid, 1000);
			}
		}
		else
		{
		    if(GetPlayerTeamEx(playerid) != TEAM_HUMAN) addAmo = 0;
		    
		    if((ammo+addAmo) < 1000)
		    {
				SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname) + (ammo+addAmo));
				GivePlayerWeapon(playerid, weapid, (ammo+addAmo));
  			}
			else
			{
			    GivePlayerWeapon(playerid, weapid, 1000);
			    SetPVarInt(playerid, gunname, 1000);
			    SetPlayerAmmoAC(playerid, weapid, 1000);
			}
		}
	}
	else
	{
	    new addAmo = 0;
	    new wd, wp;
	    GetPlayerWeaponData(playerid, GetWeaponSlot(weapid), wp, wd);
	   	if(wd <= 0)
 		{
 		    SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname) + ammo+addAmo);
		 	GivePlayerWeapon(playerid, weapid, ammo+addAmo);
		}
		else
		{
		    if(wd > 0 &&  GetPVarInt(playerid, gunname) <= 0)
		    {
		        GivePlayerWeapon(playerid, weapid, ammo+addAmo);
		        SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname) + ammo+addAmo);
   				SetPlayerAmmoAC(playerid, weapid, GetPVarInt(playerid, gunname));
       			SetPVarInt(playerid, gunname, GetPVarInt(playerid, gunname));
		    }
			else if(GetPVarInt(playerid, gunname) > 1000)
			{
			    GivePlayerWeapon(playerid, weapid, ammo);
   				SetPlayerAmmoAC(playerid, weapid, 1000);
       			SetPVarInt(playerid, gunname, 1000);
			}
		}
	}
	return 1;
}

stock SetPlayerAmmoAC(playerid, weapid, ammo)
{
    new gunname[32];
    GetWeaponName(weapid, gunname, sizeof(gunname));
    SetPVarInt(playerid, gunname, ammo);
    SetPlayerAmmo(playerid, weapid, ammo);
}

stock GivePlayerXP(playerid, xp, bool:more=true)
{
    new string[24];
    if((xp == 2 || xp == 1) && more) xp = 5;
	Player[playerid][pXP] += floor(xp * GetVipOnKillBonus(playerid));
	
	format(string,sizeof(string),"~y~+_%i_]", xp);
	GameTextForPlayer(playerid, string, 3500, 5);
}

fun CanUseAbility(playerid)
{
	if(Player[playerid][aDuty]) return 0;
	if(Player[playerid][Jailed] >= 1) return 0;
	if(GetPlayerAnimationIndex(playerid) == 839) return 0;
	if(IsFalling(playerid))
	{
	    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	    {
	    	if(Player[playerid][pClass][TEAM_HUMAN] == ROCKETMAN ||
      		Player[playerid][pClass][TEAM_HUMAN] == IRONMAN ||
        	Player[playerid][pClass][TEAM_HUMAN] == SPIDERMAN ||
         	Player[playerid][pClass][TEAM_HUMAN] == HUMANQUEEN) return 1;
		}
		else if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
		{
		    if(Player[playerid][pClass][TEAM_ZOMBIE+1] == FASTZOMBIE ||
      		Player[playerid][pClass][TEAM_ZOMBIE+1] == MEGAJUMPERZOMBIE) return 1;
		}
		return 0;
	}
	
	if(PlayerGuitarTime[playerid] >= 1 && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) return 0;
	return 1;
}

fun stopSound(i) return PlayerPlaySound(i, 0, 0.0, 0.0, 0.0);

public OnPlayerGiveDamageActor(playerid, damaged_actorid, Float: amount, weaponid, bodypart)
{
    if(damaged_actorid >= Merchants[0] && damaged_actorid <= Merchants[4])
    {
		ApplyActorAnimation(damaged_actorid, "DEALER", "DEALER_IDLE", 4.1, 1, 0, 0, 1, 1000);
        return 0;
	}
	return 0;
}

fun OnPlayerGiveDamage(playerid, damagedid, Float:amount, weaponid, bodypart)
{
    if(IsPlayerConnected(damagedid))
	{
		if(Player[playerid][aDuty] || Player[damagedid][aDuty]) return 1;
		if(gettime() < ZombieSpawnProtection[damagedid] && GetPlayerTeamEx(damagedid) == TEAM_ZOMBIE)
		{
		    SetPlayerChatBubble(damagedid, "SPAWN PROTECTION", 0xd6d6c2FF, 20.0, 1000);
			return 0;
		}
		if(GetPlayerTeamEx(damagedid) == TEAM_ZOMBIE) for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(damagedid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) { SetPlayerChatBubble(damagedid, "SPAWN PROTECTION", 0xd6d6c2FF, 20.0, 1000); return 0; }
		
		if(weaponid >= 22 && weaponid <= 42 || weaponid == 0 || weaponid == 8 || weaponid == 9)
		{
		    PlayerShotPlayer[playerid][damagedid] = true;

			//ApplyCustomDamage(playerid, damagedid, weaponid, amount, false, bodypart);
			UseDamageSystem(damagedid, playerid, amount, weaponid, bodypart);
		}
	}
    return 1;
}

fun OnPlayerTakeDamage(playerid, issuerid, Float: amount, weaponid, bodypart)
{
    if(weaponid >= 49 && weaponid <= 54)
	{
	    if(IsPlayerConnected(issuerid))
		{
			if(GetPlayerTeamEx(issuerid) != GetPlayerTeamEx(playerid) && !Player[issuerid][aDuty])
			{
			    PlayerShotPlayer[issuerid][playerid] = true;
			    if(weaponid == 50)
			    {
			        if(!ItsNewbie(playerid)) ApplyCustomDamage(issuerid, playerid, weaponid, amount, false, bodypart);
			    }
				else ApplyCustomDamage(issuerid, playerid, weaponid, amount, false, bodypart);
			}
		}
		else
		{
			return 0;
		}
	}
    else if((!IsPlayerConnected(playerid) || !IsPlayerConnected(issuerid)) && weaponid != 33)
	{
	    //printf("Check damage #2: %d", weaponid);
		return 0;
	}
	
	PlayerShotPlayer[issuerid][playerid] = true;
	if(Player[issuerid][aDuty] || Player[playerid][aDuty]) return 0;
	
	if(gettime() < ZombieSpawnProtection[playerid] && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
 		SetPlayerChatBubble(playerid, "SPAWN PROTECTION", 0xd6d6c2FF, 20.0, 1000);
		return 0;
	}
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE) for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(playerid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) { SetPlayerChatBubble(playerid, "SPAWN PROTECTION", 0xd6d6c2FF, 20.0, 1000); return 0; }
    if(weaponid >= 1 && weaponid <= 15 && weaponid != 8 && weaponid != 9) UseDamageSystem(playerid, issuerid, amount, weaponid, bodypart);
    
	return 1;
}

fun Unstung(playerid)
{
	TextDrawHideForPlayer(playerid, Stun[playerid]);
	Player[playerid][Stung] = false;
}

fun TaserIsReady(playerid, hitid)
{
    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == ADVANCEDPOLICEMAN)
	{
	    switch(Player[playerid][pLang])
	    {
			case 0: GameTextForPlayer(playerid, "~y~Taser is ~g~ready", 2000, 5);
			case 1: GameTextForPlayer(playerid, "~y~ШОКЕР ~g~заряжен", 2000, 5);
			case 2: GameTextForPlayer(playerid, "~y~Taser esta ~g~listo", 2000, 5);
		}
	}
    Player[playerid][TaserReady] = true;
}

fun StartMap()
{
    static query[96];
	
	if(IsValidObject(mapGate))
	{
		DestroyObject(mapGate);
		mapGate = INVALID_OBJECT_ID;
	}

	if(IsValidObject(mapGate2))
	{
		DestroyObject(mapGate2);
		mapGate2 = INVALID_OBJECT_ID;
	}
	
	if(IsValidObject(mapFlag))
	{
		DestroyObject(mapFlag);
		mapFlag = INVALID_OBJECT_ID;
	}

   	foreach(Player, i)
   	{
   	    mysql_format(Base, query, sizeof(query), "SELECT * FROM `paydays` WHERE `acc` = '%d' AND `build`='"SERVER_BUILD"'", Player[i][pAccountID]);
		mysql_tquery(Base, query, "CheckForEXP", "i", i);
		
		for( new j = 0; j < 18; j++ )
		{
	        if(IsValidObject(box[i][j]))
			{
				DestroyObject(box[i][j]);
				Delete3DTextLabel(boxText[i][j]);
				box[i][j] = INVALID_OBJECT_ID;
			}
			box[i][j] = INVALID_OBJECT_ID;
		}
		for( new j = 0; j < 5; j++ ) TextDrawHideForPlayer(i, ServerIntro[i][j]);
		
   	    if(Player[i][eventMember] > -1) continue;
   	    if(Player[i][pInGangMatch]) continue;
   	    
   	    foreach(Player, j) PlayerShotPlayer[i][j] = false;
   	    
	   	PlayerDamageChecker[i][p_ID] = -1;
   	    IsEvacuated[i] = false;
   	    CurePlayer(i);
   	    lastHuman[i] = false;
   	    Player[i][IsBurned][0] = 0;
    	Player[i][IsBurned][1] = 0;
   	    Player[i][Poisioned] = false;
   	    TimesJumped[i] = 0;
     	PR_VirtualWorldForPlayer[i] = 0;
   	    Player[i][pAdditionalDamage] = 0.0;
   	    
   	    IsPlayerControlledBy[i] = -1;
   	    PlayerControllPlayer[i] = -1;
   	    
   	    Player[i][AbilityAffectedID] = INVALID_PLAYER_ID;
		Player[i][Tasered] = false;
   	    SetPlayerTeamEx(i, TEAM_HUMAN);
   	    SpawnZoneTimer[i] = 5;
   	    Player[i][IsPlayerAdvancedInfected] = false;
		DisablePlayerCheckpoint(i);
	 	
		PlayerDamageChecker[i][DamageGiven] = 0.0;
		
		Player[i][AntiSeeker] = false;
		Player[i][AntiFreeze] = false;
		Player[i][pWasGangAffected] = false;
		Player[i][AntiRadioctive] = false;
		Player[i][AntiBuring] = false;
		Player[i][AntiLegBreaks] = false;
		Player[i][AntiScreamer] = false;
		Player[i][Helmet] = false;
		
		KillTimer(Player[i][PoisionTimer]);
		KillTimer(Player[i][InfectedTimer]);
		KillTimer(Player[i][BleedingTimer]);
		

		p_FallingTime[i] = -1;
	    p_FallingCheck{i} = 0;
        
  		if(Player[i][Jailed] >= 1) SetPlayerTeamEx(i, TEAM_ZOMBIE);
		if(IsPlayerOnDuel[i]) SetPlayerTeamEx(i, NO_TEAM);
		if(GetPlayerTeamEx(i) > TEAM_ZOMBIE) SetPlayerTeamEx(i, GetPlayerTeamEx(i));
		
		if(Map[m_GangControll] > 0)
		{
		    if(mapid > 0) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][196], mapid, Map[m_MapName], Map[m_Author], Clan[Map[m_GangControll]][Full]);
			else SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][196], maps+1, Map[m_MapName], Map[m_Author], Clan[Map[m_GangControll]][Full]);
		}
		else
		{
			if(mapid > 0) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][33], mapid, Map[m_MapName], Map[m_Author]);
			else SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][33], maps+1, Map[m_MapName], Map[m_Author]);
			switch(Player[i][pLang])
			{
			    case 0: {
					SendClientMessage(i,-1,"{1db87f}[CASTLE]: THIS CASTLE IS BROKEN");
					SendClientMessage(i,-1,"{1db87f}[CASTLE]: THE STRENGTH OF THE FALLEN WARRIORS INCREASED");
					SendClientMessage(i,-1,"{1db87f}[CASTLE]: ZOMBIES HAVE x1.5 HP MORE");
				}
				case 1: {
				    SendClientMessage(i,-1,"{1db87f}[КРЕПОСТЬ]: ЭТА КРЕПОСТЬ РАЗРУШЕНА");
					SendClientMessage(i,-1,"{1db87f}[КРЕПОСТЬ]: СИЛА ПАВШИХ ВОИНОВ ВОЗРОСЛА");
					SendClientMessage(i,-1,"{1db87f}[КРЕПОСТЬ]: HP ЗОМБИ УВЕЛИЧЕНО В x1.5 РАЗА");
				}
				case 2: {
					SendClientMessage(i,-1,"{1db87f}[CASTILLO]: ESTE CASTILLO ESTA ROTO");
					SendClientMessage(i,-1,"{1db87f}[CASTILLO]: AUMENTO LA FUERZA DE LOS GUERREROS CAIDOS");
					SendClientMessage(i,-1,"{1db87f}[CASTILLO]: LOS ZOMBIS TIENEN x1.5 HP MAS");
				}
			}
		}
		
		//if(mapid > 0) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][33], mapid, Map[m_MapName], Map[m_Author]);
		//else SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][33], maps+1, Map[m_MapName], Map[m_Author]);

		if(Map[m_Interior] <= 0) SendClientMessage(i,-1,serverLang[Player[i][pLang]][34]);
		
		Player[i][UnlimitedBoxes] = 0;
		Player[i][LegBreak] = false;
		Player[i][Blidness] = 0;
		Player[i][aDuty] = false;
		AdminVeh[i] = 0;
		if(Player[i][ZombieCount] > 3) Player[i][ZombieCount] = 0;
		if(IsSpecing[i] && Player[i][pAdmin] > 0)
    	{
    	    TogglePlayerSpectating(i, 0);
        	IsSpecing[i] = false;
			IsBeingSpeced[spectatorid[i]] = false;
			spectatorid[i] = -1;
		}
		IsSpecing[i] = false;
   	}

   	for( new i; i < 2; i++ )
   	{
   		if(NewSpawnPoints[i][0] != 0.0)
		{
	 		NewSpawnsCreators[i] = INVALID_PLAYER_ID;
	 		Delete3DTextLabel(NewSpawnPointsText[i]);
	 		NewSpawnPoints[i][0] = 0.0;
		}
	}
	
 	for( new j = 0; j < sizeof(Map[ZombieSpawnX]); j++ )
    {
        Delete3DTextLabel(SpawnPoints[j]);
    	SpawnPoints[j] = Create3DTextLabel("{FFFFFF}Zombie Spawn\ndo{FF0000} not{FFFFFF} shoot zombies here", 0xFF0000FF, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j], 50.0, 0, 1);
	}
	
	new Float:dsx = 2.5, Float:dsy = 2.5;
	for( new i = 0; i < sizeof(Merchants); i++ )
	{
	    Delete3DTextLabel(SpawnMerchants[i]);
		if(IsValidActor(Merchants[i])) DestroyActor(Merchants[i]);
	}

    for( new i = 0; i < sizeof(Merchants); i++ )
	{
	    switch(random(2))
	    {
            case 0: Merchants[i] = CreateActor(171, Map[HumanSpawnX][i]+dsx, Map[HumanSpawnY][i]+dsy, Map[HumanSpawnZ][i], float(random(360)));
            case 1: Merchants[i] = CreateActor(172, Map[HumanSpawnX][i]+dsx, Map[HumanSpawnY][i]+dsy, Map[HumanSpawnZ][i], float(random(360)));
		}
		SetActorVirtualWorld(Merchants[i], Map[m_World]);
		SetActorHealth(Merchants[i], 200.0);
		ApplyActorAnimation(Merchants[i], "DEALER", "DEALER_IDLE", 4.1, 1, 0, 0, 1, 1000);
		SpawnMerchants[i] = Create3DTextLabel("{FFFFFF}{0099ff}Merchant\n{99d6ff}Press {FFFFFF}LEFT ALT{99d6ff} to buy anti-things", 0xFF0000FF, Map[HumanSpawnX][i]+dsx, Map[HumanSpawnY][i]+dsy, Map[HumanSpawnZ][i] + 1.5, 10.0, 0, 1);
	}

   	SetZombies();
   	foreach(Player, i) StartupHuman(i);

    UnloadFilterScript(Map[m_FSMapLastName]);

    if(Map[m_GateID] > 0) mapGate = CreateObject(Map[m_GateID], Map[m_GatePos][0], Map[m_GatePos][1], Map[m_GatePos][2], Map[m_GatePos][3], Map[m_GatePos][4], Map[m_GatePos][5]);
   	if(Map[m_Gate2ID] > 0) mapGate2 = CreateObject(Map[m_Gate2ID], Map[m_Gate2Pos][0], Map[m_Gate2Pos][1], Map[m_Gate2Pos][2], Map[m_Gate2Pos][3], Map[m_Gate2Pos][4], Map[m_Gate2Pos][5]);
    if(Map[m_GangControll] > 0) mapFlag = CreateObject(11245, Map[FlagCoords][0], Map[FlagCoords][1], Map[FlagCoords][2], Map[FlagCoords][3], Map[FlagCoords][4], Map[FlagCoords][5]);
    
    Delete3DTextLabel(Map[flagText]);
	if(Map[m_GangControll] > 0) {
		new flag_str[356], gang_id = Map[m_GangControll];
		format(flag_str, sizeof(flag_str), "{FFF000}Controlled by{FFFFFF} %s (%s){FFF000}\n\n%s\n{FFFFFF}(/gang join %d)", Clan[gang_id][Full], Clan[gang_id][Short], Clan[gang_id][g_Motd], gang_id);
		Map[flagText] = Create3DTextLabel(flag_str, 0xFF0000FF, Map[FlagTextCoords][0], Map[FlagTextCoords][1], Map[FlagTextCoords][2], 300.0, Map[m_World], 0);
		printf("%f", Map[FlagTextCoords][0]);
	}
    
   	for( new i; i < MAX_PICKUPS; i++ ) DestroyPickupEx(i);

    Map[m_XPType] = 1;
	if( GetWeekDay() >= 6 && GetWeekDay() <= 7)  { Map[m_XPType] = 2; }

	/////////// TODO
	// Map[m_XPTypeVIP] = 3;
    ///////////////////////
    
    Time = MAX_MAP_TIME;

   	KillTimerEx(mapvar[0]);
	KillTimerEx(mapvar[1]);
	KillTimerEx(mapvar[2]);

    mapvar[0] = SetTimer("OnMapUpdate", MAX_MAPUPDATE_TIME, true);
	mapvar[1] = SetTimer("OnMapBalance", MAX_BALANCERUPDATE_TIME, true);

	SetWeather(Map[m_Weather]);
	SetWorldTime(Map[m_Time]);
	FirstBlood = false;
	LastAlive = false;
	LastHumanKilled = false;
	MapStarted = true;
}

fun FunSetVip(i)
{
    if(cache_num_rows() > 0)
	{
	    new time, vip;
	   	cache_get_value_name_int(0, "VipTime", time);
	   	cache_get_value_name_int(0, "VIP", vip);
	   	if(vip >= 1)
  		{
  		    Player[i][pVipTime] = time;
		  	Player[i][pVip] = vip;
		}
		else
		{
		    Player[i][pVipTime] = 0;
		  	Player[i][pVip] = 0;
		}
	}
	else
	{
 		if(Player[i][pVip] <= 0)
 		{
	    	Player[i][pVipTime] = 0;
			Player[i][pVip] = 0;
		}
	}
	return 1;
}

fun OnMapBalance()
{
	if(playerOnline >= 2)
	{
		if(GetTeamPlayersAlive(TEAM_HUMAN) <= 0 && IsValidTimer(mapvar[0]) && GetTeamPlayersAlive(TEAM_ZOMBIE) >= 2)
		{
		    KillTimerEx(mapvar[0]);
			KillTimerEx(mapvar[1]);
			KillTimerEx(mapvar[2]);
		    foreach(Player, i)
			{
				SendClientMessage(i, -1, serverLang[Player[i][pLang]][69]);
				//if(DayliMission[i] == 7 && DayMission[i][dm_progress] < DayMission[i][dm_counter]) DayMission[i][dm_progress]++;
			}
			mapvar[2] = SetTimer("EndMap", 4000, false);
			MapStarted = false;
			foreach(Player, j)
			{
				if(GetPlayerTeamEx(j) == TEAM_ZOMBIE && !lastHuman[j] && AFK[j] <= -4 && ZombieMoveTime[j] <= 2)
				{
    				GivePlayerXP(j, 15);
				}
			}
		}
	}
}

fun Load_GetMapID()
{
    if(cache_num_rows() > 0)
 	{
 	    cache_get_value_name_int(0, "ID", maps);
	}
	
	new tmp = (mapid+1), query[64];

	if(tmp == 31) tmp = 32;
	if(tmp > maps || tmp <= 0) tmp = 0;
	
	mysql_format(Base, query, sizeof(query), "SELECT `Name` FROM `maps` WHERE `ID` = '%i'", tmp);
 	mysql_tquery(Base, query, "Load_GetMapName");
	
	return 1;
}

fun Load_GetMapName()
{
    if(cache_num_rows() > 0)
 	{
 	    new name[32], string[144];
 	    cache_get_value_name(0, "Name", name, 32);
 	    foreach(Player, i)
		{
   			for( new j = strlen(name); j > -1; j--) if(name[j] == ' ') name[j] = '_';
			switch(Player[i][pLang])
			{
			    case 0: format(string,sizeof(string), "Next_Map:_%s", name);
				case 1: format(string,sizeof(string), RusToGame("Следующая__Карта:_%s"), name);
				case 2: format(string,sizeof(string), "Siguiente_Mapa:_%s", name);
			}
			TextDrawSetString(DisplayInfo[0][i], string);
		}
	}
	return 1;
}

fun LoadMapInfo()
{
    strmid(Map[m_Author], " ", 0, 1, 1);
    if(cache_num_rows() > 0)
 	{
		new position[15][96], name[2][96], CamPos[256], flag_coords[256];
		
		if(mapid == 0) DestroyAllVehicle();

        cache_get_value_name(0, "mauthor", Map[m_Author], 25);
        if(strlen(Map[m_Author]) >= 2)
        {
            new str[48];
	        format(str, sizeof(str), "{FFFFFF}(by %s)", Map[m_Author]);
			strmid(Map[m_Author], str, 0, 48, 49);
        }
        
	    cache_get_value_name_int(0, "Time", Map[m_Time]);
	    cache_get_value_name_int(0, "Weather", Map[m_Weather]);
	    cache_get_value_name_int(0, "Interior", Map[m_Interior]);
	    cache_get_value_name_int(0, "tnx", Map[m_LastCapturedTime]);
	    
	    cache_get_value_name(0, "Filterscript", name[0], 96);
	    cache_get_value_name(0, "Name", name[1], 96);
	    cache_get_value_name(0, "flag", flag_coords, 256);
	    
	    cache_get_value_name_int(0, "GateID", Map[m_GateID]);
	    cache_get_value_name_int(0, "Gate2ID", Map[m_Gate2ID]);
	    cache_get_value_name_int(0, "GateMove", Map[m_MoveGate]);
	    cache_get_value_name_int(0, "World", Map[m_World]);
	    cache_get_value_name_int(0, "checkpoint_size", Map[m_CheckPointSize]);
        
	    cache_get_value_name_int(0, "controlled", Map[m_GangControll]);

	    cache_get_value_name_float(0, "GateSpeed", Map[m_GateSpeed]);

	    cache_get_value_name(0, "FHS", position[0], 96);
	    cache_get_value_name(0, "SHS", position[1], 96);
	    cache_get_value_name(0, "THS", position[2], 96);
	    cache_get_value_name(0, "VHS", position[9], 96);
	    cache_get_value_name(0, "YHS", position[11], 96);

	    cache_get_value_name(0, "FZS", position[3], 96);
	    cache_get_value_name(0, "SZS", position[4], 96);
	    cache_get_value_name(0, "TZS", position[5], 96);
	    cache_get_value_name(0, "VZS", position[10], 96);
	    cache_get_value_name(0, "YZS", position[12], 96);

	    cache_get_value_name(0, "Camera", CamPos);

	    cache_get_value_name(0, "GatePos", position[6], 96);
	    cache_get_value_name(0, "GatePosTo", position[7], 96);

	    cache_get_value_name(0, "Checkpoint", position[8], 96);
	    cache_get_value_name_int(0, "AllowWater", Map[m_AllowWater]);

	    cache_get_value_name(0, "Gate2Pos", position[13], 96);
	    cache_get_value_name(0, "Gate2PosTo", position[14], 96);
	    
        sscanf(flag_coords, "p<,>fffffffff", Map[FlagCoords][0], Map[FlagCoords][1], Map[FlagCoords][2], Map[FlagCoords][3], Map[FlagCoords][4], Map[FlagCoords][5], Map[FlagTextCoords][0], Map[FlagTextCoords][1], Map[FlagTextCoords][2]);
		
	    sscanf(position[0], "p<,>fff", Map[HumanSpawnX][0], Map[HumanSpawnY][0], Map[HumanSpawnZ][0]);
	    sscanf(position[1], "p<,>fff", Map[HumanSpawnX][1], Map[HumanSpawnY][1], Map[HumanSpawnZ][1]);
	    sscanf(position[2], "p<,>fff", Map[HumanSpawnX][2], Map[HumanSpawnY][2], Map[HumanSpawnZ][2]);
	    sscanf(position[9], "p<,>fff", Map[HumanSpawnX][3], Map[HumanSpawnY][3], Map[HumanSpawnZ][3]);
	    sscanf(position[11], "p<,>fff", Map[HumanSpawnX][4], Map[HumanSpawnY][4], Map[HumanSpawnZ][4]);

	    sscanf(CamPos, "p<,>ffffff", Map[m_CamPos][0], Map[m_CamPos][1], Map[m_CamPos][2], Map[m_CamPos][3], Map[m_CamPos][4], Map[m_CamPos][5]);

	    sscanf(position[3], "p<,>fff", Map[ZombieSpawnX][0], Map[ZombieSpawnY][0], Map[ZombieSpawnZ][0]);
	    sscanf(position[4], "p<,>fff", Map[ZombieSpawnX][1], Map[ZombieSpawnY][1], Map[ZombieSpawnZ][1]);
	    sscanf(position[5], "p<,>fff", Map[ZombieSpawnX][2], Map[ZombieSpawnY][2], Map[ZombieSpawnZ][2]);
	    sscanf(position[10], "p<,>fff", Map[ZombieSpawnX][3], Map[ZombieSpawnY][3], Map[ZombieSpawnZ][3]);
	    sscanf(position[12], "p<,>fff", Map[ZombieSpawnX][4], Map[ZombieSpawnY][4], Map[ZombieSpawnZ][4]);

	    sscanf(position[6], "p<,>ffffff",Map[m_GatePos][0], Map[m_GatePos][1], Map[m_GatePos][2], Map[m_GatePos][3], Map[m_GatePos][4], Map[m_GatePos][5]);
	    sscanf(position[7], "p<,>ffffff", Map[m_GatePosTo][0], Map[m_GatePosTo][1], Map[m_GatePosTo][2], Map[m_GatePosTo][3], Map[m_GatePosTo][4], Map[m_GatePosTo][5]);

	    sscanf(position[13], "p<,>ffffff", Map[m_Gate2Pos][0], Map[m_Gate2Pos][1], Map[m_Gate2Pos][2], Map[m_Gate2Pos][3], Map[m_Gate2Pos][4], Map[m_Gate2Pos][5]);
	    sscanf(position[14], "p<,>ffffff", Map[m_Gate2PosTo][0], Map[m_Gate2PosTo][1], Map[m_Gate2PosTo][2], Map[m_Gate2PosTo][3], Map[m_Gate2PosTo][4], Map[m_Gate2PosTo][5]);

		sscanf(position[8], "p<,>fff", Map[m_Check][0], Map[m_Check][1], Map[m_Check][2]);

		new mpname[96];
		strmid(Map[m_MapName], name[1], false, strlen(name[1]), 96);
		format(mpname, sizeof(mpname), "mapname %s", Map[m_MapName]);
		SendRconCommand(mpname);

		strmid(Map[m_FSMapLastName], Map[m_FSMapName], 0, 128, 128);
		strmid(Map[m_FSMapName], name[0], 0, 128, 128);

		if(mapid < maps) { mapid++; } else { mapid = 0; }
		
		if(!Map[m_IsStarted])
		{
			StartMap();
			Map[m_IsStarted] = true;
		}

		/// Load map
		
		new lan_name[64];
		format(lan_name, sizeof(lan_name), "language %s", Map[m_MapName]);
		SendRconCommand(lan_name);
		
		LoadFilterScript(Map[m_FSMapName]);
		already_skipped = false;
		
 	}
 	return 1;
}

fun LoadFilterScript(filename[])
{
	new string[128];
	format(string, sizeof(string), "loadfs %s", filename);
	SendRconCommand(string);
	
	//printf("Loaded in %d ms!", GetTickCount() - time);
	
	return 1;
}

stock LoadNewMap()
{
	if(mapid == 31) mapid = 32;
	if((mapid-1) > maps || mapid <= 0) mapid = 0;

	new query[200];
 	mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `maps` ORDER BY `ID` DESC LIMIT 1");
 	mysql_tquery(Base, query, "Load_GetMapID");
	
 	mysql_format(Base, query, sizeof(query), "SELECT maps.*, IFNULL((SELECT users.Name mathor FROM users JOIN maps ON maps.author = users.ID WHERE maps.ID = %i),'') mauthor FROM maps WHERE maps.ID = %i", mapid, mapid);
 	mysql_tquery(Base, query, "LoadMapInfo");
 	
 	current_map = mapid;
}

fun EndMap()
{
	new j;
    foreach(Player,i)
	{
	    if(!Player[i][pInGangMatch] && !Player[i][aDuty] && !IsPlayerOnDuel[i] && !IsPlayerInAnyVehicle(i) && !IsEvacuated[i] && Player[i][Jailed] <= 0 && Player[i][eventMember] <= -1)
	    {
     		for( j = 0; j < 5; j++ ) TextDrawHideForPlayer(i, ServerIntro[i][j]);

		    switch(Player[i][pLang])
		    {
		        case 0:
		        {
		            TextDrawSetString(ServerIntro[i][0], "welcome to the");
		            TextDrawSetString(ServerIntro[i][1], "Zombie Apocalypse");
	                TextDrawSetString(ServerIntro[i][2], "server");
	                TextDrawSetString(ServerIntro[i][3], "Add to favorites <3");
	                TextDrawSetString(ServerIntro[i][4], "Type /help for more information~n~Type /rules for the server rules");
		        }
		        case 1:
		        {
		            TextDrawSetString(ServerIntro[i][0], RusToGame("добро п_ожаловать_в__мир"));
		            TextDrawSetString(ServerIntro[i][1], RusToGame("ЗОМБИ АП_ОКАЛ_ИП_СИСА"));
	                TextDrawSetString(ServerIntro[i][2], " ");
	                TextDrawSetString(ServerIntro[i][3], RusToGame("Доба_в__ьте_в__закладки <3"));
	                TextDrawSetString(ServerIntro[i][4], RusToGame("/help - помощь~n~/rules - правила сервера"));
		        }
		        case 2:
		        {
		            TextDrawSetString(ServerIntro[i][0], "Bienvenido a la");
		            TextDrawSetString(ServerIntro[i][1], "Apocalipsis Zombie");
	                TextDrawSetString(ServerIntro[i][2], "servidor");
	                TextDrawSetString(ServerIntro[i][3], "Agregar a los favoritos <3");
	                TextDrawSetString(ServerIntro[i][4], "/help para mбs informaciуn~n~/rules para las reglas del servidor");
		        }
		        default:
		        {
		            TextDrawSetString(ServerIntro[i][0], "welcome to the");
		            TextDrawSetString(ServerIntro[i][1], "Zombie Apocalypse");
	                TextDrawSetString(ServerIntro[i][2], "server");
	                TextDrawSetString(ServerIntro[i][3], "Add to favorites <3");
	                TextDrawSetString(ServerIntro[i][4], "Type /help for more information~n~Type /rules for the server rules");
		        }
		    }

	    	for( j = 0; j < 5; j++ ) TextDrawShowForPlayer(i, ServerIntro[i][j]);
			
	        if(Map[m_CamPos][0] != 0.0)
	        {
	        	SetPlayerCameraPos(i, Map[m_CamPos][0], Map[m_CamPos][1], Map[m_CamPos][2]);
	       		SetPlayerCameraLookAt(i, Map[m_CamPos][3], Map[m_CamPos][4], Map[m_CamPos][5]);
	    	}
		}
		Player[i][ReinPos][0] = 0.0;
		Player[i][ReinPos][1] = 0.0;
		Player[i][ReinPos][2] = 0.0;
		
		if(AdminVeh[i] > -1)
		{
			DestroyVehicle(AdminVeh[i]);
			AdminVeh[i] = -1;
		}
		if(IsPlayerInAnyVehicle(i) && Player[i][eventMember] <= -1)
		{
		    DestroyVehicle(GetPlayerVehicleID(i));
			//RemovePlayerFromVehicle(i);
		}
	}
	LoadNewMap();
    KillTimerEx(mapvar[2]);
    foreach(Player, i)
	{
		SendClientMessage(i, -1, serverLang[Player[i][pLang]][58]);
		switch(Player[i][pLang])
		{
		    case 0: GameTextForPlayer(i, "~r~ROUND OVER~n~~w~STARTING NEW ROUND...", 5000, 5);
		    case 1: GameTextForPlayer(i, RusToGame("~r~КОНЕЦ РАУНДА~n~~w~ПОДГОТОВКА НОВОГО..."), 5000, 5);
		    case 2: GameTextForPlayer(i, "~r~REDONDEAR~n~~w~COMENZANDO NUEVA RONDA...", 5000, 5);
		}
	}
	SetTimer("StartMap", 8000, false);
	MapStarted = false;
	return 1;
}

fun OnMapUpdate()
{
	Time -= 5;
	
	static tm[64], query[96];
	format(tm,sizeof(tm), "%d", Time);
	TextDrawSetString(TimeLeft, tm);
	
	if(Time == 60)
	{
	 	mysql_format(Base, query, sizeof(query), "SELECT `ID` FROM `maps` ORDER BY `ID` DESC LIMIT 1");
		mysql_tquery(Base, query, "GetTheNextMap");
 	}
	
	foreach(Player, i)
	{
	    if(SpawnZoneTimer[i] <= 4)
	    {
	        static j, bool:c = false;
		    for( j = 0; j < sizeof(Map[ZombieSpawnX]); j++ )
			{
				if(IsPlayerInRangeOfPoint(i, 25.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j]))
				{
				    c = true;
					break;
				}
			}
			if(!c) SpawnZoneTimer[i]++;
   		}
   		
 		if(OldPos[i][3] >= 1.0)  OldPos[i][3] -= 1.0;
 		
 		if(GetPlayerTeamEx(i) == TEAM_ZOMBIE && Player[i][pClass][TEAM_ZOMBIE+1] == REGENERATOR)
 		{
	    	new Float:h;
     		GetPlayerHealth(i, h);
     		if(h <= 90.0) SetPlayerHealthAC(i, h + 10.0);
       	}
        
		Player[i][TimesDamage] = 0;
		if(CBugTimes[i] >= 1) CBugTimes[i]--;
		
		if(TimesJumped[i] > 0) TimesJumped[i]--;
		if(JumpTimes[i] > 0) JumpTimes[i]--;
		
		//if(MaybeBH[i] > 0) MaybeBH[i]--;
		Player[i][GunJammerAttack] = false;
    	Player[i][HeroField] = false;
	}
	
	if(Time <= 0) TextDrawSetString(TimeLeft,"...");
	
	if(Time == 0)
	{
		if(IsValidTimer(mapvar[2])) KillTimerEx(mapvar[2]);
	    if(Map[m_MoveGate] > 0)
		{
			MoveObject(mapGate, Map[m_GatePosTo][0], Map[m_GatePosTo][1], Map[m_GatePosTo][2], Map[m_GateSpeed], Map[m_GatePosTo][3], Map[m_GatePosTo][4], Map[m_GatePosTo][5]);
        	if(mapGate2 > 0) MoveObject(mapGate2, Map[m_Gate2PosTo][0], Map[m_Gate2PosTo][1], Map[m_Gate2PosTo][2], Map[m_Gate2PosTo], Map[m_Gate2PosTo][3], Map[m_Gate2PosTo][4], Map[m_Gate2PosTo][5]);
		}
		
		TextDrawSetString(TimeLeft,"...");
		SetTimer("ShowCheckpoint", MAX_SHOW_CP_TIME, false);
		foreach(Player, i)
		{
		    SendClientMessage(i,-1, serverLang[Player[i][pLang]][37]);
			SendClientMessage(i,-1, serverLang[Player[i][pLang]][38]);
		}
	}
	return 1;
}

fun ShowCheckpoint()
{
	foreach(Player,i) SetPlayerCheckpoint(i,Map[m_Check][0],Map[m_Check][1],Map[m_Check][2], Map[m_CheckPointSize]);
	mapvar[2] = SetTimer("EndMap", MAX_END_TIME, false);
	return 1;
}

stock DestroyAllVehicle()
{
    for(new i; i < MAX_VEHICLES; i++)
	{
    	DestroyVehicle(i);
	}
	return 1;
}

stock CheckToStartMap()
{
    if(!Map[m_IsStarted]) LoadNewMap();
}

GetWeekDay(day=0, month=0, year=0)
{
	if(!day) getdate(year, month, day);
    new j, e;
  	if (month <= 2) { month += 12; --year; }
  	j = year % 100;
  	e = year / 100;
  	switch ((day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7)
  	{
    	case 0: return 6;
    	case 1: return 7;
    	case 2: return 1;
    	case 3: return 2;
    	case 4: return 3;
    	case 5: return 4;
    	case 6: return 5;
  	}
  	return 0;
}

stock EmptyMessage(const string[])
{
    for(new i; string[i] != 0x0; i++)
    {
        switch(string[i])
        {
            case 0x20: continue;
            default: return 0;
        }
    }
    return 1;
}

stock ShowDisplayInfo(playerid)
{
    TextDrawShowForPlayer(playerid, TimeLeft);
    TextDrawShowForPlayer(playerid, AliveInfo[playerid]);
    TextDrawShowForPlayer(playerid, UntillEvac[0][playerid]);
	TextDrawShowForPlayer(playerid, UntillEvac[1][playerid]);
	
	TextDrawShowForPlayer(playerid, DisplayInfo[0][playerid]);
	TextDrawShowForPlayer(playerid, DisplayInfo[1][playerid]);
}

stock UpdateAliveInfo(playerid)
{
	new string[160];
	switch(Player[playerid][pLang])
	{
	    case 0:
		{
			format(string,sizeof(string),"~r~zombies: %d~n~~w~humans: %d",GetTeamPlayersAlive(TEAM_ZOMBIE),GetTeamPlayersAlive(TEAM_HUMAN));
            TextDrawSetString(UntillEvac[1][playerid], "UNTIL EVAC");
		}
		case 1:
		{
			format(string,sizeof(string),RusToGame("~r~зомби: %d~n~~w~люди: %d"),GetTeamPlayersAlive(TEAM_ZOMBIE),GetTeamPlayersAlive(TEAM_HUMAN));
            TextDrawSetString(UntillEvac[1][playerid], RusToGame("В_РЕМЯ"));
		}
		case 2:
		{
			format(string,sizeof(string),"~r~zombies: %d~n~~w~humanos: %d",GetTeamPlayersAlive(TEAM_ZOMBIE),GetTeamPlayersAlive(TEAM_HUMAN));
            TextDrawSetString(UntillEvac[1][playerid], "HASTA EVAC");
		}
	}
	TextDrawSetString(AliveInfo[playerid], string);
	
	if(GetUnlockedSlot(Player[playerid][pSettings], PS_FPS) == 1)
	{
	    TextDrawHideForPlayer(playerid, FPS_Info[playerid]);
	    format(string,sizeof(string),"~y~FPS:_~w~%d", GetPlayerFPS(playerid));
	    TextDrawSetString(FPS_Info[playerid], string);
	    TextDrawShowForPlayer(playerid, FPS_Info[playerid]);
	}
	
	return 1;
}

fun GetTeamPlayersAlive(teamid)
{
    new count;
    foreach(Player, i)
    {
        if(GetPlayerTeamEx(i) == teamid) count++;
    }
    return count;
}

stock PlayerKick(playerid, const reason[] = "") {
	if(strlen(reason)) {
	   	new y, m, d, h, i, s, body[866];
		TimestampToDate(gettime(), y, m, d, h, i, s, 3);
	    new stats[2][401];
	    GetNetworkStats(stats[1], sizeof(stats[]));
	    GetPlayerNetworkStats(playerid, stats[0], sizeof(stats[]));
		format(body, sizeof(body), "\t\t\n\n%02d:%02d %02d/%02d/%04d\n\n%s\n%s\n\t\t", h, i, m, d, y, stats[1], stats[0]);
		ShowPlayerDialog(playerid, DIALOG_INFO, DIALOG_STYLE_MSGBOX, "(N)etwork (I)nformation", body, "Close", "");
	}
	SetTimerEx("KickPL",100,0,"i", playerid);
}

fun KickPL(playerid) { Kick(playerid); }

stock StartupHuman(playerid)
{
    if(InGangHouse[playerid]) return 0;
	if(IsPlayerOnDuel[playerid]) return 0;
	if(Player[playerid][pInGangMatch]) return 0;
	if(Player[playerid][Jailed] >= 1) return 0;
	if(Player[playerid][eventMember] > -1) return 0;
    if(WasHumanTimes[playerid] > 3 && VipTeamSelected[playerid] != TEAM_HUMAN)
    {
        switch(Player[playerid][pLang])
		{
			case 0:
			{
				//SendClientMessage(playerid, -1, "{FFF000}>> You were chosen as a zombie due to inactive playing, go and kill all the humans");
                SendClientMessage(playerid, -1, "{FFF000}>> You should help your team, not stand most of the time");
	   			SendClientMessage(playerid, -1, "{FFF000}>> Use your ability to make it faster (LEFT ALT)");
                //SendClientMessageFormat(playerid, -1, "{FFF000}>> Team Balance: Zombie: %d times / Human: %d times", WasZombieTimes[playerid], WasHumanTimes[playerid]);
			}
			case 1:
			{
				//SendClientMessage(playerid, -1, "{FFF000}>> Вы были выбраны за команду зомби из за неактивной игры, идите и убейте всех людей!");
                SendClientMessage(playerid, -1, "{FFF000}>> Вы должны помогать своей команде, а не стоять большую часть времени");
	   			SendClientMessage(playerid, -1, "{FFF000}>> Используйте свою способность, чтобы сделать это быстрее (ЛЕВЫЙ АЛЬТ)");
                //SendClientMessageFormat(playerid, -1, "{FFF000}>> Баланс Команд: Вы были Зомби: %d раз / Человеком: %d раз", WasZombieTimes[playerid], WasHumanTimes[playerid]);
			}
			case 2:
			{
				//SendClientMessage(playerid, -1, "{FFF000}>> Fuiste elegido como zombie debido a la inactividad jugando, ve y mata a todos los humanos");
                SendClientMessage(playerid, -1, "{FFF000}>> Debes ayudar a tu equipo, no pararte la mayor parte del tiempo");
	   			SendClientMessage(playerid, -1, "{FFF000}>> Usa tu habilidad para hacerlo mбs rбpido (IZQUIERDA ALT)");
	   			//SendClientMessageFormat(playerid, -1, "{FFF000}>> Team Balance: Zombie: %d times / Human: %d times", WasZombieTimes[playerid], WasHumanTimes[playerid]);
			}
		}
		setupZombie(playerid);
		SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(playerid);
		
		WasZombieTimes[playerid] = 0;
		WasHumanTimes[playerid] = 0;
        return 0;
    }
	if(!Player[playerid][pLogged] || VipTeamSelected[playerid] == TEAM_ZOMBIE) {
		SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
		new p = random(sizeof(Map[ZombieSpawnX])), Float:dist = (float(1+random(19))/100.0);
		SetPlayerPosAC(playerid, Map[ZombieSpawnX][p]+dist, Map[ZombieSpawnY][p]+dist, Map[ZombieSpawnZ][p]);
		SetCameraBehindPlayer(playerid);
		// printf("THIS CALLED");
	}
	if(GetPlayerTeamEx(playerid) != TEAM_ZOMBIE && Player[playerid][pLogged])
	{
	    switch(Player[playerid][pLang])
	    {
	    	case 0: GameTextForPlayer(playerid, "~r~TRY TO STAY~n~~w~ALIVE", 2000, 6);
	    	case 1: GameTextForPlayer(playerid, RusToGame("~r~ПОПЫТАЙТЕСЬ~n~~w~ВЫЖИТЬ"), 2000, 6);
	    	case 2: GameTextForPlayer(playerid, "~r~INTENTA PERMANECER~n~~w~VIVO", 2000, 6);
		}
 	   	setupHuman(playerid);
 	   	SetSpawnInfo(playerid,TEAM_HUMAN,252,Map[HumanSpawnX][0],Map[HumanSpawnY][0],Map[HumanSpawnZ][0],0.0,0,0,0,0,0,0);
		SpawnPlayer(playerid);
		
		WasZombieTimes[playerid] = 0;
		WasHumanTimes[playerid]++;
		ZombieMoveTime[playerid] = 0;
 	}
 	return 1;
}

stock SetZombies(bool:ignore_selection = false)
{
	new Zmbsn;
	if(playerOnline >= 2) Zmbsn = floor(playerOnline / 2);
	if(playerOnline >= 6) Zmbsn = ceil(playerOnline / 3);
	if(playerOnline >= 21) Zmbsn = ceil(playerOnline / 4);
	
    if(Zmbsn >= 1)
    {
        new pl, itterations = 0, i;
	    for(i = 0; i < Zmbsn; i++)
		{
		    search_player:
		    if(itterations >= (Zmbsn*12)) break;
		    itterations++;
		    pl = Iter_Random(Players);
		    if(!Player[pl][pLogged]) goto search_player;
		    if(IsPlayerOnDuel[pl]) goto search_player;
		    if(Player[pl][pInGangMatch]) goto search_player;
		    if(Player[pl][Jailed] >= 1) goto search_player;
			if(GetPlayerTeamEx(pl) == TEAM_ZOMBIE) goto search_player;
			if(VipTeamSelected[pl] == TEAM_HUMAN) goto search_player;
			if(Player[pl][eventMember] > -1) goto search_player;
			if(WasZombieTimes[pl] > WasHumanTimes[pl] && WasZombieTimes[pl] > 3 && !ignore_selection) goto search_player;
			
	 		printf("Setting teams %d of %d", i+1, Zmbsn);
	 		setupZombie(pl);
	 		SetSpawnInfo(pl,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
	       	SpawnPlayer(pl);
			
	       	if(VipTeamSelected[pl] == -1) WasZombieTimes[pl]++;
	       	WasHumanTimes[pl] = 0;
	       	
	       	switch(Player[pl][pLang])
			{
				case 0:
				{
					SendClientMessage(pl, -1, "{FFF000}>> You were chosen as a zombie go and kill all the humans");
	       			SendClientMessage(pl, -1, "{FFF000}>> Use your ability to make it faster (LEFT ALT)");
				}
				case 1:
				{
					SendClientMessage(pl, -1, "{FFF000}>> Вы были выбраны за команду зомби, идите и убейте всех людей!");
	       			SendClientMessage(pl, -1, "{FFF000}>> Используйте свою способность, чтобы сделать это быстрее (ЛЕВЫЙ АЛЬТ)");
				}
				case 2:
				{
					SendClientMessage(pl, -1, "{FFF000}>> Fuiste elegido como zombie, ve y mata a todos los humanos");
	       			SendClientMessage(pl, -1, "{FFF000}>> Usa tu habilidad para hacerlo mбs rбpido (IZQUIERDA ALT)");
				}
			}
		}
	}

	if(!ignore_selection) {
	    new zcount;
		foreach(Player, i) {
		    if(GetPlayerTeamEx(i) == TEAM_ZOMBIE) zcount++;
		}
		if(zcount < Zmbsn) SetZombies(true);
	}
	
	return 1;
}

stock ceil(Float:num) return floatround(num, floatround_ceil);
stock floor(Float:num) return floatround(num, floatround_floor);

stock RusToGame(const string[])
{
    new result[128];
    for(new i; i < 128; i++)
    {
    	switch(string[i])
     	{
      		case 'а':result[i] = 'a';
      		case 'А':result[i] = 'A';
      		case 'б':result[i] = '—';
	      	case 'Б':result[i] = 'Ђ';
	      	case 'в':result[i] = 'ў';
	      	case 'В':result[i] = '‹';
	      	case 'г':result[i] = '™';
	      	case 'Г':result[i] = '‚';
	      	case 'д':result[i] = 'љ';
	      	case 'Д':result[i] = 'ѓ';
	      	case 'е':result[i] = 'e';
	      	case 'Е':result[i] = 'E';
	      	case 'ё':result[i] = 'e';
	      	case 'Ё':result[i] = 'E';
	      	case 'ж':result[i] = '›';
	      	case 'Ж':result[i] = '„';
	      	case 'з':result[i] = 'џ';
	      	case 'З':result[i] = '€';
	      	case 'и':result[i] = 'њ';
	      	case 'И':result[i] = '…';
	      	case 'й':result[i] = 'ќ';
	      	case 'Й':result[i] = '…';
	      	case 'к':result[i] = 'k';
	      	case 'К':result[i] = 'K';
	      	case 'л':result[i] = 'ћ';
	      	case 'Л':result[i] = '‡';
	      	case 'м':result[i] = 'Ї';
	      	case 'М':result[i] = 'M';
	      	case 'н':result[i] = '®';
	      	case 'Н':result[i] = 'H';
	      	case 'о':result[i] = 'o';
	      	case 'О':result[i] = 'O';
	      	case 'п':result[i] = 'Ј';
	      	case 'П':result[i] = 'Њ';
	      	case 'р':result[i] = 'p';
	      	case 'Р':result[i] = 'P';
	      	case 'с':result[i] = 'c';
	      	case 'С':result[i] = 'C';
	      	case 'т':result[i] = '¦';
	      	case 'Т':result[i] = 'Џ';
	      	case 'у':result[i] = 'y';
	      	case 'У':result[i] = 'Y';
	      	case 'ф':result[i] = '?';
	      	case 'Ф':result[i] = 'Ѓ';
	      	case 'х':result[i] = 'x';
	      	case 'Х':result[i] = 'X';
	      	case 'ц':result[i] = '$';
	      	case 'Ц':result[i] = '‰';
	      	case 'ч':result[i] = '¤';
	      	case 'Ч':result[i] = 'Ќ';
	      	case 'ш':result[i] = 'Ґ';
	      	case 'Ш':result[i] = 'Ћ';
	      	case 'щ':result[i] = 'Ў';
	      	case 'Щ':result[i] = 'Љ';
	      	case 'ь':result[i] = '©';
	      	case 'Ь':result[i] = '’';
	      	case 'ъ':result[i] = 'ђ';
	      	case 'Ъ':result[i] = '§';
	      	case 'ы':result[i] = 'Ё';
	      	case 'Ы':result[i] = '‘';
	      	case 'э':result[i] = 'Є';
	      	case 'Э':result[i] = '“';
	      	case 'ю':result[i] = '«';
	      	case 'Ю':result[i] = '”';
	      	case 'я':result[i] = '¬';
	      	case 'Я':result[i] = '•';
   			default:result[i]=string[i];
     	}
	}
    return result;
}

stock AdminOnline()
{
	foreach(Player, i)
	{
	    if(Player[i][pAdmin] > 0 && Player[i][pLogged] && FakeData[i][6] <= 0 && AFK[i] <= -3) return 1;
	}
	return 0;
}

stock HighAdminOnline()
{
    foreach(Player, i)
	{
	    if(Player[i][pAdmin] >= 3 && AFK[i] <= -3) return 1;
	}
	return 0;
}

stock SendGangMessage(playerid, const message[])
{
	foreach(Player, i)
	{
		if(Player[i][pClan] == Player[playerid][pClan])
		{
	 	    SendClientMessage(i, -1, message);
	 	}
 	}
 	return 1;
}

stock DestroyPickupEx(pickupid, bool:ByForce = false)
{
	if(IsValidPickup(pickupid))
	{
	    if(!ByForce)
	    {
			if(Pickups[pickupid][epi_PickCanDestroy])
			{
				DestroyPickup(pickupid);
				Pickups[pickupid][epi_PickCanDestroy] = true;
				Pickups[pickupid][e_ID] = -1;
    			Pickups[pickupid][e_Time] = 0;
    			Pickups[pickupid][e_ForPlayer] = -1;
			}
		}
		else
		{
		    DestroyPickup(pickupid);
		    Pickups[pickupid][epi_PickCanDestroy] = true;
			Pickups[pickupid][e_ID] = -1;
		    Pickups[pickupid][e_Time] = 0;
		    Pickups[pickupid][e_ForPlayer] = -1;
		}
	}
}

stock IsValidPickup(pickupid)
{
	return (pickupid > -1 && pickupid <= 4093);
}

stock CreatePickupMeat(model, type, Float:X, Float:Y, Float:Z, virtualworld = 0, forPlayer = -1, playerid = -1)
{
    new a = CreatePickup(model, type, X, Y, Z, virtualworld);
    Pickups[a][e_ID] = a;
    Pickups[a][e_Time] = gettime()+15;
    Pickups[a][e_ForPlayer] = forPlayer;
    Pickups[a][e_ItemID] = model;
    Pickups[a][epi_PickCanDestroy] = true;
    Pickups[a][e_DropperID] = playerid;
    
    return a;
}

stock CreatePickupEx(pickupid, type, Float: x, Float: y, Float: z, virtual, bool:canDelete = true)
{
    new ID = CreatePickup(pickupid, type, x, y, z, virtual);
	if(IsValidPickup(ID))
	{
	    Pickups[ID][e_ID] = ID;
    	Pickups[ID][e_Time] = 0;
    	Pickups[ID][e_ForPlayer] = -1;
    	Pickups[ID][e_ItemID] = -1;
		Pickups[ID][epi_PickCanDestroy] = canDelete;
		Pickups[ID][e_DropperID] = -1;
	}
	return ID;
}

stock IsPlayerInWater(playerid)
{
    new animlib[32],tmp[32];
    GetAnimationName(GetPlayerAnimationIndex(playerid),animlib,32,tmp,32);
    if((!strcmp(animlib, "SWIM") || strfind(tmp, "swim", true) != -1) && !IsPlayerInAnyVehicle(playerid) ) return true;
    return false;
}

stock AnimCmp(playerid, const animname[])
{
    new animlib[32],tmp[32];
    GetAnimationName(GetPlayerAnimationIndex(playerid),animlib,32,tmp,32);
    if(strfind(animlib, tmp, true) != -1 || strfind(animlib, animname, true) != -1) return 1;
    return 0;
}

stock GetPlayerSpeed(playerid)
{
    new Float:ST[4];
    if(IsPlayerInAnyVehicle(playerid))GetVehicleVelocity(GetPlayerVehicleID(playerid),ST[0],ST[1],ST[2]);
    else GetPlayerVelocity(playerid,ST[0],ST[1],ST[2]);
    ST[3] = floatsqroot(floatpower(floatabs(ST[0]), 2.0) + floatpower(floatabs(ST[1]), 2.0) + floatpower(floatabs(ST[2]), 2.0)) * 150.0;
    return floatround(ST[3]);
}

stock OnPlayerCheckForSpeed(player_id)
{
    new
        vehicle_id = GetPlayerVehicleID(player_id),
        Float: pos_x,
        Float: pos_y,
        Float: pos_z;
    switch(vehicle_id)
    {
        case 0: GetPlayerVelocity(player_id, pos_x, pos_y, pos_z);
        default: GetVehicleVelocity(vehicle_id, pos_x, pos_y, pos_z);
    }
    return floatround(VectorSize(pos_x, pos_y, pos_z) * 100.0);
}

ReColor(text[])
{
    new
        pos = -1;
    while ((pos = strfind(text, "(", false, pos + 1)) != -1)
    {
        new
            c = pos + 1,
            n = 0,
            ch;
        while ((ch = text[c]) && n != 6)
        {
            if (!('a' <= ch <= 'f' || 'A' <= ch <= 'F' || '0' <= ch <= '9'))
            {
                break;
            }
            ++c;
            ++n;
        }
        if (n == 6 && ch == ')')
        {
            text[pos] = '{';
            text[c] = '}';
        }
    }
    //return 1;
}

stock SignCreate(playerid)
{
	//SendClientMessageFormat(playerid, -1, "%s", Name(playerid));
	CallRemoteFunction("GetUserAccountID", "ii", playerid, Player[playerid][pAccountID]);
	
	new hash[65], query[264], timedate[24];
	format(timedate, sizeof(timedate), "%d", gettime()+getdate()+Player[playerid][pAccountID]);
	SHA256_PassHash(timedate, "u37!39UM+t3;-PTohhHUEm?9A4}.mNu3fa4n~MoA93F77K,;7[!9WFpRVy@c3X@9T{gTdjC7Lk_3q#34A*E}3%e4№p4Xu3zL9,~u-F37@fu*%tM4q{_MtF9=9$sJHd(7", hash, sizeof(hash));
    mysql_format(Base, query, sizeof(query), "INSERT INTO `signs` (`Sign`,`Name`,`EXP`,`VIP`,`Admin`,`Rank`,`Balance`,`build`) VALUES ('%e','%e','%d','%d','%d','%d','%f','"SERVER_BUILD"')", hash,
	Player[playerid][UserName],
	Player[playerid][pXP],
	Player[playerid][pVip],
	Player[playerid][pAdmin],
	Player[playerid][pRank],
    Player[playerid][pBalance]);
	mysql_tquery(Base, query, "", "", "");
	strmid(Player[playerid][pSign], hash, 0, 16, 17);
}

stock resetVars(playerid)
{
    for( new i = 0; i < MAX_PLAYERS; i++ ) HeadshotsInCount[playerid][i] = 0;
    SuspectForAIM[playerid] = false;
    
    KillTimer(Player[playerid][PoisionTimer]);
	KillTimer(Player[playerid][InfectedTimer]);
	KillTimer(Player[playerid][BleedingTimer]);

    HoursForAch[playerid][0] = -1;
    HoursForAch[playerid][1] = -1;
    InGangHouse[playerid] = false;
    
	for( new i = 0; i < MAX_PLAYERS; i++ ) {
	    if(strlen(UserPrivateChannelID[playerid][i]) >= 3) {
	        new DCC_Channel: ToSent = DCC_FindChannelById(UserPrivateChannelID[playerid][i]);
    		DCC_SendChannelMessageEx(ToSent, "```yaml\nLost connection, player logged out\n```");
			DCC_DeleteChannel(DCC_FindChannelById(UserPrivateChannelID[playerid][i]));
		}
        UserPrivateChannelID[playerid][i] = "\0";
        UserPrivateChannelUserIDs[playerid][i] = "\0";
        UserPrivateChannelUserNames[playerid][i] = "\0";
	}
    UserCreatedChannels[playerid] = 0;

    Player[playerid][pInGangMatch] = false;
	Achievements[playerid][ach_CONQUEROR] = 0;
	Achievements[playerid][ach_USED_ABILITY] = 0;
	Achievements[playerid][ach_SURVIVED] = 0;
	Achievements[playerid][ach_KILLED_HUMANS] = 0;
	Player[playerid][pAdditionalDamage] = 0.0;
	Achievements[playerid][ach_KILLED_ZOMBIE] = 0;
	Achievements[playerid][ach_KILLED_PLAYERS] = 0;
	Achievements[playerid][ach_COLLECTED_MEATS] = 0;
	Achievements[playerid][ach_ACHIEVED_KILLSTREAK] = 0;
	Achievements[playerid][ach_DUELS_WIN] = 0;
	Achievements[playerid][ach_SHOCK] = 0;
	Achievements[playerid][ach_DIED_TIMES] = 0;
	Achievements[playerid][ach_REPORTED_TIMES] = 0;
	Achievements[playerid][ach_SHOP_TIMES] = 0;
	Achievements[playerid][ach_VOID] = 0;
	Achievements[playerid][ach_WINNER] = 0;
	Achievements[playerid][ach_HOURS_PLAYED] = 0;
	Achievements[playerid][ach_PULSATION] = 0;
	Achievements[playerid][ach_KILL_IN_5_SEC] = 0;
	Achievements[playerid][ach_SESSION_TIME] = 0;
	Achievements[playerid][ach_Counter] = 0;
	Achievements[playerid][ach_RUNNED] = 0.0;
	Achievements[playerid][ach_BMask][0] = 0;
	Achievements[playerid][ach_BMask][1] = 0;
	Achievements[playerid][ctg_time][0] = 0;
	Achievements[playerid][ctg_time][1] = 0;
	Achievements[playerid][Seconds] = 0;
	Achievements[playerid][Minutes] = 0;
	Achievements[playerid][Hours] = 0;

    VipTeamSelected[playerid] = -1;
    GravityMode[playerid] = false;
    GravityReset[playerid] = false;
    NewbieChangedClass[playerid] = false;
    TormentTime[playerid] = 0;
    ARDestructionTime[playerid] = 0;
    
    WasZombieTimes[playerid] = 0;
	WasHumanTimes[playerid] = 0;
	Player[playerid][pRestTime] = 0.0;
	
	/// MODULE
	//////////
	
    TimesJumped[playerid] = 0;
    PHS_SelID[playerid] = -1;
    Player[playerid][hasBleedEffect] = false;
    AntiCheat[playerid][ac_OldHP] = 0.0;
    AntiCheat[playerid][ex_OldHP] = 0.0;
    AntiCheat[playerid][weap_OldHP] = -100.0;
    drugs[playerid] = 5;
    CanJumpTwice[playerid] = 0;
    TempSpeciality[playerid] = -1;
    
    AntiCheat[playerid][ac_break_space] = 0;
    AntiCheat[playerid][ac_cs_warns] = 0;
    AntiCheat[playerid][ac_ex_warns] = 0;
    AntiCheat[playerid][ac_bp_warns] = 0;

    IsPlayerControlledBy[playerid] = -1;
    PlayerControllPlayer[playerid] = -1;

    AntiCheat[playerid][ac_weapon_hack] = 0;
    AntiCheat[playerid][ac_parkour] = 0;
    AntiCheat[playerid][ac_health_hack] = 0;

    AntiCheat[playerid][ac_teleport_hack] = 0;
    AntiCheat[playerid][ac_jump_hack] = 0;
    AntiCheat[playerid][ac_airbreak_hack] = 0;

    AntiCheat[playerid][weap_bp_ticks] = 0;

    AntiCheat[playerid][ac_teleports] = 0;
    AntiCheat[playerid][ac_jumps] = 0;

	/////////////////////// ANTI-CHEAT ///////////////////////////////

    static i;
    lmrf[playerid] = INVALID_PLAYER_ID;
    SpawnZoneTimer[playerid] = 5;
    alreadyNotificated[playerid] = -1;

    Player[playerid][pAntisonRound] = 0;
	
    CanUseCBugTime[playerid] = 0;
	BadNetworkTime[playerid] = 0;
    
    Player[playerid][pPort] = 0;
    Player[playerid][IsBurned][0] = 0;
	Player[playerid][IsBurned][1] = 0;
    Player[playerid][Poisioned] = false;
    Player[playerid][IsPlayerAdvancedInfected] = false;
 	Player[playerid][AntiSeeker] = false;
	Player[playerid][AntiFreeze] = false;
	Player[playerid][AntiRadioctive] = false;
	Player[playerid][AntiBuring] = false;
	Player[playerid][AntiLegBreaks] = false;
	Player[playerid][AntiSpider] = false;
	Player[playerid][AntiScreamer] = false;
	Player[playerid][SlowWalk] = 0;
	Player[playerid][Helmet] = false;
	Player[playerid][Fearlessness] = false;
	Player[playerid][Cursed] = false;
	
	Player[playerid][hasInfinitiveAmmo] = 0;

    for( i = 0; i < 30; i++) AccountsToAccept[playerid][i] = -1;
    for( i = 0; i < 32; i++) Player[playerid][pNewAttachments][i] = -1;

    CardEffectToUnlock[playerid] = -1;

    Player[playerid][resetEasyMissions] = 0;
    Player[playerid][resetMediumMissions] = 0;
    Player[playerid][resetHardMissions] = 0;
    Player[playerid][pYouTuber] = 0;
    DuelEXP[playerid] = 0;
	DuelRules[0][playerid] = 0;
	DuelRules[1][playerid] = 0;
    
    byingClass[playerid][0] = -1;
    byingClass[playerid][1] = -1;
    
    Player[playerid][pLang] = 0;
    Player[playerid][isInBying][0] = -1;
    Player[playerid][isInBying][1] = 0;
    Player[playerid][itemsInShop] = 0;
    Player[playerid][pShopPage] = 0;
    strmid(Player[playerid][pShopFilter], "", 0, 128, 129);
    
    Player[playerid][pShowWeapon][0] = -1;
    Player[playerid][pShowWeapon][1] = 0;
    
    for( i = 0; i < 10; i++)
    {
		OnlineShop[playerid][eps_id][i] = -1;
	    OnlineShop[playerid][eps_inx][i] = -1;
	    OnlineShop[playerid][eps_count][i] = 0;
	    OnlineShop[playerid][eps_price][i] = 0;
	    OnlineShop[playerid][eps_time][i] = 0;
	    OnlineShop[playerid][eps_vip][i] = 0;
	    OnlineShop[playerid][eps_acc][i] = 0;
	    OnlineShop[playerid][eps_type][i] = 0;
	}
	
	strmid(OnlineShop[playerid][eps_info_0], "", 0, 128, 129);
	strmid(OnlineShop[playerid][eps_info_1], "", 0, 128, 129);
	strmid(OnlineShop[playerid][eps_info_2], "", 0, 128, 129);
	strmid(OnlineShop[playerid][eps_info_3], "", 0, 128, 129);
	strmid(OnlineShop[playerid][eps_info_4], "", 0, 128, 129);
	strmid(OnlineShop[playerid][eps_info_5], "", 0, 128, 129);
    strmid(OnlineShop[playerid][eps_info_6], "", 0, 128, 129);
    strmid(OnlineShop[playerid][eps_info_7], "", 0, 128, 129);
    strmid(OnlineShop[playerid][eps_info_8], "", 0, 128, 129);
    strmid(OnlineShop[playerid][eps_info_9], "", 0, 128, 129);
	
    Player[playerid][pRefID] = 0;
    Player[playerid][PacketsLoss] = 0.0;
    Player[playerid][AbilityAffectedID] = INVALID_PLAYER_ID;
    Player[playerid][CheckForProtect] = INVALID_PLAYER_ID;
    
    Player[playerid][pUpgPoints] = 0;
    
    for( i = 0; i < 6; i++ ) pActionsSelected[playerid][i] = -1;
	
	Player[playerid][pLastGangJoin] = 0;
    
    SelectReward[playerid] = true;
    Player[playerid][e_Days] = 0;
	Player[playerid][e_PrevLogin] = 0;
	//for( i = 0; i< FLYZOMBIE; i++) Player[playerid][e_Avoid][i]=0;
	
    Player[playerid][eventMember] = -1;
    SetPlayerGravity(playerid, 0.008);
    ZombieMoveTime[playerid] = 0;
	Registered{playerid} = false;
    IsPlayerDeadByWarMember[playerid] = INVALID_PLAYER_ID;
    DeletePVar(playerid, "colExchangeID");
    DeletePVar(playerid, "Pizdorvanka");
    DeletePVar(playerid, "SpeedHack");
    DeletePVar(playerid, "WeapHack");
    DeletePVar(playerid, "auto-log");
    DeletePVar(playerid,"DocFlood");
    DeletePVar(playerid, "stype");
	SetPVarInt(playerid, "pl", -1);
	DeletePVar(playerid, "inx");
	DeletePVar(playerid, "pr");
	DeletePVar(playerid, "vp");
	DeletePVar(playerid, "ct");
	ClearPlayerShopInfo(playerid);
	
	PlayerShowHisTrophyID[playerid] = -10;
	SetPVarInt(playerid, "sell_trophy", -1);
	SetPVarInt(playerid, "sell_trophy_id", -1);
	SetPVarInt(playerid, "sell_trophy_price", -1);
    DeletePVar(playerid, "ItemInvIndex");
    DeletePVar(playerid, "dwxc");
    DeletePVar(playerid, "UseGold");
    DeletePVar(playerid, "UseGoldID");
    SetPVarInt(playerid,  "dtrp_id", -1);
    DeletePVar(playerid, "QuestCoin");
    DeletePVar(playerid,  "AchievementTypeList");
    DeletePVar(playerid,  "QuestInx");
    for( i = 0; i < 4; i++ )
	{
		Player[playerid][AdminActivity][i] = 0;
		Player[playerid][PlayerActivity][i] = 0;
	}
	Player[playerid][AdminActivity][4] = 0;
    IsPlayerDead[playerid] = false;
	CommandFloodTimer[playerid][ShowGangMembers] = 0;
    HeroFieldTime[playerid][1] = 0;
    HeroFieldTime[playerid][0] = 0;
    WasZombieTimes[playerid] = 0;
    Player[playerid][FireBullet][0] = -1;
	Player[playerid][FireBullet][1] = 0;
    LasDeadTime[playerid] = 0;
    PlayerGuitarTime[playerid] = 0;
	AntiCheatVehicle[playerid] = false;
    if(DefenderText[playerid] > Text3D:-1) Delete3DTextLabel(DefenderText[playerid]),DefenderText[playerid]=Text3D:-1;
    for( i = 0; i < sizeof(svrCLHXP); i++) { PlayerClassUnlocked[playerid][TEAM_HUMAN][i] = 0; }
	for( i = 0; i < sizeof(svrCLZXP); i++) { PlayerClassUnlocked[playerid][TEAM_ZOMBIE][i] = 0; }

	for( i = 0; i < MAX_PLAYERS; i++ ) Abilitys[playerid][CanGiveArmour][i] = 1;
	
    if(GangName[playerid]>Text3D:-1) Delete3DTextLabel(GangName[playerid]),GangName[playerid]=Text3D:-1;
	
    GangPanelIDSelected[playerid] = -1;
    GangPanelName[playerid][0] = '\0';
    Player[playerid][pBalance] = 0.0;
    
    meatDropsID[playerid] = -1;
    PlayerDamageChecker[playerid][DamageGiven] = 0.0;
   	HumanZombieBoss[playerid] = false;
	HumanHumanBoss[playerid] = false;
 	Healer[playerid] = false;
    PlayerDamageChecker[playerid][p_ID] = -1;
    PlayerDamageChecker[playerid][uAFK] = 0;
    LastMessagesTryed[playerid] = 0;
    Player[playerid][pIndentety] = false;
    //Player[playerid][LeatherFace][0] = 0;
    ZombieSpawnProtection[playerid] = 0;
    
    FakekillData[playerid][DeathCount] = 0;
    FakekillData[playerid][LastDeathTime] = 0;
    IsSpecing[playerid] = false;
    Suspecting[playerid] = 0;
    IsSpecing[playerid] = false;
    if(spectatorid[playerid] > -1) IsBeingSpeced[spectatorid[playerid]] = false;
    strmid(PlayerText[playerid], "", 0, 128, 128);
    spectatorid[playerid] = -1;
    //PlayerDamagedWeap[playerid][Weapon] = -1;
    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
	Player[playerid][Warnings] = 0;
	if(AdminVeh[playerid] > -1) DestroyVehicle(AdminVeh[playerid]);
    AdminVeh[playerid] = -1;
	Player[playerid][Jailed] = -1;
	Player[playerid][Accelerated] = -1;
    Player[playerid][pLogged] = false;
    DeletePVar(playerid, "frtime");
    Player[playerid][pAccountID] = 0;
    Player[playerid][Killstreak] = 0;
    if(IsValidPickup(meatDrops[playerid])) DestroyPickupEx(meatDrops[playerid], true);
    if(IsValidPickup(infectedMeat[playerid])) DestroyPickupEx(infectedMeat[playerid], true);
    infectedMeat[playerid] = -1;
    meatDrops[playerid] = -1;
    FakeData[playerid][0] = 0;
	FakeData[playerid][1] = 0;
 	FakeData[playerid][2] = 0;
	FakeData[playerid][3] = 0;
 	FakeData[playerid][4] = 0;
	FakeData[playerid][5] = 0;
	FakeData[playerid][6] = 0;
	FakeData[playerid][7] = 0;
	FakeData[playerid][8] = 0;
    strmid(LastMessage[playerid], "", 0, 1);
    Player[playerid][AntiSeeker] = false;
    Player[playerid][GunJammerAttack] = false;
    Player[playerid][Tasered] = false;
    Player[playerid][HeroField] = false;
    DuelReceived[playerid] = false;
    CockroachAbility[playerid] = false;
    SobeitTime[playerid] = 0;
    AntiSobeit[playerid] = 0;
    Player[playerid][GangBanned] = 0;
    IsBanned{playerid} = false;
    IsPlayerOnDuel[playerid] = false;
	DuelerID[playerid] = -1;
	Player[playerid][ConnectedMap] = -1;
	Player[playerid][AntiFreeze] = false;
	Player[playerid][Muted] = 0;
	Player[playerid][AntiRadioctive] = false;
	Player[playerid][AntiBuring] = false;
	Player[playerid][AntiLegBreaks] = false;
	Player[playerid][AntiSpider] = false;
	Player[playerid][AntiScreamer] = false;
	foreach(Player, j) isReported[playerid][j] = false;
	Player[playerid][AntiBlind] = false;
	Player[playerid][Helmet] = false;
	Player[playerid][Fearlessness] = false;
	Player[playerid][Cursed] = false;
	Player[playerid][CanSpyPM] = false;
	Player[playerid][CanCheckCMD] = false;
    Player[playerid][pKills] = 0;
	Player[playerid][pKillstreakMax] = 0;
	Player[playerid][pPlayerKills] = 0;
	Player[playerid][totalPlayersKilledInGW] = 0;
	Player[playerid][pCardSet] = 0;
	Player[playerid][pPlayerKillsBack] = 0;
	Player[playerid][pSettings] = 0;
	Player[playerid][IsDefender] = 0;
	Player[playerid][DefenderSorryTime] = 0;
	Player[playerid][pHumanClassesUnlocked_0] = 0;
	Player[playerid][pHumanClassesUnlocked_1] = 0;
	Player[playerid][pZombieClassesUnlocked_0] = 0;
	Player[playerid][pZombieClassesUnlocked_1] = 0;
	Player[playerid][RoundsWin] = 0;
	Player[playerid][pVipSkin] = 0;
	Player[playerid][DuelsWin] = 0;
	Player[playerid][pAttID][0] = 0;
	Player[playerid][pAttID][2] = 0;
	Player[playerid][pAttID][4] = 0;
	Player[playerid][pAttID][6] = 0;
	Player[playerid][DuelsLose] = 0;
	Player[playerid][pVip] = 0;
	Player[playerid][pAdmin] = 0;
	Player[playerid][pRank] = 0;
	Player[playerid][pXP] = 0;
	Player[playerid][pClan] = 0;
	Player[playerid][pClanRank] = 0;
	Player[playerid][pClanWarns] = 0;
	Player[playerid][pLang] = 0;
	Player[playerid][pVipTime] = 0;
	Player[playerid][Blidness] = 0;
	
	Player[playerid][pClass][TEAM_HUMAN] = CIVILIAN;
	Player[playerid][pClass][TEAM_ZOMBIE+1] = STANDARDZOMBIE;
    Player[playerid][pClass][TEAM_HUMAN+1] = CIVILIAN;
	Player[playerid][pClass][TEAM_ZOMBIE+2] = STANDARDZOMBIE;
}

public OnPlayerEditAttachedObject( playerid, response, index, modelid, boneid, Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fScaleX, Float:fScaleY, Float:fScaleZ )
{
    //SetPlayerAttachedObject(playerid,  5.50, 84.60, 83.7, 1.0, 1.0, 1.0, 0xC659B600);
	printf("SetPlayerAttachedObject(playerid, %d, %d, %d, %0.5f, %0.5f, %0.5f, %0.5f, %0.5f, %0.5f, %0.5f, %0.5f, %0.5f)", index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ );

	if(384 <= modelid <= 393)
    {
        foreach(Player, i)
	    {
	        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Object Crasher #1", Player[playerid][UserName], playerid);
		}
		return 0;
    }
    
	switch(index)
	{
	    case 0:
	    {
				Player[playerid][pAttID][0] = modelid;
    			Player[playerid][pAttID][1] = boneid;
    			Player[playerid][pAttIDPos][0] = fOffsetX;
				Player[playerid][pAttIDPos][1] = fOffsetY;
				Player[playerid][pAttIDPos][2] = fOffsetZ;
				Player[playerid][pAttIDPos][3] = fRotX;
				Player[playerid][pAttIDPos][4] = fRotY;
				Player[playerid][pAttIDPos][5] = fRotZ;
				Player[playerid][pAttIDPos][6] = fScaleX;
				Player[playerid][pAttIDPos][7] = fScaleY;
				Player[playerid][pAttIDPos][8] = fScaleZ;
	    }
    	case 1:
	    {
				Player[playerid][pAttID][2] = modelid;
    			Player[playerid][pAttID][3] = boneid;
    			Player[playerid][pAttIDPos][9] = fOffsetX;
				Player[playerid][pAttIDPos][10] = fOffsetY;
				Player[playerid][pAttIDPos][11] = fOffsetZ;
				Player[playerid][pAttIDPos][12] = fRotX;
				Player[playerid][pAttIDPos][13] = fRotY;
				Player[playerid][pAttIDPos][14] = fRotZ;
				Player[playerid][pAttIDPos][15] = fScaleX;
				Player[playerid][pAttIDPos][16] = fScaleY;
				Player[playerid][pAttIDPos][17] = fScaleZ;
	    }
	    case 2:
	    {
				Player[playerid][pAttID][4] = modelid;
    			Player[playerid][pAttID][5] = boneid;
    			Player[playerid][pAttIDPos][18] = fOffsetX;
				Player[playerid][pAttIDPos][19] = fOffsetY;
				Player[playerid][pAttIDPos][20] = fOffsetZ;
				Player[playerid][pAttIDPos][21] = fRotX;
				Player[playerid][pAttIDPos][22] = fRotY;
				Player[playerid][pAttIDPos][23] = fRotZ;
				Player[playerid][pAttIDPos][24] = fScaleX;
				Player[playerid][pAttIDPos][25] = fScaleY;
				Player[playerid][pAttIDPos][26] = fScaleZ;
	    }
	    case 3:
	    {
				Player[playerid][pAttID][6] = modelid;
    			Player[playerid][pAttID][7] = boneid;
    			Player[playerid][pAttIDPos][27] = fOffsetX;
				Player[playerid][pAttIDPos][28] = fOffsetY;
				Player[playerid][pAttIDPos][29] = fOffsetZ;
				Player[playerid][pAttIDPos][30] = fRotX;
				Player[playerid][pAttIDPos][31] = fRotY;
				Player[playerid][pAttIDPos][32] = fRotZ;
				Player[playerid][pAttIDPos][33] = fScaleX;
				Player[playerid][pAttIDPos][34] = fScaleY;
				Player[playerid][pAttIDPos][35] = fScaleZ;
	    }
	}
	return 1;
}

stock AttachUserObjects(playerid)
{
    if(Player[playerid][pAttID][0] > 0) SetPlayerAttachedObject(playerid, 0,
	Player[playerid][pAttID][0], Player[playerid][pAttID][1],
	Player[playerid][pAttIDPos][0], Player[playerid][pAttIDPos][1],
	Player[playerid][pAttIDPos][2], Player[playerid][pAttIDPos][3],
	Player[playerid][pAttIDPos][4], Player[playerid][pAttIDPos][5],
	Player[playerid][pAttIDPos][6], Player[playerid][pAttIDPos][7],
	Player[playerid][pAttIDPos][8]);
	
	if(Player[playerid][pAttID][2] > 0) SetPlayerAttachedObject(playerid, 1,
	Player[playerid][pAttID][2], Player[playerid][pAttID][3],
	Player[playerid][pAttIDPos][9], Player[playerid][pAttIDPos][10],
	Player[playerid][pAttIDPos][11], Player[playerid][pAttIDPos][12],
	Player[playerid][pAttIDPos][13], Player[playerid][pAttIDPos][14],
	Player[playerid][pAttIDPos][15], Player[playerid][pAttIDPos][16],
	Player[playerid][pAttIDPos][17]);
	
	if(Player[playerid][pAttID][4] > 0) SetPlayerAttachedObject(playerid, 2,
	Player[playerid][pAttID][4], Player[playerid][pAttID][5],
	Player[playerid][pAttIDPos][18], Player[playerid][pAttIDPos][19],
	Player[playerid][pAttIDPos][20], Player[playerid][pAttIDPos][21],
	Player[playerid][pAttIDPos][22], Player[playerid][pAttIDPos][23],
	Player[playerid][pAttIDPos][24], Player[playerid][pAttIDPos][25],
	Player[playerid][pAttIDPos][26]);
	
	if(Player[playerid][pAttID][6] > 0) SetPlayerAttachedObject(playerid, 3,
	Player[playerid][pAttID][6], Player[playerid][pAttID][7],
	Player[playerid][pAttIDPos][27], Player[playerid][pAttIDPos][28],
	Player[playerid][pAttIDPos][29], Player[playerid][pAttIDPos][30],
	Player[playerid][pAttIDPos][31], Player[playerid][pAttIDPos][32],
	Player[playerid][pAttIDPos][33], Player[playerid][pAttIDPos][34],
	Player[playerid][pAttIDPos][35]);
}

stock CreateObjectsX(objectid,Float:px, Float:py, Float:pz, Float:rx, Float:ry, ammount, Float:radius, time, Float:angle=360.0, bool:circleangles=true, Float:rz=0.0)
{
	if(ammount <= 1 || 0.0 <= angle > 360.0 || radius<=0.0) return false;
	for(new i=0;i<=ammount;i++)
	{
		new obj;
		obj = CreateObject(objectid, px+floatsin((angle/ammount)*i, degrees)*radius, py+floatcos((angle/ammount)*i, degrees)*radius, pz, rx, ry, circleangles ? ((-angle/ammount)*i) : (rz));
        SetTimerEx("RemoveObject", time*1000, 0, "i", obj);
	}
	return 1;
}

stock CreatePickupsX(objectid,Float:px, Float:py, Float:pz, ammount, Float:radius, Float:angle=360.0)
{
	if(ammount <= 1 || 0.0 <= angle > 360.0 || radius<=0.0) return false;
	for(new j,i=0;i<=ammount;i++)
	{
		j = CreatePickupEx(objectid, 23, px+floatsin((angle/ammount)*i, degrees)*radius, py+floatcos((angle/ammount)*i, degrees)*radius, pz, -1);
        meatDropsID[j] = 2804;
	}
	return 1;
}

stock SetPlayerSkinAC(playerid, skin, isAbility = 0)
{
	Player[playerid][pSkin] = skin;
    if(Player[playerid][pVipSkin] > 0 && !isAbility) SetPlayerSkin(playerid, Player[playerid][pVipSkin]);
    else SetPlayerSkin(playerid, skin);
    ClearAnimations(playerid, 1);
}

stock KillTimerEx(timerid)
{
    KillTimer(timerid);
    timerid = -1;
}

stock GetTextUpperCount(const text[])
{
	new count;
    for(new i, j = strlen(text)-1; i < j; i ++)
    {
        if(('A' <= text[i] <= 'Z') && ('A' <= text[i+1] <= 'Z')) count++;
    }
    return count;
}

stock SetAbilityTimer(playerid, time, tm = TEAM_ZOMBIE)
{
	if(tm == TEAM_ZOMBIE) SetTimerEx("AbilityIsReady", time*1000, 0, "iii", playerid, Player[playerid][pClass][TEAM_ZOMBIE+1], tm);
	if(tm == TEAM_HUMAN) SetTimerEx("AbilityIsReady", time*1000, 0, "iii", playerid, Player[playerid][pClass][TEAM_HUMAN], tm);
	return 1;
}

fun AbilityIsReady(playerid, ClassID, tm)
{
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == ClassID)
	{
	    switch(Player[playerid][pLang])
	    {
	        case 0: TextDrawSetString(AIR[playerid], "~y~ABILITY~w~ IS~g~ READY!");
	        case 1: TextDrawSetString(AIR[playerid], RusToGame("~y~С_П_ОС_ОБНОСТЬ ~g~ГОТОВ_А!"));
	        case 2: TextDrawSetString(AIR[playerid], "~y~CAPACIDAD~w~ ESTA~g~ LISTO!");
		}
	    
	    TextDrawShowForPlayer(playerid, AIR[playerid]);
	    SetTimerEx("HideAbIsReady", 2000, 0, "i", playerid);
	    if(GetUnlockedSlot(Player[playerid][pSettings], PS_ABILITY_READY) == 1) PlayerPlaySound(playerid, 1056, 0.0, 0.0, 0.0);
	}
	if(GetPlayerTeamEx(playerid) == tm && Player[playerid][pClass][TEAM_HUMAN] == ClassID)
	{
	    TextDrawShowForPlayer(playerid, AIR[playerid]);
	    SetTimerEx("HideAbIsReady", 2000, 0, "i", playerid);
	    if(GetUnlockedSlot(Player[playerid][pSettings], PS_ABILITY_READY) == 1) PlayerPlaySound(playerid, 1056, 0.0, 0.0, 0.0);
	}
}

fun HideAbIsReady(playerid) return TextDrawHideForPlayer(playerid, AIR[playerid]);

stock RemoveObjects(playerid)
{
    RemoveBuildingForPlayer(playerid, 3338, 703.0938, 1334.8438, 10.5000, 0.25);
	RemoveBuildingForPlayer(playerid, 3244, 703.0938, 1334.8438, 10.5000, 0.25);
    RemoveBuildingForPlayer(playerid, 3794, -1404.8281, 499.8828, 10.7188, 0.25);
	RemoveBuildingForPlayer(playerid, 3793, -1403.8984, 500.0859, 10.8203, 0.25);
	RemoveBuildingForPlayer(playerid, 3795, -1401.8359, 494.9063, 10.5469, 0.25);
	RemoveBuildingForPlayer(playerid, 3792, -1401.0078, 494.6875, 10.7500, 0.25);
	RemoveBuildingForPlayer(playerid, 3793, -1398.1797, 494.7734, 10.8203, 0.25);
	RemoveBuildingForPlayer(playerid, 3788, -1399.0625, 494.4453, 10.7188, 0.25);
	RemoveBuildingForPlayer(playerid, 3789, -1403.6172, 504.0938, 10.5469, 0.25);
	RemoveBuildingForPlayer(playerid, 3791, -1289.9766, 494.7734, 10.6719, 0.25);
	RemoveBuildingForPlayer(playerid, 3795, -1294.1172, 499.3359, 10.5469, 0.25);
	RemoveBuildingForPlayer(playerid, 3791, -1290.5000, 496.4375, 10.6719, 0.25);
	RemoveBuildingForPlayer(playerid, 3787, -1290.2656, 499.9609, 10.7734, 0.25);
	RemoveBuildingForPlayer(playerid, 3787, -1290.3125, 497.9609, 10.7734, 0.25);
	RemoveBuildingForPlayer(playerid, 3787, -1300.6406, 504.0391, 10.7734, 0.25);
	RemoveBuildingForPlayer(playerid, 3789, -1301.5859, 511.1094, 10.5469, 0.25);
	RemoveBuildingForPlayer(playerid, 3792, -1301.5859, 511.9688, 10.7500, 0.25);
	RemoveBuildingForPlayer(playerid, 3794, -1305.3359, 511.1953, 10.7188, 0.25);
	RemoveBuildingForPlayer(playerid, 3793, -1305.2891, 512.1484, 10.8203, 0.25);
	RemoveBuildingForPlayer(playerid, 3788, -1294.0156, 509.2188, 10.7188, 0.25);
	RemoveBuildingForPlayer(playerid, 3793, -1294.0156, 510.1563, 10.8203, 0.25);
	RemoveBuildingForPlayer(playerid, 3794, -1294.6172, 501.3281, 10.7188, 0.25);
	RemoveBuildingForPlayer(playerid, 3795, -1290.3984, 503.4688, 10.5469, 0.25);
	RemoveBuildingForPlayer(playerid, 3792, -1289.7031, 503.9922, 10.7500, 0.25);
	RemoveBuildingForPlayer(playerid, 3793, -1294.3750, 503.1094, 10.4297, 0.25);

    RemoveBuildingForPlayer(playerid, 5906, 1213.7656, -1177.0938, 19.7500, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1038.0781, -1155.3750, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1053.1641, -1159.7031, 25.9063, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1092.6563, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1083.0391, -1155.3750, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1012.6719, -1135.4141, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1045.6094, -1140.1641, 25.8594, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1052.6719, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1072.2578, -1140.1953, 25.7891, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1078.1250, -1128.6016, 26.3125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1083.3906, -1130.2734, 25.9063, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1093.0703, -1140.2500, 25.9063, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1087.3359, -1118.8594, 26.4688, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1112.9688, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1120.2188, -1155.3750, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1132.6563, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1150.8906, -1155.3750, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1160.1328, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1171.6328, -1149.8828, 25.7422, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1152.2734, -1140.1406, 25.8750, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1103.6016, -1135.4141, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1123.0938, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1143.6016, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1168.2344, -1135.2500, 25.8438, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1136.9141, -1135.0234, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1108.3594, -1135.0234, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1181.9688, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1182.1719, -1155.3750, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1203.3984, -1154.1641, 26.2188, 0.25);
	RemoveBuildingForPlayer(playerid, 5804, 1213.7656, -1177.0938, 19.7500, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1215.6719, -1159.8672, 25.5703, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1226.8594, -1150.0469, 25.5156, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1243.6328, -1155.1641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1206.4844, -1140.2969, 25.9688, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1176.8438, -1135.4141, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1196.3438, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1216.8516, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1233.4141, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1240.0078, -1134.6875, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1182.1719, -1134.6875, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1261.6094, -1155.1641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1275.8125, -1149.7734, 25.8516, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1278.0234, -1155.1641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1295.1094, -1155.1641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1311.6719, -1155.1641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1252.6094, -1140.2266, 25.8516, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1274.5938, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1311.6719, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1295.1094, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1280.1719, -1134.8359, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1322.2734, -1155.9063, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1332.5703, -1149.9922, 25.8438, 0.25);
	RemoveBuildingForPlayer(playerid, 1223, 1332.1797, -1135.6641, 22.8125, 0.25);
	RemoveBuildingForPlayer(playerid, 717, 1322.2734, -1134.2344, 23.0000, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1257.8125, -1128.0625, 26.0703, 0.25);
	RemoveBuildingForPlayer(playerid, 1283, 1263.2891, -1130.7578, 25.8516, 0.25);
	RemoveBuildingForPlayer(playerid, 1297, 1267.0234, -1118.8594, 26.4688, 0.25);
	RemoveBuildingForPlayer(playerid, 1415, -619.6250, -473.4531, 24.5859, 0.25);
	RemoveBuildingForPlayer(playerid, 17020, -475.9766, -544.8516, 28.1172, 0.25);
	RemoveBuildingForPlayer(playerid, 1278, -471.5547, -479.9219, 38.6250, 0.25);
}

public OnIncomingRPC(playerid, rpcid, BitStream:bs)
{
    if(rpcid == 0x67)
    {
    	new addr;
     	BS_ReadValue(bs, PR_INT8, 0, PR_INT32, addr);
     	AntiSobeit[playerid] = ((addr & 0xFC0000) != 0xFC0000);
    }
    return 1;
}

fun GetPlayerIpInfo(playerid, ip[])
{
	new str[196];
	
	#if debug_mode == 0
	format(str, sizeof(str), "api.ipstack.com/%s?access_key=e7ff6901b7476b2c8537e4c7c8cb6d60", ip);
    #endif
    
    #if debug_mode == 1
	format(str, sizeof(str), "www.extreme-ip-lookup.com/json/%s", ip);
	printf("DEBUG MODE (GEO BASE)");
	#endif
	
	HTTP(playerid, HTTP_GET, str, "", "OnGeoBase");
	return 1;
}

fun OnGeoBase(index, response_code, data[])
{
	if(IsPlayerConnected(index))
	{
	    #if debug_mode == 0
	    new JSONNode:dataNode = json_parse_string(data);
	    new country[50], IP[16], msg[300], cisp[50], ipName[96], query[128];
    	json_get_string(dataNode, country, sizeof(country), "country_name");
    	strmid(Player[index][p_Country], country, 0, 50, 51);
		
    	GetPlayerIp(index, IP, 16);
	    if(strlen(country) <= 3) country = "Internal Error";
	
	 	foreach(Player, i)
		{
		    if(Player[i][pAdmin] < 1) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][0], Player[index][UserName], index);
			else
			{
				SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][152], Player[index][UserName], index, IP, country);
			}
		}
		
		SendClientMessage(index, -1, "{BEBEBE}-- Current Build v"SERVER_BUILD"");
		SendClientMessage(index, -1, "{BEBEBE}-- Last update: "SERVER_UPDATE"");
		
		DiscordChannel = DCC_FindChannelById("615197122202959902");
		new y, m, d, h, a, s;
		
		TimestampToDate(gettime(), y, m, d, h, a, s, 3);
		format(msg, 300, "```%04d-%02d-%02d %02d:%02d %s - (IP: %s) - (Location: %s)```", y, m, d, h, a, Player[index][UserName], IP, country);
		DCC_SendChannelMessageEx(DiscordChannel, msg);
		strmid(Player[index][pRegion], country, 0, 64, 65);
        
		new version[24];
    	GetPlayerVersion(index, version, sizeof(version));
    	json_close(dataNode);
    	#endif
	}
    return 1;
}

stock MakeReasonFromShort(const short[], bool:ignorecase=false)
{
    new result[128];
	new rs[][] =
    {
        "HH","GM","AH","PM","WH","VH","TA","AB","TP","TH","ISM","IR","BE","ADV",
        "FH","JH","RF","AIM","SH","GH","SD","SC","BW","BP","IF","FX","BH","BH1",
        "AA","SK","OOM"
    };
    new fl[][] =
    {
        "Health Hack", "Health Hack", "Ammo Hack", "Parkour Mode",
        "Weapon Hack", "Vehicle Hack", "Team Attacking", "AirBrake", "Teleport Hack",
        "Teleport Hack", "Insulting Staff Member", "Insulting Relatives", "Ban Evading",
        "Advertising", "Fly Hack", "Jump Hack", "Rapid Fire", "Aimbot", "Speed Hack",
        "Weapon Hack","Spawn Damage","Spawn Camping","Blocking the way","Bullet Proof",
        "Insulting Relatives","EXP farming","Bunnyhopping","Control your language","AFK Abuse",
        "Spawn Killing","Out Of Map"
    };
    for( new i; i < sizeof(rs); i++ )
	{
		if(strfind(short, rs[i], ignorecase) == 0)
		{
		    strcat(result, fl[i]);
		    if(strlen(rs[i]) == 2) strcat(result, short[2]);
		    else strcat(result, short[3]);
		    return result;
		}
	}
	strcat(result, short);
	return result;
}

stock MakeCountryFromCode(country_code[])
{
	new result[45], codes[][3] =
	{
		"AF","AX","AL","DZ","AS","AD","AO","AI","AQ","AG","AR","AM","AW","AU","AT",
		"AZ","BS","BH","BD","BB","BY","BE","BZ","BJ","BM","BT","BO","BA","BW",
		"BV","BR","VG","IO","BN","BG","BF","BI","KH","CM","CA","CV","KY","CF",
		"TD","CL","CN","HK","MO","CX","CC","CO","KM","CG","CD","CK","CR","CI",
		"HR","CU","CY","CZ","DK","DJ","DM","DO","EC","EG","SV","GQ","ER","EE",
		"ET","FK","FO","FJ","FI","FR","GF","PF","TF","GA","GM","GE","DE","GH",
		"GI","GR","GL","GD","GP","GU","GT","GG","GN","GW","GY","HT","HM","VA",
		"HN","HU","IS","IN","ID","IR","IQ","IE","IM","IL","IT","JM","JP","JE",
		"JO","KZ","KE","KI","KP","KR","KW","KG","LA","LV","LB","LS","LR","LY",
		"LI","LT","LU","MK","MG","MW","MY","MV","ML","MT","MH","MQ","MR","MU",
		"YT","MX","FM","MD","MC","MN","ME","MS","MA","MZ","MM","NA","NR","NP",
		"NL","AN","NC","NZ","NI","NE","NG","NU","NF","MP","NO","OM","PK","PW",
		"PS","PA","PG","PY","PE","PH","PN","PL","PT","PR","QA","RE","RO","RU",
		"RW","BL","SH","KN","LC","MF","PM","VC","WS","SM","ST","SA","SN","RS",
		"SC","SL","SG","SK","SI","SB","SO","ZA","GS","SS","ES","LK","SD","SR",
		"SJ","SZ","SE","CH","SY","TW","TJ","TZ","TH","TL","TG","TK","TO","TT",
		"TN","TR","TM","TC","TV","UG","UA","AE","GB","US","UM","UY","UZ","VU",
		"VE","VN","US","WF","EH","YE","ZM","ZW"
	},
	names[][45] =
	{
		"Afghanistan","Aland Islands","Albania","Algeria","American Samoa","Andorra",
		"Angola","Anguilla","Antarctica","Antigua and Barbuda","Argentina","Armenia",
		"Aruba","Australia","Austria","Azerbaijan","Bahamas","Bahrain","Bangladesh",
		"Barbados","Belarus","Belgium","Belize","Benin","Bermuda","Bhutan","Bolivia",
		"Bosnia and Herzegovina","Botswana","Bouvet Island","Brazil","British Virgin Islands",
		"British Indian Ocean Territory","Brunei Darussalam","Bulgaria","Burkina Faso",
		"Burundi","Cambodia","Cameroon","Canada","Cape Verde","Cayman Islands","Central African Republic",
		"Chad","Chile","China","Hong Kong, SAR China","Macao, SAR China","Christmas Island","Cocos (Keeling) Islands",
		"Colombia","Comoros","Congo (Brazzaville)","Congo, (Kinshasa)","Cook Islands",
		"Costa Rica","Cфte d'Ivoire","Croatia","Cuba","Cyprus","Czech Republic","Denmark",
		"Djibouti","Dominica","Dominican Republic","Ecuador","Egypt","El Salvador",
		"Equatorial Guinea","Eritrea","Estonia","Ethiopia","Falkland Islands (Malvinas)",
		"Faroe Islands","Fiji","Finland","France","French Guiana","French Polynesia",
		"French Southern Territories","Gabon","Gambia","Georgia","Germany","Ghana",
		"Gibraltar","Greece","Greenland","Grenada","Guadeloupe","Guam","Guatemala",
		"Guernsey","Guinea","Guinea-Bissau","Guyana","Haiti","Heard and Mcdonald Islands",
		"Holy See (Vatican City State)","Honduras","Hungary","Iceland","India","Indonesia",
		"Iran","Iraq","Ireland","Isle of Man","Israel","Italy","Jamaica","Japan","Jersey",
		"Jordan","Kazakhstan","Kenya","Kiribati","Korea (North)","Korea (South)","Kuwait",
		"Kyrgyzstan","Lao","Latvia","Lebanon","Lesotho","Liberia","Libya","Liechtenstein",
		"Lithuania","Luxembourg","Macedonia","Madagascar","Malawi","Malaysia","Maldives",
		"Mali","Malta","Marshall Islands","Martinique","Mauritania","Mauritius","Mayotte",
		"Mexico","Micronesia","Moldova","Monaco","Mongolia","Montenegro","Montserrat","Morocco",
		"Mozambique","Myanmar","Namibia","Nauru","Nepal","Netherlands","Netherlands Antilles",
		"New Caledonia","New Zealand","Nicaragua","Niger","Nigeria","Niue","Norfolk Island",
		"Northern Mariana Islands","Norway","Oman","Pakistan","Palau","Palestinian Territory",
		"Panama","Papua New Guinea","Paraguay","Peru","Philippines","Pitcairn","Poland","Portugal",
		"Puerto Rico","Qatar","Rйunion","Romania","Russian Federation","Rwanda","Saint-Barthйlemy",
		"Saint Helena","Saint Kitts and Nevis","Saint Lucia","Saint-Martin (French part)","Saint Pierre and Miquelon",
		"Saint Vincent and Grenadines","Samoa","San Marino","Sao Tome and Principe","Saudi Arabia","Senegal","Serbia",
		"Seychelles","Sierra Leone","Singapore","Slovakia","Slovenia","Solomon Islands","Somalia","South Africa",
		"South Georgia and the South Sandwich Islands","South Sudan","Spain","Sri Lanka","Sudan","Suriname",
		"Svalbard and Jan Mayen Islands","Swaziland","Sweden","Switzerland","Syrian Arab Republic (Syria)",
		"Taiwan","Tajikistan","Tanzania","Thailand","Timor-Lest","Togo","Tokelau","Tonga","Trinidad and Tobag",
		"Tunisia","Turkey","Turkmenistan","Turks and Caicos Islands","Tuvalu","Uganda","Ukraine","United Arab Emirates",
		"United Kingdom","United States of America","US Minor Outlying Islands","Uruguay","Uzbekistan","Vanuatu",
		"Venezuela (Bolivarian Republic)","Viet Nam","Virgin Islands","Wallis and Futuna Islands","Western Sahara",
		"Yemen","Zambia","Zimbabwe"
	};

	for( new i; i < sizeof(codes); i++ )
	{
		if(!strcmp(country_code, codes[i]))
		{
		    strcat(result, names[i]);
		    return result;
		}
	}
	return result;
}

stock SetPlayerPosAC(playerid,Float:X,Float:Y,Float:Z)
{
    AntiTPTimerEx(playerid,3);
    OldPos[playerid][0] = X;
	OldPos[playerid][1] = Y;
	OldPos[playerid][2] = Z;
    SetPlayerPos(playerid,X,Y,Z);
    return 1;
}

stock AntiTPTimerEx(playerid,extra)
{
    AntiPlayerTP[playerid]=gettime()+(extra+floor(GetPlayerPing(playerid)/100));
    return 1;
}

stock AntiSlap(playerid, extra)
{
	AntiPlayerSlap[playerid]=gettime()+(extra+floor(GetPlayerPing(playerid)/100));
    return 1;
}

stock AntiSpeedHack(playerid, extra)
{
	AntiPlayerSpeedHack[playerid]=gettime()+(extra+floor(GetPlayerPing(playerid)/100));
	return 1;
}

fun IgnoreThisClass(playerid)
{
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    switch(Player[playerid][pClass][TEAM_ZOMBIE+1])
	    {
	        case MEGAJUMPERZOMBIE, FASTZOMBIE: return 1;
		}
	}
	if(GetPlayerTeamEx(playerid) == TEAM_HUMAN)
	{
	    switch(Player[playerid][pClass][TEAM_HUMAN])
	    {
	        case IRONMAN, HUMANQUEEN, SPIDERMAN: return 1;
		}
	}
	return 0;
}

stock IsFalling(i)
{
	if(GetPlayerSpeed(i) >= 50 && (GetPlayerAnimationIndex(i) == 960 || GetPlayerAnimationIndex(i) >= 1128 && GetPlayerAnimationIndex(i) <= 1134)) return 1;
	return 0;
}

stock CheckForWebsite(const text[])
{
	if(strfind(text, "www", true) != -1) return 1;
	if(strfind(text, "http", true) != -1) return 1;
	new name[][] =
	{
	    ".com", ".org", ".ru", ".biz", ".gov",
	    ".info", ".int", ".net", ".post", ".pro", ".tk", ".xxx",
	    ".xyz", ".yandex", ".dev", ".su", ".ua", ".kz", ".eu", ".es",
	    ".lt", ".in", ".us", ".bz", ".so", ".st", ".ws", ".io", //".sk",
	    ".ooo", ".ink", ".md", ".tj", ".tm", ".top", ".zone", ".tw", ".to",
	    ".tl", ".cc", "bttdm"
	};
	for( new i; i < sizeof(name); i++ ) if(strfind(text, name[i], true) != -1) return 1;
	return 0;
}


stock Accelerate(i, time = 15)
{
    if(Player[i][IsDefender] <= 0)
	{
	    if(GangName[i]>Text3D:-1) Delete3DTextLabel(GangName[i]),GangName[i]=Text3D:-1;
		if(IsPlayerAcceleratedText[i]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[i]),IsPlayerAcceleratedText[i]=Text3D:-1;
	    IsPlayerAcceleratedText[i] = Create3DTextLabel("{5c5cd6}Accelerated", 0xFFFFFFFF, 0.0, 0.0, 0.0, 30.0, Map[m_World], 0);
	    Attach3DTextLabelToPlayer(IsPlayerAcceleratedText[i], i, 0.0, 0.0, 0.7);
		Player[i][Accelerated] = time;
		PlayerPlaySound(i, 6402, 0.0, 0.0, 0.0);
	}
}

stock AttachGangName(i)
{
    if(GetWeekDay() != GANG_WARS_DAY) return 0;
    static h, f, q;
    gettime(h, f, q);
	if(h < 15 || h >= 20 && f >= 0 && q >= 0)  return 0;
    
    if(IsPlayerAcceleratedText[i]>Text3D:-1) Delete3DTextLabel(IsPlayerAcceleratedText[i]),IsPlayerAcceleratedText[i]=Text3D:-1;
	if(GangName[i]>Text3D:-1) Delete3DTextLabel(GangName[i]),GangName[i]=Text3D:-1;
	if(Clan[Player[i][pClan]][g_IsNeutral]) {}
	else
	{
	    new gid = Player[i][pClan], id = -1, str[128], j;
	    if(!Clan[gid][g_IsRulles])
		{
	        for(j = 1; j < sizeof(Clan); j++) {
				if(Clan[j][g_IsRulles]) {
					id = j;
					break;
				}
			}
			if(id > 0) {
			    if(Clan[gid][g_AllianceWith][gid] >= 2) {
					format(str, sizeof(str), "{FFF000}Sub-Ruler\n%s", Clan[gid][Full]);
			    	GangName[i] = Create3DTextLabel(str, 0xFFFFFFFF, 0.0, 0.0, 0.0, 30.0, GetPlayerVirtualWorld(i), 0);
				}
			}
			else GangName[i] = Create3DTextLabel(Clan[gid][Full], 0xFFFFFFFF, 0.0, 0.0, 0.0, 30.0, GetPlayerVirtualWorld(i), 0);
		}
		else
		{
		    format(str, sizeof(str), "{FFF000}Ruler\n%s", Clan[gid][Full]);
			GangName[i] = Create3DTextLabel(str, 0xFFFFFFFF, 0.0, 0.0, 0.0, 30.0, GetPlayerVirtualWorld(i), 0);
		}
		Attach3DTextLabelToPlayer(GangName[i], i, 0.0, 0.0, 0.7);
	}
	
	return 1;
}

stock CreateDefender(i)
{
	if(Player[i][IsDefender] > 0)
	{
	    if(DefenderText[i] > Text3D:-1) Delete3DTextLabel(DefenderText[i]),DefenderText[i]=Text3D:-1;
    	DefenderText[i] = Create3DTextLabel("{99ffff}[EVENT]Defender", 0xFFFFFFFF, 0.0, 0.0, 0.0, 30.0, Map[m_World], 0);
    	Attach3DTextLabelToPlayer(DefenderText[i], i, 0.0, 0.0, 0.7);
	}
}

stock IsPointInRangeOfPoint(Float:x, Float:y, Float:z, Float:x2, Float:y2, Float:z2, Float:range)
{
    x2 -= x;
    y2 -= y;
    z2 -= z;
    return ((x2 * x2) + (y2 * y2) + (z2 * z2)) < (range * range);
}

stock GetWeaponSlot(weaponid)
{
    switch(weaponid)
    {
        case 1: return 0;
        case 2..9: return 1;
        case 22..24: return 2;
        case 25..27: return 3;
        case 28, 29, 32: return 4;
        case 30, 31: return 5;
        case 33, 34: return 6;
        case 35..38: return 7;
        case 16..18, 39: return 8;
        case 41..43: return 9;
        case 10..15: return 10;
        case 44..46: return 11;
        case 40: return 12;
    }
    return 0xFFFF;
}

stock ItsNewbie(playerid) return (Player[playerid][pXP] < 2500);


stock TryToAdd(playerid, item, vip = 0, bool:canStack = true)
{
	return 0;
}

stock SearchItemInInv(playerid, item)
{
	return 0;
}

stock AddItemInInv(playerid, item, ct = 1, vip = 0, time = -1, drop = 0, xp = 0, bool:canStack = true,  chaos_index = -1, chaos_type = -1, chaos_progress =-1)
{
	return 0;
}

stock GetItemIndex(playerid, j)
{
	return -1;
}

fun GetItemCount(playerid, itemid)
{
	return 0;
}

stock GetPlayerMaxClass(playerid)
{
	switch(GetPlayerTeamEx(playerid))
	{
		case TEAM_HUMAN:
		{
			for( new i; i < END_OF_HUMAN_CLASSES; i++ ) if(Player[playerid][pXP] < svrCLHXP[i]) return i-1;
		}
		case TEAM_ZOMBIE:
		{
			for( new i; i < END_OF_ZOMBIE_CLASSES; i++ ) if(Player[playerid][pXP] < svrCLZXP[i]) return i-1;
		}
	}
	return 0;
}

stock RemoveItemFromInv(playerid, itemid, count = 1, bool:say = true, index = -1)
{
    return 0;
}

stock ShowInvItems(playerid, forplayer = INVALID_PLAYER_ID)
{
	return 0;
}

stock TryToAddAPet(playerid)
{
	return 0;
}

stock AddPet(playerid, item, const name[] = "", rare = 4, vip = 0, level = 1)
{
	return -1;
}

stock RemovePet(playerid, id)
{
    return 1;
}

stock DisablePet(playerid)
{
	RemovePlayerAttachedObject(playerid, 8);
}

fun CheckUserForPayments()
{
    #if debug_mode == 0
	if(cache_num_rows() > 0)
    {
        DiscordChannel = DCC_FindChannelById("674323910648397894");
        new z, NN[24], ON[24], date, IP[16], y, m, d, h, i, s, type, amt, msg[200];
		for( z = 0; z < cache_num_rows(); z++)
		{
			cache_get_value_name(z, "from", NN);
		    cache_get_value_name(z, "whom", ON);
		    cache_get_value_name_int(z, "type", type);
		    cache_get_value_name_int(z, "amount", amt);
	        cache_get_value_name_int(z, "date", date);
	        cache_get_value_name(z, "ip", IP);
			TimestampToDate(date, y, m, d, h, i, s, 3);
			switch(type)
			{
				case 0: format(msg, 200, "```%04d-%02d-%02d %02d:%02d %s (/pay %d EXP) to %s (IP %s)\n```", y, m, d, h, i, NN, amt, ON, IP);
            	case 1: format(msg, 200, "```%04d-%02d-%02d %02d:%02d %s (/gang deposit %d EXP) to %s (IP %s)\n```", y, m, d, h, i, NN, amt, ON, IP);
				case 2: format(msg, 200, "```%04d-%02d-%02d %02d:%02d %s (/gang pay %d EXP) to %s (IP %s)\n```", y, m, d, h, i, NN, amt, ON, IP);
				case 3: format(msg, 200, "```%04d-%02d-%02d %02d:%02d %s (/givezaps %d ZAPS) to %s (IP %s)\n```", y, m, d, h, i, NN, amt, ON, IP);
			}
			DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```No results found```");
	}
	#endif
	return 1;
}

fun ShowGangActivity(playerid)
{
	new size = cache_num_rows();
	if(size > 0)
	{
 		new i, User[MAX_PLAYER_NAME], lalog[24];
  		for( i = 0; i < size; i++ )
	 	{
   			cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
 	    	cache_get_value_name(i, "lalog", lalog);
	 		SendClientMessageFormat(playerid, -1, "{E68687}>> %s - Last login: %s", User, lalog);
		}
	}
	return 1;
}

stock ShowDamageTaken(playerid, Float:damage = 0.0)
{
	new s[13];
	format(s, sizeof(s), "-%.0f", damage);
    SetPlayerChatBubble(playerid, s, 0xd6d6c2FF, 20.0, 1000);
}

CMD:top(playerid, params[])
{
    new command[32], name[96], amount[96];
	sscanf(params, "S()[32]S()[96]S()[96]", command, name, amount);
	if(!strlen(command))
	{
	    SendClientMessage(playerid, -1, "/top kills");
	    SendClientMessage(playerid, -1, "/top xp");
	    SendClientMessage(playerid, -1, "/top duels");
	    return 1;
	}
	
	if(strfind(command, "duels") == 0)
 	{
 	    new query[128];
	    mysql_format(Base, query, sizeof(query), "SELECT `DuelWins`,`Name` FROM `users` WHERE `build`='"SERVER_BUILD"' ORDER BY `DuelWins` DESC LIMIT 10");
		mysql_tquery(Base, query, "ShowTopDuelPlayers", "i", playerid);
		return 1;
 	}
	if(strfind(command, "xp") == 0)
 	{
 	    new query[128];
	    mysql_format(Base, query, sizeof(query), "SELECT `EXP`,`Name` FROM `users` WHERE `build`='"SERVER_BUILD"' ORDER BY `EXP` DESC LIMIT 10");
		mysql_tquery(Base, query, "ShowTopXPPlayers", "i", playerid);
		return 1;
 	}
	if(strfind(command, "kills") == 0)
 	{
 	    new query[128];
	    mysql_format(Base, query, sizeof(query), "SELECT `Kills`,`Name` FROM `users` WHERE `build`='"SERVER_BUILD"' ORDER BY `Kills` DESC LIMIT 10");
		mysql_tquery(Base, query, "ShowTopKillsPlayers", "i", playerid);
		return 1;
 	}
 	return 1;
}

fun ShowTopDuelPlayers(playerid)
{
    new size = cache_num_rows();
	if(size > 0)
	{
 		switch(Player[playerid][pLang])
   		{
     		case 0: SendClientMessage(playerid, -1, "{FFD500}-- TOP 10 PLAYERS");
       		case 1: SendClientMessage(playerid, -1, "{FFD500}-- ТОП 10 ИГРОКОВ");
	        case 2: SendClientMessage(playerid, -1, "{FFD500}-- Las 10 Mejores Jugadores");
	    }
	    new User[MAX_PLAYER_NAME], k, i;
    	for( i = 0; i < size; i++ )
	 	{
	 	    cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
	 	    cache_get_value_name_int(i, "DuelWins", k);
			SendClientMessageFormat(playerid, -1, "{FFD500}(%d place) >> %s (%d wins)", i+1, User, k);
		}
	}
	return 1;
}

fun ShowTopXPPlayers(playerid)
{
    new size = cache_num_rows();
	if(size > 0)
	{
 		switch(Player[playerid][pLang])
   		{
     		case 0: SendClientMessage(playerid, -1, "{FFD500}-- TOP 10 PLAYERS");
       		case 1: SendClientMessage(playerid, -1, "{FFD500}-- ТОП 10 ИГРОКОВ");
	        case 2: SendClientMessage(playerid, -1, "{FFD500}-- Las 10 Mejores Jugadores");
	    }
		new i, User[MAX_PLAYER_NAME], k;
		for( i = 0; i < size; i++ )
	 	{
	 	    cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
	 	    cache_get_value_name_int(i, "EXP", k);
			SendClientMessageFormat(playerid, -1, "{FFD500}(%d place) >> %s (%d exp)", i+1, User, k);
		}
	}
	return 1;
}

fun ShowTopKillsPlayers(playerid)
{
    new size = cache_num_rows();
	if(size > 0)
	{
 		switch(Player[playerid][pLang])
   		{
     		case 0: SendClientMessage(playerid, -1, "{FFD500}-- TOP 10 PLAYERS");
       		case 1: SendClientMessage(playerid, -1, "{FFD500}-- ТОП 10 ИГРОКОВ");
	        case 2: SendClientMessage(playerid, -1, "{FFD500}-- Las 10 Mejores Jugadores");
	    }
	    new i, User[MAX_PLAYER_NAME], k;
    	for( i = 0; i < size; i++ )
	 	{
	 	    cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
	 	    cache_get_value_name_int(i, "Kills", k);
			SendClientMessageFormat(playerid, -1, "{FFD500}(%d place) >> %s (%d kills)", i+1, User, k);
		}
	}
	return 1;
}

stock GangSetTaxes(exp) return exp - floor(exp * (TAXES-0.10));

stock CheckForIP(const message[])
{
    new i_numcount, i_period, i_pos;
    while(message[i_pos])
	{
        if('0' <= message[i_pos] <= '9') i_numcount ++;
        else if(message[i_pos] == '.') i_period ++;
        i_pos++;
    }
    if(i_numcount >= 5) return 1;
    return 0;
}

stock CheckForFlood(const message[])
{
    new i_pos = 1, ch = message[0], count;
    while(message[i_pos])
	{
		if(ch == message[i_pos]) count++;
		else {
			ch = message[i_pos];
		    count = 0;
		}
        i_pos++;
    }
    if(count >= 3) return 1;
    return 0;
}

stock ClearEventsFromMemory()
{
    new eventID, i, newID;
	for( eventID = 0; eventID < 10; eventID ++)
	{
	    EventInfo[eventID][e_IsStarted] = false;
	    EventInfo[eventID][e_IsJoinsClosed] = false;
	    EventInfo[eventID][e_IsGangNeed] = false;
	    EventInfo[eventID][e_RequestToDelete] = false;
	    
	    EventInfo[eventID][e_VirtualWorld] = 0;
	   	EventInfo[eventID][e_minPlayers] = 0;
	   	EventInfo[eventID][e_maxPlayers] = MAX_PLAYERS;
	   	EventInfo[eventID][e_curPlayers] = 0;
	   	EventInfo[eventID][e_minRank] = 0;
	   	EventInfo[eventID][e_minExp] = 0;
	   	EventInfo[eventID][e_TimerCount] = 0;
	   	EventInfo[eventID][e_TimeToEnd] = -1;
	   	
	    for(i = 1; i < 6; i++) EventInfo[eventID][e_IsTeamActive][i] = false;
	    for(i = 0; i < 6; i++) EventInfo[eventID][e_Skin][i] = 0;
	   	for(i = 0; i < 3; i++) EventInfo[eventID][e_defaultPoses][i] = 0.0;
	   	EventInfo[eventID][e_Gravity] = 0.008;
	   	
	   	EventInfo[eventID][e_Time] = 12;
		EventInfo[eventID][e_Weather] = 0;
	   	
	   	for(i = 0; i < MAX_PLAYERS; i++) if(IsValidPickup(EventInfo[eventID][e_Pickups][i])) DestroyPickupEx(EventInfo[eventID][e_Pickups][i], true);
	   	
		for( i = 0; i < 18; i++)
		{
		    newID = (i-1) > -1 ? i * 2 : 0;
	    	if(EventInfo[eventID][e_CarProps][newID] > 0) DestroyVehicle(EventInfo[eventID][e_CarProps][newID]);
		}
	    for(i = 0; i < 36; i++) EventInfo[eventID][e_CarProps][i] = 0;
	    for(i = 0; i < 8; i++) EventInfo[eventID][e_RulersPermisions][i] = 0;
        for(i = 0; i < 10; i++) EventInfo[eventID][e_Rulers][i] = 0;
        
	    EventInfo[eventID][e_IsEnded] = true;
	    EventInfo[eventID][e_OwnerID] = -1;
	    strmid(EventInfo[eventID][e_Name], "", 0, 65, 65);

	    for(i = 0; i < 100; i++)
		{
			if(IsValidDynamicObject(EventInfo[eventID][e_Objects][i]))
		    {
				DestroyDynamicObject(EventInfo[eventID][e_Objects][i]);
				EventInfo[eventID][e_Objects][i] = INVALID_OBJECT_ID;
			}
		}
	}
}

stock IsWomanSkin(skinid)
{
	switch(skinid)
	{
	    case 9..13, 31, 39..41, 53..56, 63..65, 69, 75..77, 85, 87..93, 129..131, 138..141, 145, 148, 150..152, 157, 169, 172, 178, 190..199, 201, 205, 207, 211, 214..216, 218, 219, 224..226, 231..233, 237..238, 243..246, 251, 256, 257, 263, 298, 306..309: return 1;
		default: return 0;
	}
	return 0;
}

fun GetMedicCount()
{
	foreach(Player, i)
	{
    	if(GetPlayerTeamEx(i) == TEAM_HUMAN && Player[i][pClass][TEAM_HUMAN] == MEDIC) return 1;
	}
	return 0;
}

stock ResetGangnMembersToOptimal(gangid)
{
	foreach(Player, i)
	{
	    if(Player[i][pRank] < GangsSettings[6] && Player[i][pClan] == gangid && Player[i][pClanRank] <= 5)
	    {
	        Clan[Player[i][pClan]][g_MaxMembers]--;
	        Player[i][pClan] = 0;
	        Player[i][pClanRank] = 0;
	        SendClientMessage(i, -1, serverLang[Player[i][pLang]][124]);
	        if(GetPlayerTeamEx(i) == TEAM_HUMAN) SetPlayerColor(i, COLOR_HUMAN);
	    }
	}
	new query[128];
	mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Clan`='0',`ClanRank`='0' WHERE `Clan` = '%d' AND `Rank` < '%d' AND `ClanRank` < 6 AND `build`='"SERVER_BUILD"'", gangid, GangsSettings[6]);
	mysql_tquery(Base, query, "");
	
	mysql_format(Base, query, sizeof(query), "SELECT `Clan` FROM `users` WHERE `Clan` = '%d' AND `build`='"SERVER_BUILD"'", gangid);
	mysql_tquery(Base, query, "GetGangMembers", "i", gangid);
}

stock abs(value) return ((value < 0 ) ? (-value) : (value));

stock ApplyCustomDamage(issuerid, playerid, weaponid, Float:amount, bool:type = false, bodypart = 3)
{
	PlayerShotPlayer[issuerid][playerid] = true;
	PlayerDamageChecker[playerid][DamageGiven] += 0.5;
	
	if(Player[issuerid][aDuty] || Player[playerid][aDuty]) return 0;
	
	new weapname[32];
	GetWeaponName(weaponid, weapname, sizeof(weapname));
	if(GetPVarInt(issuerid, weapname) <= -2 && strlen(weapname) >= 2) return 0;
	
    new Float:hp, Float:am, Float:damage = amount;
    GetPlayerArmourEx(playerid, am);
    GetPlayerHealthEx(playerid, hp);
	KilledBy[playerid] = issuerid;
	KilledByWeapon[playerid] = weaponid;

	DamageApplyType[playerid][0] = type;
	DamageApplyType[playerid][1] = 0;

    if(GetPlayerTeamEx(issuerid) == TEAM_ZOMBIE && weaponid == 23) return 0;
    if(Player[playerid][pClass][TEAM_ZOMBIE+1] == ENFORCER && GetPlayerTeamEx(issuerid) == TEAM_HUMAN && weaponid != 0 && weaponid != 23 && weaponid != 24 && weaponid != 25 && weaponid != 30 && weaponid <= 31) return 0;

	static const Float:damage_range = 1.0;

    switch(weaponid)
    {
        case 0:
		{
		    new Float:pos[3];
		    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
		    if(!IsPlayerInRangeOfPoint(issuerid, damage_range, pos[0], pos[1], pos[2])) return 0;
		    
			if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN &&  Player[issuerid][pClass][TEAM_HUMAN] == BOXER) damage = 50.0;
			if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN &&  Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDBOXER) damage = 100.0;
			if(GetPlayerTeamEx(issuerid) == TEAM_ZOMBIE && Player[issuerid][pClass][TEAM_ZOMBIE+1] == UNDEADBOXER) damage = 50.0;
		}
        case 8:
		{
		    new Float:pos[3];
		    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
		    if(!IsPlayerInRangeOfPoint(issuerid, damage_range, pos[0], pos[1], pos[2])) return 0;
		    
			damage = 50.0;
			if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN &&  Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDSAMURAI) damage = 100.0;
		}
		case 9: {
		    new Float:pos[3];
		    GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
		    if(!IsPlayerInRangeOfPoint(issuerid, damage_range, pos[0], pos[1], pos[2])) return 0;
			damage = (amount * 0.6);
		}
		case 26: damage = (amount * 0.55);
		case 38: damage = (amount * 0.25);
		case 24: if(Player[playerid][pClass][TEAM_ZOMBIE+1] == ENFORCER) damage = 10.0;
		case 25: if(Player[playerid][pClass][TEAM_ZOMBIE+1] == ENFORCER) damage = 10.0;
		case 34: if(Player[playerid][pClass][TEAM_ZOMBIE+1] == ENFORCER) damage = 10.0;
    }
    
    damage += Player[playerid][pAdditionalDamage];
    
    if(bodypart == 9) HeadshotsInCount[issuerid][playerid]++;
    
    if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && !Player[issuerid][KickBack] && Player[issuerid][pVip] >= 1)
    {
        for( new j; j < sizeof(Map[ZombieSpawnX]); j++ ) if(IsPlayerInRangeOfPoint(issuerid, 5.0, Map[ZombieSpawnX][j], Map[ZombieSpawnY][j], Map[ZombieSpawnZ][j])) {}
        else
        {
			if(weaponid >= 23 && weaponid <= 31 && weaponid != 27)
			{
			    if(Player[issuerid][pClass][TEAM_HUMAN] == ASSASSIN || Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDHERO || Player[issuerid][pClass][TEAM_HUMAN] == SPIDERMAN || Player[issuerid][pClass][TEAM_HUMAN] == HUMANQUEEN || Player[issuerid][pClass][TEAM_HUMAN] == IRONMAN) {}
				else
				{
				    new Float:pos[4];
				    GetPlayerPos(issuerid, pos[0], pos[1], pos[2]);
					if(IsPlayerInRangeOfPoint(playerid, 12.0, pos[0], pos[1], pos[2]))
				    {
					    GetPlayerFacingAngle(issuerid, pos[3]);
						GetPlayerCameraFrontVector(issuerid, pos[0], pos[1], pos[2]);
			  			SetPlayerVelocity(playerid, pos[0]*0.10, pos[1]*0.10, pos[2]*0.10);
			  			SetPlayerFacingAngle(playerid, pos[3]);
			  			AntiTPTimerEx(playerid, 4);
						AntiSlap(playerid, 4);
						AntiSpeedHack(playerid, 3);
						SetPlayerArmedWeapon(playerid, 0);
					}
				}
			}
		}
    }
    
    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && weaponid == 9)
    {
        switch(Player[playerid][pClass][TEAM_HUMAN])
        {
            case HERO, IRONMAN, ADVANCEDZOMBIEFAN: damage = (amount * 0.25);
        }
        if(Player[playerid][pVip] > 0) damage = (amount * 0.25);
    }
    
    new Float:result = (am - damage), Float:fract = ((result) <= -0.001 ? float(abs(ceil(result))) : 0.0);
	if(am >= 0.001)
	{
	    if( am - damage >= 1.0) SetPlayerArmourAC(playerid, am - damage);
	    else SetPlayerArmourAC(playerid, 0.0);

		SetPlayerHealthAC(playerid, hp - fract);
	}
	else
	{
		SetPlayerArmourAC(playerid, 0.0);
		SetPlayerHealthAC(playerid, hp - damage);
	}
	
	ShowDamageTaken(playerid, damage);
	
    if(weaponid != 9 && GetPlayerTeamEx(playerid) != GetPlayerTeamEx(issuerid) && GetUnlockedSlot(Player[issuerid][pSettings], PS_DING) == 1) PlayerPlaySound(issuerid, 17802, 0.0, 0.0, 0.0);
	return 1;
}

stock GetPlayerFPS(playerid)
{
    SetPVarInt(playerid, "DrunkL", GetPlayerDrunkLevel(playerid));
    if(GetPVarInt(playerid, "DrunkL") < 100){
        SetPlayerDrunkLevel(playerid, 2000);}
    else
    {
        if(GetPVarInt(playerid, "LDrunkL") != GetPVarInt(playerid, "DrunkL"))
        {
            SetPVarInt(playerid, "FPS", (GetPVarInt(playerid, "LDrunkL") - GetPVarInt(playerid, "DrunkL")));
            SetPVarInt(playerid, "LDrunkL", GetPVarInt(playerid, "DrunkL"));
            if((GetPVarInt(playerid, "FPS") > 0) && (GetPVarInt(playerid, "FPS") < 256)){
            return GetPVarInt(playerid, "FPS") - 1;}
        }
    }
    return 0;
}

fun DeleteFromKillstreakList(playerid)
{
    for( new j = 2; j > -1; j-- )
	{
		if(KSList[j] == playerid)
		{
			KSList[j] = -15+j;
			KSListKS[j] = -15+j;
		}
	}
    UpdateKillstreaksList(playerid);
	return 1;
}

fun SortKillstreakList()
{
	new itterations = sizeof(KSList), j, i, userid;
	for( i = 0; i < itterations; i++ )
	{
	    userid = KSList[i];
		if(!IsPlayerConnected(userid))
		{
			userid = -15+i;
			KSListKS[i] = -15+i;
		}
		else if(Player[userid][Killstreak] <= 0)
		{
			userid = -15+i;
			KSListKS[i] = -15+i;
		}
	}
	
	while(itterations > 0)
	{
		for( j = 0; j < 3; j++ )
		{
			for( i = j+1; i < 3; i++ )
			{
			    if(KSListKS[i] > KSListKS[j])
				{
					swap(KSList[j], KSList[i]);
                    swap(KSListKS[j], KSListKS[i]);
				}
			}
		}
		itterations--;
	}
}

fun swap(&a, &b)
{
	new temp = b;
	b = a;
	a = temp;
}

fun bool:FindUserInKsList(playerid) {
	for ( new i = 0; i < 3; i++ ) {
		if(KSList[i] == playerid) return true;
	}
	return false;
}

fun UpdateKillstreaksList(playerid)
{
	new j, string[164], xyeta_a_ne_compiler[] = "Player";
	new player0[MAX_PLAYER_NAME], player1[MAX_PLAYER_NAME], player2[MAX_PLAYER_NAME];
	
	strmid(player0, xyeta_a_ne_compiler, 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);
 	strmid(player1, xyeta_a_ne_compiler, 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);
  	strmid(player2, xyeta_a_ne_compiler, 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);

	SortKillstreakList();

	if(IsPlayerConnected(KSList[0])) if(Player[KSList[0]][Killstreak] >= 1) strmid(player0, Player[KSList[0]][UserName], 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);
    if(IsPlayerConnected(KSList[1])) if(Player[KSList[1]][Killstreak] >= 1) strmid(player1, Player[KSList[1]][UserName], 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);
	if(IsPlayerConnected(KSList[2])) if(Player[KSList[2]][Killstreak] >= 1) strmid(player2, Player[KSList[2]][UserName], 0, MAX_PLAYER_NAME, MAX_PLAYER_NAME);

	for( j = 2; j > -1; j-- )
	{
	    if(KSList[j] == playerid)
	    {
	        KSListKS[j] = Player[playerid][Killstreak];
			foreach(Player, i)
			{
				switch(Player[i][pLang])
				{
				    case 0,2:
				    {
					    format(string,sizeof(string), "~w~Killstreaks:_1._~r~%s_(%d)_~w~2._~r~%s_(%d)_~w~3._~r~%s_(%d)", player0, KSList[0] > -1 ? Player[KSList[0]][Killstreak] : 0,
					 	player1, KSList[1] > -1 ? Player[KSList[1]][Killstreak] : 0,
					  	player2, KSList[2] > -1 ? Player[KSList[2]][Killstreak] : 0);
		  	        }
		  	        case 1:
				    {
					    format(string,sizeof(string), RusToGame("~w~Топ убийств:_1._~r~%s_(%d)_~w~2._~r~%s_(%d)_~w~3._~r~%s_(%d)"), player0, KSList[0] > -1 ? Player[KSList[0]][Killstreak] : 0,
					 	player1, KSList[1] > -1 ? Player[KSList[1]][Killstreak] : 0,
					  	player2, KSList[2] > -1 ? Player[KSList[2]][Killstreak] : 0);
		  	        }
				}
				TextDrawSetString(DisplayInfo[1][i], string);
			}
			return 1;
	    }
	}
	
	for( j = 0; j < 3; j++ )
	{
	    if(KSList[j] <= -1 || Player[playerid][Killstreak] > KSListKS[j] && !FindUserInKsList(playerid))
	    {
	        KSList[j] = playerid;
	        KSListKS[j] = Player[playerid][Killstreak];
	        foreach(Player, i)
			{
				switch(Player[i][pLang])
				{
				    case 0,2:
				    {
					    format(string,sizeof(string), "~w~Killstreaks:_1._~r~%s_(%d)_~w~2._~r~%s_(%d)_~w~3._~r~%s_(%d)", player0, KSList[0] > -1 ? Player[KSList[0]][Killstreak] : 0,
					 	player1, KSList[1] > -1 ? Player[KSList[1]][Killstreak] : 0,
					  	player2, KSList[2] > -1 ? Player[KSList[2]][Killstreak] : 0);
		  	        }
		  	        case 1:
				    {
					    format(string,sizeof(string), RusToGame("~w~Топ убийств:_1._~r~%s_(%d)_~w~2._~r~%s_(%d)_~w~3._~r~%s_(%d)"), player0, KSList[0] > -1 ? Player[KSList[0]][Killstreak] : 0,
					 	player1, KSList[1] > -1 ? Player[KSList[1]][Killstreak] : 0,
					  	player2, KSList[2] > -1 ? Player[KSList[2]][Killstreak] : 0);
		  	        }
				}
				TextDrawSetString(DisplayInfo[1][i], string);
			}
			return 1;
		}
	}
	
	return 0;
}

fun UseDamageSystem(playerid, issuerid, Float: amount, weaponid, bodypart)
{
	/// HUMANs
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && (Player[issuerid][pClass][TEAM_HUMAN] == ASSASSIN || Player[issuerid][pClass][TEAM_HUMAN] == SHARPSHOOTER && weaponid == 34) && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && bodypart == 9 && !Player[playerid][Helmet])
	{
	    PlayerShotPlayer[issuerid][playerid] = true;
		PlayerDamageChecker[playerid][DamageGiven] += 0.5;

		KilledBy[playerid] = issuerid;
		KilledByWeapon[playerid] = weaponid;

		SetPlayerHealthAC(playerid, -0.0);

		ShowDamageTaken(playerid, 100.0);
		Player[playerid][AbilityAffectedID] = issuerid;
	}
	
 	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && Player[issuerid][pClass][TEAM_HUMAN] == COPIER && weaponid == 10)
    {
        if(gettime() < Abilitys[playerid][CopierCooldown])
	    {
			switch(Player[playerid][pLang])
		    {
				case 0: GameTextForPlayer(playerid,"~g~ Wait some time", 1000, 5);
		        case 1: GameTextForPlayer(playerid,RusToGame("~g~П_ОДОЖДИТЕ"), 1000, 5);
		        case 2: GameTextForPlayer(playerid,"~g~Espera algъn tiempo", 1000, 5);
			}
			return 1;
		}
    
        if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == VIPHUMAN) return 0;
        if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_HUMAN] == TANKZOMBIE) return 0;
        if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;

		PlayerShotPlayer[issuerid][playerid] = true;
        PlayerDamageChecker[playerid][DamageGiven] += 0.5;

		ResetWeapons(issuerid);
		new slot, weap, ammo, Float:sts[2];
	    for ( slot = 0; slot < 14; slot++ )
	    {
	        GetPlayerWeaponData(playerid,slot,weap,ammo);
	        if(weap <= 34 || weap >= 39 && weap <= 41) GivePlayerWeaponAC(issuerid, weap, floor(ammo / 2), false);
		}

		GivePlayerWeaponAC(issuerid, 10, 1);
		GetPlayerHealth(playerid, sts[0]);
		GetPlayerArmour(playerid, sts[1]);
		SetPlayerSkinAC(issuerid, GetPlayerSkin(playerid));
		SetPlayerHealthAC(issuerid, sts[0]);
		SetPlayerArmourAC(issuerid, sts[1]);
		ClearAnimations(issuerid);
		Abilitys[playerid][CopierCooldown] = gettime() + 25;
	}
	
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDPOLICEMAN && weaponid == 24 && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
    {
        if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;
        if(Player[issuerid][TaserReady])
        {
        	ClearAnimations(playerid);
         	new Float:pos[3], objectid;
       	 	GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
          	if(Time >= 6)
			{
   				objectid = CreateObject(18718, pos[0], pos[1], pos[2] - 2.5, 0.0, 0.0, 0.0);
       			SetTimerEx("RemoveObject", 5000, 0, "i", objectid);
			}
   			ClearAnimations(playerid, 1);
   			ApplyAnimation(playerid, "CRACK", "CRCKIDLE2", 4.1, 0, 1, 1, 0, 5000, 1);
			Player[issuerid][TaserReady] = false;
			Player[playerid][Tasered] = true;
			PlayerPlaySound(playerid, 6003, 0.0, 0.0, 0.0);
			SetTimerEx("UnfreezePlayer", 5000, 0, "i", playerid);
			SetTimerEx("TaserIsReady", 45000, 0, "ii", issuerid, playerid);
			Player[playerid][AbilityAffectedID] = issuerid;
		}
    }
	
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && !Player[playerid][IsBurned] && Player[issuerid][pClass][TEAM_HUMAN] == FIREMANIAC && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && canBeBurned(playerid, false))
    {
        PlayerShotPlayer[issuerid][playerid] = true;
        PlayerDamageChecker[playerid][DamageGiven] += 0.5;
        if(weaponid >= 22 && weaponid != 42 && Player[issuerid][FireBullet][0])
        {
    	    SetPlayerAttachedObject(playerid,9,18689,1,0.000000,-0.130999,-1.650999,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000);
    	    Player[playerid][IsBurned][0] = 1;
			Player[playerid][IsBurned][1] = 1;
			Player[issuerid][FireBullet][0] = 0;
			Player[issuerid][FireBullet][1] = gettime() + 15;
			Player[playerid][AbilityAffectedID] = issuerid;
		}
	}
	
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && (Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDBOXER && weaponid == 0 || Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDSAMURAI && weaponid == 8) && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pXP] < 2500)
	{
	    PlayerShotPlayer[issuerid][playerid] = true;
		PlayerDamageChecker[playerid][DamageGiven] += 0.5;

		KilledBy[playerid] = issuerid;
		KilledByWeapon[playerid] = weaponid;

		SetPlayerHealthAC(playerid, -0.0);

		ShowDamageTaken(playerid, 100.0);
		Player[playerid][AbilityAffectedID] = issuerid;
	}
	
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && (Player[issuerid][pClass][TEAM_HUMAN] == SCOUT || Player[issuerid][pClass][TEAM_HUMAN] == ADVANCEDSCOUT) && weaponid == 34 && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    PlayerShotPlayer[issuerid][playerid] = true;
		PlayerDamageChecker[playerid][DamageGiven] += 0.5;

		KilledBy[playerid] = issuerid;
		KilledByWeapon[playerid] = weaponid;
        new Float:hp;
		GetPlayerHealthEx(playerid, hp);
			
		if(getZombieClass(playerid) != ENFORCER) SetPlayerHealthAC(playerid, hp - 43.0);
		else SetPlayerHealthAC(playerid, hp - 15.0);
		
		Player[playerid][AbilityAffectedID] = issuerid;
		return 1;
	}
	
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && Player[issuerid][pClass][TEAM_HUMAN] == POISONER && (weaponid == 33 || weaponid == 41 || weaponid == 25 && random(2) == 0 || weaponid == 24 && random(4) == 0) && GetPlayerTeamEx(playerid) == TEAM_ZOMBIE)
	{
	    PlayerShotPlayer[issuerid][playerid] = true;
		PlayerDamageChecker[playerid][DamageGiven] += 0.5;

		KilledBy[playerid] = issuerid;
		KilledByWeapon[playerid] = weaponid;

		InfectPlayerWithAbility(playerid, 7.0, 0, issuerid);
		Player[playerid][AbilityAffectedID] = issuerid;
	}
	
	/// ZOMBIEs
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && Player[playerid][pClass][TEAM_ZOMBIE+1] == SPOREZOMBIE)
    {
        if(classCanBeInfected(issuerid) && gettime() < Abilitys[playerid][SporeZombie])
        {
            ZombieSpawnProtection[playerid] = 0;
            if(getHumanClass(playerid) != SHARPSHOOTER)
            {
				if(InfectPlayer(9999.9, issuerid, playerid))
            	{
					foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][27], Player[issuerid][UserName], Player[playerid][UserName]);
					GivePlayerXP(playerid, 2);
				}
			}
		}
	}
	
	if(GetPlayerTeamEx(playerid) == TEAM_ZOMBIE && GetPlayerTeamEx(issuerid) == TEAM_ZOMBIE)
	{
		Player[issuerid][TimesDamage]++;
		if(weaponid == 9 && Player[issuerid][TimesDamage] >= 30 || weaponid != 9 && Player[issuerid][TimesDamage] >= 3)
	    {
	        PlayerShotPlayer[issuerid][playerid] = true;

	        switch(Player[issuerid][pLang])
		    {
				case 0: GameTextForPlayer(issuerid, "~b~WTF ~g~zombie?", 2000, 5);
		        case 1: GameTextForPlayer(issuerid,RusToGame("~b~ЧТО ~g~ЗА ~r~Х ~g~ЗОМБИ?"), 2000, 5);
		        case 2: GameTextForPlayer(issuerid,"~b~WTF ~g~zombi?", 2000, 5);
			}

			ApplyAnimation(issuerid, "PED", "getup_front", 4.1, 0, 1, 1, 0, 0);
			Player[issuerid][TimesDamage] = 0;
	    }
	}
	
	// Cure by Rifle
	if(GetPlayerTeamEx(issuerid) == TEAM_HUMAN && CanCureByRifleShot(issuerid) && Player[playerid][IsPlayerInfected] && weaponid == 33)
	{
	    if(GetPlayerColor(playerid) == COLOR_EVACUATED) return 1;

	    PlayerShotPlayer[issuerid][playerid] = true;
		PlayerDamageChecker[playerid][DamageGiven] += 0.5;

	   	if(CurePlayer(playerid, issuerid))
	   	{
	  		GivePlayerXP(issuerid, 5);
			foreach(Player, i) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][62], Player[playerid][UserName], Player[issuerid][UserName]);
 			GameTextForPlayer(playerid,"~g~ANTEDOTE TAKEN", 2000, 5);
		}
	}

	if(GetPlayerTeamEx(issuerid) != GetPlayerTeamEx(playerid)) ApplyCustomDamage(issuerid, playerid, weaponid, amount, false, bodypart);
	return 1;
}

fun CreateNewUserInDB(playerid, const IP[])
{
	Player[playerid][pAccountID] = cache_insert_id();
	if(Player[playerid][pAccountID] > -1)
	{
	    new query[364];
 		KillTimer(RegisterTimer[playerid]);
	    SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
	    Player[playerid][pClass][TEAM_HUMAN] = CIVILIAN;
		Player[playerid][pClass][TEAM_ZOMBIE+1] = STANDARDZOMBIE;
	    Player[playerid][pClass][TEAM_HUMAN+1] = CIVILIAN;
		Player[playerid][pClass][TEAM_ZOMBIE+2] = STANDARDZOMBIE;

		mysql_format(Base, query, sizeof(query), "INSERT INTO `userinfo` (`id`,`last_ip`,`reg_date`,`port`) VALUES ('%d','%e','%d','%d')",Player[playerid][pAccountID], IP, gettime(), Player[playerid][pPort]);
		mysql_tquery(Base, query, "", "", "");
		Player[playerid][pRegDate] = gettime();
		strmid(Player[playerid][pLastIP], IP, 0, 16, 17);

        mysql_format(Base, query, sizeof(query), "SELECT * FROM `Achievements` WHERE `ID` = '%d'", Player[playerid][pAccountID]);
 		mysql_tquery(Base, query, "LoadAchievements", "i", playerid);
 		
 		mysql_format(Base, query, sizeof(query), "SELECT * FROM `timeout` WHERE `ID` = '%d'", Player[playerid][pAccountID]);
 		mysql_tquery(Base, query, "LoadTimeout", "i", playerid);

	 	/*new Head[48];
		format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 4);
		ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_3, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][11], ServerRegisters[Player[playerid][pLang]][10], ServerRegisters[Player[playerid][pLang]][12]);
		*/
		return 1;
	}
	else
	{
		SendClientMessageFormat(playerid, -1, "{FFF000}>> Error! Code 0x%d", mysql_errno(Base));
		foreach(Player, j) if(Player[j][pAdmin] > 0 && Player[j][pLogged]) SendClientMessageFormat(j, 0x33CCFFFF, "{33CCFF}>> %s has been kicked [Reason: MySQL error (0x%d)]", Player[playerid][UserName], mysql_errno(Base));
	}
	PlayerKick(playerid);
	return 1;
}

fun TryToFindUserNamesFromDiscord(limit)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("674323910648397894");
    if(cache_num_rows() > 0)
    {
		new acc, msg[72], query[164];
		
  		cache_get_value_name_int(0, "account", acc);
  		format(msg, sizeof(msg), "```css\nAccount ID %d\n```", acc);
		DCC_SendChannelMessageEx(DiscordChannel, msg);
		if(acc > 0)
		{
			mysql_format(Base, query, sizeof(query), "SELECT * FROM `namechanger` WHERE `account` = '%d' AND `build`='"SERVER_BUILD"' ORDER BY `Date` DESC LIMIT %d", acc, limit);
			mysql_tquery(Base, query, "ShowNameChanges", "i", acc);
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```No results found```");
		return 1;
	}
	#endif
	return 1;
}

fun CheckForOffStatsInInvDiscord(type)
{
    #if debug_mode == 0
	if(type == 0) DiscordChannel = DCC_FindChannelById("674323910648397894");
    else DiscordChannel = DCC_FindChannelById("613185790683513003");
    
	if(cache_num_rows() > 0)
	{
		new  year, month, day, stats[512];
		getdate(year, month, day);
	    new y, m, d, h, i, s, vip[21], msg[200], rd, IP[16];
	    new k, ksm, rw, dw, dl, vp, vpt, ad, rk, xp, cln, clnr, id, name[24], uIP[16], lalog[24];
		
		if(cache_num_rows() > 1)
		{
	        format(msg, sizeof(msg), "```\n%d matches found\n```", cache_num_rows());
			DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
		
		for( new zpl = 0; zpl < cache_num_rows(); zpl++)
		{
			cache_get_value_name_int(zpl, "ID", id);
			cache_get_value_name(zpl, "Name", name);
		    cache_get_value_name_int(zpl, "Kills", k);
	        cache_get_value_name_int(zpl, "Killstreak", ksm);
	        cache_get_value_name_int(zpl, "RoundWins", rw);
	        cache_get_value_name_int(zpl, "DuelWins", dw);
	        cache_get_value_name_int(zpl, "DuelLoses", dl);
	        cache_get_value_name_int(zpl, "VIP", vp);
	        cache_get_value_name_int(zpl, "Admin", ad);
	        cache_get_value_name_int(zpl, "Rank", rk);
	        cache_get_value_name_int(zpl, "EXP", xp);
	        cache_get_value_name_int(zpl, "Clan", cln);
	        cache_get_value_name_int(zpl, "ClanRank", clnr);
	        cache_get_value_name_int(zpl, "VipTime", vpt);
	        cache_get_value_name(zpl, "IP", uIP);
	        cache_get_value_name(zpl, "lalog", lalog);
	        TimestampToDate(vpt, y, m, d, h, i, s, 3);
	        cache_get_value_name_int(zpl, "reg_date", rd);
			cache_get_value_name(zpl, "last_ip", IP, 17);

			switch(vp)
			{
			    case 0: vip = "No";
			    case 1: vip = "Bronze(1)";
			    case 2: vip = "Silver(2)";
			    case 3: vip = "Gold(3)";
			}

		 	format(msg, sizeof(msg), "```\nName: %s - Kills: %d - Best Killstreak: %d\n", name, k, ksm);
		 	strcat(stats, msg);
			format(msg, sizeof(msg), "Wins: %d - Duel Wins: %d - Duel Loses: %d\n", rw, dw, dl);
			strcat(stats, msg);
	        if(d > 0) format(msg, sizeof(msg), "EXP: %d - VIP: %s - VIP Expire: %02dD/%02dM/%dY\n", xp, vip, d, m, y);
			else format(msg, sizeof(msg), "EXP: %d - VIP: %s - VIP Expire: ---\n", xp, vip);
			strcat(stats, msg);
			format(msg, sizeof(msg), "Gang: (ID %d)(Rank: %d) - Account ID: %d\n", cln, clnr, id);
	        strcat(stats, msg);
	        format(msg, sizeof(msg), "Registered IP: %s - Last Login: %s\n```", uIP, lalog);
	        strcat(stats, msg);
	        
			DCC_SendChannelMessageEx(DiscordChannel, stats);
			stats = "";

	 		TimestampToDate(rd, y, m, d, h, i, s, 3);
    		format(msg, sizeof(msg), "```\nRegistered: %04d-%02d-%02d - Last IP: %s\n```", y, m, d, IP);
			DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
	}
	else
	{
		DCC_SendChannelMessageEx(DiscordChannel, "```This player(s) is not found, check the data```");
	}
	#endif
	return 1;
}

fun CheckForIpsInDiscord(type)
{
    #if debug_mode == 0
    if(type == 0) DiscordChannel = DCC_FindChannelById("674323910648397894");
    else DiscordChannel = DCC_FindChannelById("613185790683513003");
    
	new size = cache_num_rows();
	if(size > 0)
	{
	    new i, User[MAX_PLAYER_NAME], id, query[164];
		for( i = 0; i < size; i++ )
 		{
	 	    cache_get_value_name(i, "Name", User, MAX_PLAYER_NAME);
	 	    cache_get_value_name_int(i, "ID", id);
			mysql_format(Base, query, sizeof(query), "SELECT `Name` FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", User);
	 	    if(type == 0) mysql_tquery(Base, query, "CheckForBan", "isiii", id, User, 1, -1, 1);
	 	    if(type == 1) mysql_tquery(Base, query, "CheckForBan", "isiii", id, User, 1, -1, 0);
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "No results found!");
	}
	#endif
	return 1;
}

fun MakeAdminOfflineDiscord(const userName[], const reason[], lvl)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("667021505846312960");
	if(cache_num_rows() > 0)
 	{
 	    new id, frm[128], query[164];
 	    cache_get_value_name_int(0, "Admin", id);
 	    if(id >= 5)
 	    {
 	        DCC_SendChannelMessageEx(DiscordChannel, "```!makeadminoffline (name) (0-4)```");
			return 1;
	    }
		mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Admin` = '%d' WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", lvl, reason);
		mysql_tquery(Base, query, "", "", "");
		format(frm, 128, "```\n>> %s set admin level of %s to %d\n```", userName, reason, lvl);
		DCC_SendChannelMessageEx(DiscordChannel, frm);
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```\nThis player is not found, check the data\n```");
	}
	#endif
	return 1;
}

fun CheckToUnbanIpFromDiscord(const reason[], const userName[])
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("667021505846312960");
	if(cache_num_rows() > 0)
	{
	    new query[128], msg[200];
 	    format(query, 128, "unbanip %s", reason);
		SendRconCommand(query);
		SendRconCommand("reloadbans");
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][142], userName, reason);
		mysql_format(Base, query, sizeof(query), "DELETE FROM `banip` WHERE `IP` = '%e'", reason);
		mysql_tquery(Base, query, "", "", "");
		
		format(msg, 128, "```yaml\n%s has unbanned IP %s\n```", userName, reason);
		DiscordChannel = DCC_FindChannelById("613185790683513003");
		DCC_SendChannelMessageEx(DiscordChannel, msg);
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```\nThis ip address is not blocked\n```");
	}
	#endif
	return 1;
}

fun TryToUnbanFromDiscord(const reason[], const userName[], type)
{
    #if debug_mode == 0
    if(type == 0) DiscordChannel = DCC_FindChannelById("667021505846312960");
    else DiscordChannel = DCC_FindChannelById("613185790683513003");
    
	if(cache_num_rows() > 0)
 	{
 	    new query[256], msg[200];
     	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][47], reason, userName);

   	    mysql_format(Base, query, sizeof(query), "UPDATE `banlog` SET `await`= '0',`unbanned` = '1',`untime` = '%d',`unadmin` = '%e' WHERE `name` = '%e'", gettime(), userName, reason);
		mysql_tquery(Base, query, "", "", "");

		mysql_format(Base, query, sizeof(query), "DELETE FROM `banlist` WHERE `Name` = '%e' AND `build`='"SERVER_BUILD"'", reason);
		mysql_tquery(Base, query, "", "", "");
		format(msg, 128, "```%s has been unbanned by %s```", reason, userName);
		DCC_SendChannelMessageEx(DiscordChannel, msg);

		DiscordChannel = DCC_FindChannelById("624580613697175582");
		format(query, sizeof query, "```\n%s has been unbanned by %s (IRC)\n```", reason, userName);
		DCC_SendChannelMessageEx(DiscordChannel, query);
	}
	else
	{
		DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
	}
	#endif
	return 1;
}

fun TryToBanNameFromDiscord(const user[], const reason[], const userName[])
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("667021505846312960");
	if(cache_num_rows() > 0)
	{
	    new id;
        cache_get_value_name_int(0, "ID", id);
        if(id > 0)
		{
			new query[300], msg[200];
		    mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',1,0,'"SERVER_BUILD"')", user, userName, reason);
			mysql_tquery(Base, query, "", "", "");

			mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`build`) VALUES ('%d','%e','%e','%d','%d','%d','%e','"SERVER_BUILD"')", id, userName, reason, 0, 1, gettime(), user);
			mysql_tquery(Base, query, "", "", "");

			format(msg, 128, "```%s has been banned by %s [Reason: %s]```", user, userName, reason);
			DCC_SendChannelMessageEx(DiscordChannel, msg);

			DiscordChannel = DCC_FindChannelById("619186196718944256");
 			format(msg, sizeof msg, "```\n%s has been banned by %s [Reason: %s]\n```", user, userName, reason);
  			DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
		else
		{
	    	DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
	}
	#endif
	return 1;
}

fun TryToRemovePlayerEXPFromDiscord(const userName[], percent)
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("667021505846312960");
	if(cache_num_rows() > 0)
 	{
  		new id, user[24], ex, frm[128], query[128];
		cache_get_value_name_int(0, "ID", id);
		cache_get_value_name(0, "Name", user);
		cache_get_value_name_int(0, "EXP", ex);

        new Float:tsena = float(ex), skidka = percent;
        ex -= floatround(((tsena/100)*skidka), floatround_round);
        
		mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `EXP` = '%d' WHERE `ID` = '%d'", max(0, ex), id);
		mysql_tquery(Base, query, "", "", "");

		format(frm, 128, "```\n>> %s took %d percents of %s's EXP\n```", userName, percent, user);
		DCC_SendChannelMessageEx(DiscordChannel, frm);

	   	foreach(Player, i)
		{
			if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s took %d percents of {FFFFFF}%s’s EXP", userName, percent, user);
			if(!strcmp(user, Player[i][UserName]))
			{
	    		Player[i][pXP] -= floatround(((tsena/100)*skidka), floatround_round);
	    		if(Player[i][pXP] <= -1) Player[i][pXP] = 0;
			}
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```\nThis player is not found, check the data\n```");
	}
	#endif
	return 1;
}

fun OfftbanUserInDiscord(const userName[], const name[], time, const reason[])
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("613185790683513003");
	if(cache_num_rows() > 0)
	{
	    new rank, id, query[264];
	   	cache_get_value_name_int(0, "Admin", rank);
	   	cache_get_value_name_int(0, "ID", id);
	   	if(rank >= 5)
  		{
		  	DCC_SendChannelMessageEx(DiscordChannel, "```Not enough rights```");
	    	return 1;
		}

        mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`,`await`) VALUES ('%e','%e','%e',0,'%d','"SERVER_BUILD"', '%d')", name, userName, reason, (time*3600)+gettime(), time);
		mysql_tquery(Base, query, "", "", "");

        mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`build`,`await`) VALUES ('%d','%e','%e','%d','%d','%d','%e','"SERVER_BUILD"', '%d')", id, userName, reason, (time*3600)+gettime(), 0, gettime(), name, time);
		mysql_tquery(Base, query, "", "", "");

        DiscordChannel = DCC_FindChannelById("613185790683513003");
  		format(query, sizeof query, "```\n%s has been banned by %s for %d hour(s) [Reason: %s] (offline)\n```", name, userName, time, reason);
   		DCC_SendChannelMessageEx(DiscordChannel, query);

		DiscordChannel = DCC_FindChannelById("619186196718944256");
  		format(query, sizeof query, "```\n%s has been banned by %s for %d hour(s) [Reason: %s]\n```", name, userName, time, reason);
   		DCC_SendChannelMessageEx(DiscordChannel, query);

   		foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][149], name, userName, time, reason);
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
	}
	#endif
	return 1;
}


fun UnbanIPFromDiscord(const userName[], const reason[])
{
    #if debug_mode == 0
	new query[128], msg[200];
    format(query, 128, "unbanip %s", reason);
	SendRconCommand(query);
	SendRconCommand("reloadbans");
	foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, serverLang[Player[i][pLang]][142], userName, reason);
	
	if(cache_num_rows() > 0)
 	{
		mysql_format(Base, query, sizeof(query), "DELETE FROM `banip` WHERE `IP` = '%e'", reason);
		mysql_tquery(Base, query, "", "", "");
	}
	
	format(msg, 128, "```yaml\n%s has unbanned IP %s\n```", userName, reason);
	DiscordChannel = DCC_FindChannelById("613185790683513003");
	DCC_SendChannelMessageEx(DiscordChannel, msg);
	#endif
	return 1;
}

fun BanNameInIRC(const userName[], const user[], const reason[])
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("613185790683513003");
	new id;
	if(cache_num_rows() > 0)
	{
        cache_get_value_name_int(0, "ID", id);
        if(id > 0)
		{
		    new msg[200], query[400];
		    mysql_format(Base, query, sizeof(query), "INSERT INTO `banlist` (`Name`,`Admin`,`Why`,`Permanent`,`Time`,`build`) VALUES ('%e','%e','%e',1,0,'"SERVER_BUILD"')", user, userName, reason);
			mysql_tquery(Base, query, "", "", "");

			mysql_format(Base, query, sizeof(query), "INSERT INTO `banlog` (`acc`,`admin`,`reason`,`time`,`perm`,`initiated`,`name`,`build`) VALUES ('%d','%e','%e','%d','%d','%d','%e','"SERVER_BUILD"')", id, userName, reason, 0, 1, gettime(), user);
			mysql_tquery(Base, query, "", "", "");

			format(msg, 128, "```%s has been banned by %s [Reason: %s]```", user, userName, reason);
			DCC_SendChannelMessageEx(DiscordChannel, msg);

			DiscordChannel = DCC_FindChannelById("619186196718944256");
 			format(msg, sizeof msg, "```\n%s has been banned by %s [Reason: %s]\n```", user, userName, reason);
  			DCC_SendChannelMessageEx(DiscordChannel, msg);
		}
		else
		{
	    	DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
		}
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "```This player is not found, check the data```");
	}
	#endif
	return 1;
}

fun DiscordGetIpFromPlayer(const reason[])
{
    #if debug_mode == 0
    DiscordChannel = DCC_FindChannelById("613185790683513003");
	if(cache_num_rows() > 0)
 	{
     	new IP[16], msg[200];
 	    cache_get_value_name(0, "IP", IP);
 	    format(msg, 128, "```yaml\n%s's IP %s\n```", reason, IP);
        DCC_SendChannelMessageEx(DiscordChannel, msg);
	}
	else
	{
	    DCC_SendChannelMessageEx(DiscordChannel, "No results found!");
	}
	#endif
	return 1;
}


fun GetTheNextMap()
{
    if(cache_num_rows() > 0)
 	{
 	    cache_get_value_name_int(0, "ID", maps);
 	    if(mapid == 31) mapid = 32;
	    if(mapid >= (maps+1)) mapid = 0;

		new query[128];
	    mysql_format(Base, query, sizeof(query), "SELECT `Name` FROM `maps` WHERE `ID` = '%i'", mapid);
		mysql_tquery(Base, query, "GetTheNextMapName");
	}
	return 1;
}

fun GetTheNextMapName()
{
    if(cache_num_rows() > 0)
    {
		new name[32];
		cache_get_value_name(0, "Name", name, 32);
		foreach(Player, i) SendClientMessageFormat(i,-1,serverLang[Player[i][pLang]][36], name);
	}
	return 1;
}

stock ShowGangClasses(playerid)
{
    return 1;
}

fun GetRulerGangClasses(playerid)
{
	return 1;
}

fun OnSetPlayerEmail(playerid, const inputtext[])
{
	if(cache_num_rows() > 0)
	{
		ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account\n\nEmail you typed already exists!", "Ok", "Back");
	}
	else
	{
		for( new i = strlen(inputtext); i > -1; i--)
		{
			if(inputtext[i] == ' ')
			{
			    ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account\n\nInvalid Email", "Ok", "Back");
				return 1;
			}
		}
		if(strfind(inputtext, "@") >= 3)
        {
			new query[164];
	        strmid(Player[playerid][pEmail], inputtext, false, strlen(inputtext), strlen(inputtext)+1);
	        mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `Email` = '%e' WHERE `ID` = '%d' AND `build`='"SERVER_BUILD"'", inputtext, Player[playerid][pAccountID]);
	        mysql_tquery(Base, query, "", "");
		}
		else
		{
		    ShowPlayerDialog(playerid, DIALOG_CREATE_MAIL, DIALOG_STYLE_INPUT, "Email", "Enter your new email address to be able to regain access to your account\n\nInvalid Email", "Ok", "Back");
			return 1;
		}
	}
	return 1;
}

fun OnCheckForRegisterOrRecovery(playerid, const inputtext[])
{
	if(cache_num_rows() > 0)
	{
	    new st[2][128], recovery[2][65];
		cache_get_value_name_int(0, "Language", Player[playerid][pLang]);
		cache_get_value_name(0, "Salt", recovery[0]);
		cache_get_value_name(0, "Secret", recovery[1]);
		cache_get_value_name(0, "Name", NM[playerid], MAX_PLAYER_NAME);
		format(st[0], 128, serverLang[Player[playerid][pLang]][53], 1);
		format(st[1], 128, serverLang[Player[playerid][pLang]][54], NM[playerid]);
		strmid(Player[playerid][pSalt], recovery[0], false, strlen(recovery[0]), strlen(recovery[0])+1);
		strmid(Player[playerid][pKey], recovery[1], false, strlen(recovery[1]), strlen(recovery[1])+1);
    	ShowPlayerDialog(playerid, DIALOG_RESTORE_ACCESS_0, DIALOG_STYLE_INPUT, st[0], st[1], serverLang[Player[playerid][pLang]][55], serverLang[Player[playerid][pLang]][56]);
        attemptsToLog[playerid] = 3;
	}
	else
	{
		strmid(Player[playerid][pEmail], inputtext, false, strlen(inputtext), strlen(inputtext)+1);
		new Head[48];
		format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 3);
	    ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_2, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][5], serverLang[Player[playerid][pLang]][4], serverLang[Player[playerid][pLang]][56]);
	}
	return 1;
}

fun OnCheckForPromocode(playerid)
{
	if(cache_num_rows())
	{
	    new query[400], id;
		cache_get_value_name_int(0, "ID", id);
		Player[playerid][pRefID] = id;
		
	 	mysql_format(Base, query, sizeof(query), "UPDATE `users` SET `ref` = '%d' WHERE `ID` = '%d'", id, Player[playerid][pAccountID]);
 	 	mysql_tquery(Base, query);
 	 	SignCreate(playerid);
 	 	
     	playerOnline++;
     	configureClass(playerid);
		setupZombie(playerid);
		SetSpawnInfo(playerid,TEAM_ZOMBIE,252,Map[ZombieSpawnX][0],Map[ZombieSpawnY][0],Map[ZombieSpawnZ][0],0.0,0,0,0,0,0,0);
		Registered{playerid} = true;
		Player[playerid][pLogged] = true;
	}
	else
	{
	    new Head[48];
		format(Head, 48, ServerRegisters[Player[playerid][pLang]][0], 4);
		ShowPlayerDialog(playerid, DIALOG_REGISTER_STEP_3, DIALOG_STYLE_INPUT, Head, ServerRegisters[Player[playerid][pLang]][11], ServerRegisters[Player[playerid][pLang]][10], ServerRegisters[Player[playerid][pLang]][12]);
	}
	return 1;
}

#if debug_mode == 0
fun DCC_SendChannelMessageEx(DCC_Channel:MessageChannel, const message[])
{
    DCC_SendChannelMessage(MessageChannel, message);
}
#endif

stock CreateGangHouse()
{
    new tmpobjid;
	tmpobjid = CreateDynamicObject(1536, 1236.279052, -666.875000, 1084.675903, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3603, "bevmans01_la", "lasbevcit7", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1237.025268, -671.441284, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1235.378906, -669.777099, 1086.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1238.668457, -669.820068, 1086.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1237.262939, -666.718688, 1086.347900, 0.000000, 0.000000, 90.239997, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(14409, 1237.065551, -681.418518, 1082.589233, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 5401, "jeffers4_lae", "flooringwd01_int", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1237.022705, -681.051635, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19394, 1234.122558, -675.470520, 1086.347900, 0.000000, 0.000000, -53.639999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1233.534790, -681.062072, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19394, 1229.557983, -679.804382, 1086.347900, 0.000000, 0.000000, -33.720008, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1231.642089, -677.444091, 1086.347900, 0.000000, 0.000000, -49.259990, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1233.530029, -671.443481, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1228.630737, -673.657714, 1086.347900, 0.000000, 0.000000, 38.700000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1231.035278, -670.290222, 1086.347900, 0.000000, 0.000000, 115.139968, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1230.044677, -671.436279, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1226.577392, -671.444091, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1230.055541, -681.048095, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1226.571166, -681.055297, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1223.106811, -671.486938, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 16103, "des_ne", "vgs_rockwall01_128", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1223.084106, -681.058837, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1224.045898, -680.118347, 1086.347900, 0.000000, 0.000000, 78.179946, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1223.940551, -676.160461, 1086.347900, 0.000000, 0.000000, 143.699935, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1230.655151, -681.405395, 1086.347900, 0.000000, 0.000000, 85.259918, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1235.355834, -683.337585, 1086.347900, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1238.672729, -683.331970, 1086.347900, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1233.469848, -688.068237, 1085.685546, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14786, "ab_sfgymbeams", "knot_wood128", 0x00000000);
	tmpobjid = CreateDynamicObject(19378, 1243.999267, -669.811340, 1084.605957, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 6094, "canalsg_law", "ws_sheetwood_clean", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1243.511962, -669.589965, 1086.347900, 0.000000, 0.000000, 90.360000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1245.263061, -669.741210, 1086.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(19450, 1246.529296, -674.559204, 1083.718383, 0.000000, 0.000000, 90.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(2127, 1242.868774, -670.179870, 1084.692016, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 8034, "vgsswarhse04", "GB_truckdepot14", 0x00000000);
	tmpobjid = CreateDynamicObject(2128, 1239.410888, -672.463806, 1084.692260, 0.000000, 0.000000, 90.900016, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 19513, "whitephone", "whitephone", 0x00000000);
	tmpobjid = CreateDynamicObject(2129, 1239.382690, -670.308105, 1084.640136, 0.000000, 0.000000, -269.880065, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 8034, "vgsswarhse04", "GB_truckdepot14", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 2, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	tmpobjid = CreateDynamicObject(2130, 1240.842529, -670.172180, 1084.548828, 0.000000, 0.000000, 0.300009, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 8034, "vgsswarhse04", "GB_truckdepot14", 0xFFFFFFFF);
	SetDynamicObjectMaterial(tmpobjid, 2, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	tmpobjid = CreateDynamicObject(2129, 1239.384277, -671.295227, 1084.640136, 0.000000, 0.000000, -269.580078, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 8034, "vgsswarhse04", "GB_truckdepot14", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 2, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	tmpobjid = CreateDynamicObject(2207, 1244.053222, -673.534179, 1084.679077, 0.000000, 0.000000, 179.879943, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14786, "ab_sfgymbeams", "knot_wood128", 0x00000000);
	tmpobjid = CreateDynamicObject(2125, 1241.999511, -673.571228, 1084.995727, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14653, "ab_trukstpb", "met_supp", 0x00000000);
	tmpobjid = CreateDynamicObject(2125, 1243.143920, -672.602111, 1084.995727, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14653, "ab_trukstpb", "met_supp", 0x00000000);
	tmpobjid = CreateDynamicObject(2125, 1244.197631, -673.608886, 1084.995727, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14653, "ab_trukstpb", "met_supp", 0x00000000);
	tmpobjid = CreateDynamicObject(19378, 1244.010620, -679.435974, 1084.605957, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14488, "dogsgym", "ah_yelplnks", 0x00000000);
	tmpobjid = CreateDynamicObject(19394, 1240.196411, -674.572265, 1086.347900, 0.000000, 0.000000, -89.819976, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(19450, 1246.609252, -674.559204, 1089.094970, 0.000000, 0.000000, 90.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1238.833862, -669.821472, 1086.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3595, "dingbat01_la", "bambowal1_LA", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1242.194213, -678.521972, 1086.347900, 0.000000, 0.000000, 132.779922, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1245.228027, -676.152160, 1086.347900, 0.000000, 0.000000, -1.259999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(1707, 1230.622314, -674.705810, 1084.653320, 0.000000, 0.000000, 128.700027, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14701, "lahss2int2", "WH_carpet4", 0x00000000);
	tmpobjid = CreateDynamicObject(2081, 1230.284423, -670.776428, 1084.694213, 0.000000, 0.000000, -155.640029, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14706, "labig2int2", "flooringwd02_int", 0x00000000);
	tmpobjid = CreateDynamicObject(2081, 1230.513305, -675.580017, 1084.694213, 0.000000, 0.000000, -52.500000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14706, "labig2int2", "flooringwd02_int", 0x00000000);
	tmpobjid = CreateDynamicObject(2184, 1226.449951, -678.038940, 1084.705444, 0.000000, 0.000000, 52.320011, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14771, "int_brothelint3", "GB_midbar09", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14771, "int_brothelint3", "GB_nastybar12", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1235.205810, -669.826782, 1086.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1228.753540, -673.547363, 1086.347900, 0.000000, 0.000000, 38.700000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(19579, 1226.169067, -677.661499, 1085.351806, 0.000000, 0.000000, -1.919999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF000000);
	tmpobjid = CreateDynamicObject(19610, 1226.164550, -677.669555, 1085.495971, -90.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xF0000000);
	tmpobjid = CreateDynamicObject(2269, 1226.167846, -677.189697, 1085.563476, 0.000000, 0.000000, 179.819931, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFFFFFFFF);
	tmpobjid = CreateDynamicObject(2269, 1226.139526, -678.169799, 1085.563476, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFFFFFFFF);
	tmpobjid = CreateDynamicObject(1574, 1227.267944, -672.679687, 1084.694335, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 4, 14668, "711c", "gun_ceiling3", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1235.355834, -683.337585, 1089.839111, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1238.672729, -683.331970, 1089.839111, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1230.600952, -684.945495, 1087.408691, 0.000000, 0.000000, 90.959907, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1238.648681, -689.720092, 1087.405761, 0.000000, 0.000000, -0.060079, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1233.869140, -692.933654, 1087.405761, 0.000000, 0.000000, 90.119903, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1229.059814, -689.804260, 1087.405761, 0.000000, 0.000000, -0.060079, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19786, 1232.355468, -684.942504, 1087.533813, 0.000000, 0.000000, 0.899999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 1560, "7_11_door", "CJ_CHROME2", 0x00000000);
	tmpobjid = CreateDynamicObject(2313, 1231.670043, -685.215881, 1085.764892, 0.000000, 0.000000, 1.320000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 2, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(1709, 1235.093505, -691.317138, 1085.773193, 0.000000, 0.000000, 180.480041, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14652, "ab_trukstpa", "CJ_CORD", 0xFFFFFFFF);
	tmpobjid = CreateDynamicObject(11724, 1229.591552, -688.310974, 1086.289550, 0.000000, 0.000000, 89.819999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 2, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	tmpobjid = CreateDynamicObject(19443, 1229.310302, -689.357604, 1084.332031, 0.000000, 0.000000, -88.379997, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14584, "ab_abbatoir01", "carpet5kb", 0x00000000);
	tmpobjid = CreateDynamicObject(19443, 1229.303710, -687.314514, 1084.332031, 0.000000, 0.000000, -88.379997, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14584, "ab_abbatoir01", "carpet5kb", 0x00000000);
	tmpobjid = CreateDynamicObject(970, 1228.022338, -689.313964, 1086.080932, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14584, "ab_abbatoir01", "ab_vent1", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14584, "ab_abbatoir01", "ab_vent1", 0x00000000);
	tmpobjid = CreateDynamicObject(970, 1227.992919, -687.286682, 1086.080932, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14584, "ab_abbatoir01", "ab_vent1", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14584, "ab_abbatoir01", "ab_vent1", 0x00000000);
	tmpobjid = CreateDynamicObject(2315, 1231.836791, -690.987121, 1085.772949, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14652, "ab_trukstpa", "wood01", 0xFFFFFFFF);
	tmpobjid = CreateDynamicObject(3498, 1233.671264, -684.750244, 1085.772216, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(3498, 1231.025634, -684.795043, 1085.772216, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(2230, 1234.001464, -685.872253, 1085.768676, 0.000000, 0.000000, -43.500000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 2, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(2230, 1231.215942, -685.531250, 1085.768676, 0.000000, 0.000000, 28.260009, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 2, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(3498, 1230.864257, -684.792297, 1088.318725, 0.000000, 90.000000, 0.899999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(3498, 1230.864257, -684.792297, 1086.769775, 0.000000, 90.000000, 0.899999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1238.624389, -688.066284, 1084.626831, 0.000000, 0.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1238.624389, -688.066284, 1090.379028, 0.000000, 0.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1229.129638, -688.144775, 1084.626831, 0.000000, 0.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1229.129638, -688.144775, 1090.379028, 0.000000, 0.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1234.037963, -692.893066, 1084.626831, 0.000000, 0.000000, 90.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1234.037963, -692.893127, 1090.379028, 0.000000, 0.000000, 90.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1230.601318, -684.948608, 1084.626831, 0.000000, 0.000000, 90.959999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1230.601318, -684.948608, 1090.379028, 0.000000, 0.000000, 90.959999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19355, 1232.584716, -688.374145, 1085.688232, 0.000000, 90.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14803, "bdupsnew", "Bdup2_Rug", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1237.118652, -689.570617, 1087.405761, 0.000000, 0.000000, -21.000070, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1236.884765, -690.134155, 1084.626831, 0.000000, 0.000000, -21.120000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(19463, 1237.234985, -689.261962, 1090.379028, 0.000000, 0.000000, -21.000009, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2755, "ab_dojowall", "mp_apt1_roomfloor", 0x00000000);
	tmpobjid = CreateDynamicObject(640, 1236.734985, -689.182495, 1086.405639, 0.000000, 0.000000, 158.559936, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 19622, "broom1", "cj_smallbat", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFF439909);
	SetDynamicObjectMaterial(tmpobjid, 2, 19622, "broom1", "cj_smallbat", 0x00000000);
	tmpobjid = CreateDynamicObject(2010, 1234.337768, -685.491027, 1085.771850, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF439909);
	tmpobjid = CreateDynamicObject(2010, 1230.497558, -685.494628, 1085.771850, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, -1, "none", "none", 0xFF439909);
	tmpobjid = CreateDynamicObject(11724, 1229.213989, -688.310607, 1086.289550, 0.000000, 0.000000, 89.820037, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 2, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	tmpobjid = CreateDynamicObject(19443, 1229.139526, -688.259643, 1088.367797, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 3314, "ce_burbhouse", "sw_wallbrick_06", 0x00000000);
	tmpobjid = CreateDynamicObject(2259, 1234.182861, -680.598327, 1085.467529, 0.000000, 0.000000, 173.160079, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 1569, "adam_v_doort", "ws_guardhousedoor", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14737, "whorewallstuff", "ah_painting1", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 2, 1569, "adam_v_doort", "ws_guardhousedoor", 0x00000000);
	tmpobjid = CreateDynamicObject(2125, 1233.868896, -680.388183, 1085.009033, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14652, "ab_trukstpa", "mp_diner_wood", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14650, "ab_trukstpc", "Gen_Sacki", 0x00000000);
	tmpobjid = CreateDynamicObject(1819, 1234.359741, -681.071105, 1084.693481, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14650, "ab_trukstpc", "Gen_Sacki", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 14652, "ab_trukstpa", "mp_diner_wood", 0x00000000);
	tmpobjid = CreateDynamicObject(640, 1238.202880, -671.962829, 1085.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 19622, "broom1", "cj_smallbat", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFF439909);
	tmpobjid = CreateDynamicObject(640, 1235.844848, -671.876342, 1085.347900, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 19622, "broom1", "cj_smallbat", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFF439909);
	tmpobjid = CreateDynamicObject(2257, 1231.657226, -677.589721, 1086.465454, 0.000000, 0.000000, 40.619968, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 19525, "weddingcake1", "bngdecoration1", 0x00000000);
	tmpobjid = CreateDynamicObject(2257, 1238.528076, -684.480163, 1087.458007, 0.000000, 0.000000, -90.299949, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14737, "whorewallstuff", "AH_paintbond", 0x00000000);
	tmpobjid = CreateDynamicObject(11714, 1241.735717, -678.796875, 1086.284667, 0.000000, 0.000000, -47.520011, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18028, "cj_bar2", "GB_nastybar13", 0x00000000);
	tmpobjid = CreateDynamicObject(19439, 1240.503417, -679.979858, 1085.856323, 0.000000, 0.000000, -47.700000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14713, "lahss2aint2", "HS2_Curt3", 0x00000000);
	tmpobjid = CreateDynamicObject(19439, 1242.993652, -677.692138, 1085.842895, 0.000000, 0.000000, -47.700000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14713, "lahss2aint2", "HS2_Curt3", 0x00000000);
	tmpobjid = CreateDynamicObject(19962, 1240.858032, -679.646057, 1087.562744, 0.000000, 90.000000, 42.780010, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 2562, "cj_hotel_sw", "CJ-COUCHL1", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, 2562, "cj_hotel_sw", "CJ-COUCHL1", 0x00000000);
	tmpobjid = CreateDynamicObject(638, 1241.502075, -678.546569, 1085.383056, 0.000000, 0.000000, -47.459999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 19622, "broom1", "cj_smallbat", 0x00000000);
	SetDynamicObjectMaterial(tmpobjid, 1, -1, "none", "none", 0xFF439909);
	tmpobjid = CreateDynamicObject(19379, 1233.469848, -688.068237, 1090.054443, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1226.668579, -676.835449, 1088.174194, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1237.157714, -676.867004, 1088.174194, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1231.389770, -667.228149, 1088.174194, 0.000000, 90.000000, -0.300000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1241.856323, -667.257019, 1088.174194, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19379, 1247.655273, -676.895141, 1088.174194, 0.000000, 90.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1237.011230, -682.720642, 1089.484741, 0.000000, -40.000000, 89.939987, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18065, "ab_sfammumain", "plywood_gym", 0x00000000);
	tmpobjid = CreateDynamicObject(19356, 1238.683959, -680.139099, 1089.839111, 0.000000, 0.000000, -0.600000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 18787, "matramps", "cardboard4", 0x00000000);
	tmpobjid = CreateDynamicObject(19448, 1230.655151, -681.405395, 1089.779785, 0.000000, 0.000000, 85.259918, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 0, 14777, "int_casinoint3", "GB_midbar05", 0x00000000);
	tmpobjid = CreateDynamicObject(1494, 1233.550048, -675.944580, 1084.590576, 0.000000, 0.000000, 36.360000, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14581, "ab_mafiasuitea", "wood02S", 0x00000000);
	tmpobjid = CreateDynamicObject(1494, 1229.189208, -680.448730, 1084.590576, 0.000000, 0.000000, 57.299999, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 14581, "ab_mafiasuitea", "wood02S", 0x00000000);
	tmpobjid = CreateDynamicObject(2257, 1229.674438, -674.423034, 1086.941040, 0.000000, 0.000000, 128.760131, -1, -1, -1, 300.00, 300.00);
	SetDynamicObjectMaterial(tmpobjid, 1, 18835, "mickytextures", "smileyface2", 0x00000000);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	tmpobjid = CreateDynamicObject(19325, 1244.780639, -674.582580, 1086.032470, 0.000000, 0.000000, 89.999969, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2142, 1233.008789, -669.599548, 1084.692504, 0.000000, 0.000000, 26.640050, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2025, 1234.692382, -669.526245, 1084.692260, 0.000000, 0.000000, -90.240020, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2299, 1232.293945, -673.627136, 1084.692871, 0.000000, 0.000000, 24.720010, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(14455, 1226.398925, -673.012573, 1086.318359, 0.000000, 0.000000, -126.480026, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(14455, 1223.006835, -677.670532, 1086.318359, 0.000000, 0.000000, -126.480026, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(14455, 1230.807250, -676.707458, 1086.318359, 0.000000, 0.000000, -231.480026, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(1714, 1225.827148, -676.172851, 1084.659912, 0.000000, 0.000000, 48.720020, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2066, 1223.518310, -679.804809, 1084.693847, 0.000000, 0.000000, -12.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2066, 1224.098388, -679.915100, 1084.693847, 0.000000, 0.000000, -12.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2066, 1224.695190, -680.036682, 1084.693847, 0.000000, 0.000000, -12.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2066, 1225.292602, -680.160827, 1084.693847, 0.000000, 0.000000, -12.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(1428, 1226.011474, -674.329895, 1085.943115, 0.000000, 0.000000, 53.520019, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19808, 1226.234130, -677.343688, 1085.494506, 0.000000, 0.000000, 177.539978, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2894, 1226.754516, -676.858154, 1085.480224, 0.000000, 0.000000, -122.279937, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11705, 1227.152832, -676.060546, 1085.448852, 0.000000, 0.000000, -93.660003, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19174, 1226.986938, -680.653991, 1086.901489, 0.000000, 0.000000, -191.879989, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2001, 1228.665771, -680.316406, 1084.693237, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2001, 1229.929687, -678.563232, 1084.693237, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19894, 1227.223144, -676.494995, 1085.480224, 0.000000, 0.000000, -57.179969, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19172, 1226.948852, -680.901367, 1085.589111, 90.000000, 0.000000, 168.660095, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1228.205566, -680.773132, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19821, 1227.684570, -680.653747, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.330322, -680.597961, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.848632, -680.478942, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1228.263916, -680.557006, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1228.046142, -680.759826, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1228.104370, -680.543640, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1227.889770, -680.706542, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1227.946777, -680.510498, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19821, 1227.722778, -680.436096, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19821, 1227.508544, -680.598937, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19821, 1227.545043, -680.401123, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.386962, -680.401794, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.171020, -680.584716, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.229370, -680.368591, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.036254, -680.513244, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1227.071655, -680.335327, 1085.603271, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.876708, -680.365844, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.654296, -680.392089, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.695800, -680.254028, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.918212, -680.227783, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.445800, -680.393371, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.506225, -680.249389, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.308959, -680.288818, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1226.357788, -680.106750, 1085.603271, 0.000000, 0.000000, -8.699999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11725, 1229.564453, -688.312133, 1086.063476, 0.000000, 0.000000, 88.739990, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19825, 1229.285156, -688.261352, 1087.962280, 0.000000, 0.000000, 89.820022, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2283, 1229.222412, -690.565185, 1087.727905, 0.000000, 0.000000, 89.759986, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2712, 1234.007568, -681.210937, 1085.163574, 1.440000, -15.779999, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2712, 1233.885375, -681.178771, 1085.163574, 4.739999, -4.980000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2712, 1234.149536, -681.241882, 1085.105834, -1.320000, -28.379980, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19173, 1232.245361, -681.215698, 1085.050170, 40.000000, 0.000000, -4.320000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2847, 1237.524902, -670.670898, 1084.694458, 0.000000, 0.000000, 89.699996, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2847, 1237.518310, -672.616760, 1084.694458, 0.000000, 0.000000, 89.699996, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2847, 1237.515991, -674.583618, 1084.694458, 0.000000, 0.000000, 89.699996, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2345, 1232.385253, -685.056518, 1086.625366, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19172, 1245.395751, -671.892211, 1085.264526, 90.000000, 0.000000, -90.480003, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19172, 1245.536621, -671.886413, 1085.895751, 90.000000, 0.000000, -90.480003, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19172, 1245.658325, -671.891967, 1086.498657, 90.000000, 0.000000, -90.480003, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.942382, -670.736755, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.943237, -670.908752, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.959228, -671.069335, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.951904, -671.214782, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.953369, -671.399169, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.969482, -671.559570, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1245.005981, -671.715393, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.990478, -671.864440, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.741577, -670.740234, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.768310, -670.903137, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19820, 1244.775390, -671.064270, 1085.277954, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.077148, -671.410034, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.003051, -671.194396, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.912353, -671.459289, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.081665, -671.644104, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.916870, -671.693298, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.092529, -671.859130, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.940551, -671.870666, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.946411, -672.050476, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.071655, -670.986022, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1245.010864, -672.188232, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.852661, -672.253540, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1244.957763, -672.390258, 1085.909179, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.087036, -672.228332, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.061279, -672.406982, 1086.512329, 0.000000, 0.000000, -86.520011, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.027709, -673.088317, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.074829, -672.893188, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1244.975952, -672.879455, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.105712, -672.675048, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1244.972290, -672.616088, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1244.962158, -672.393249, 1086.512329, 0.000000, 0.000000, -86.520011, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1244.996337, -672.155090, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19823, 1245.092041, -672.047302, 1086.512329, 0.000000, 0.000000, -86.460006, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19172, 1240.969604, -669.415832, 1086.445678, 90.000000, 0.000000, -0.059999, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11718, 1242.012329, -669.881835, 1086.473876, 0.000000, 0.000000, 34.019931, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11719, 1241.698486, -669.912170, 1086.459350, 0.000000, 0.000000, 34.679981, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11719, 1241.438964, -669.907775, 1086.459350, 0.000000, 0.000000, 34.799980, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(11719, 1241.183105, -669.858703, 1086.459350, 0.000000, 0.000000, 34.679981, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2267, 1231.990356, -681.395874, 1086.677368, 0.000000, 0.000000, 175.319976, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2265, 1230.949462, -680.848815, 1086.888061, 0.000000, 0.000000, 173.339904, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2266, 1230.793701, -680.823059, 1086.213134, 0.000000, 0.000000, 175.139785, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19806, 1232.762939, -688.168823, 1089.211791, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19583, 1240.641723, -669.880493, 1085.594482, -1.320000, 0.059999, -33.599998, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19583, 1240.724731, -669.913269, 1085.594482, -1.320000, 0.059999, -33.599998, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19583, 1240.829467, -669.964233, 1085.594482, -1.320000, 0.059999, -33.599998, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2822, 1241.192382, -670.044555, 1085.594482, 0.000000, 0.000000, 20.040000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19581, 1239.521728, -670.123535, 1085.686035, 0.000000, 0.000000, -52.259990, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19585, 1239.196289, -671.138732, 1085.885131, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19569, 1243.541870, -673.596069, 1085.455566, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19561, 1243.235839, -673.744995, 1085.455444, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2829, 1243.048828, -673.412536, 1085.455566, 0.000000, 0.000000, 212.699951, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2863, 1240.653320, -669.979919, 1086.458862, 0.000000, 0.000000, 40.439998, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19585, 1240.208740, -670.013305, 1086.662963, 0.000000, 0.000000, -98.579986, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(1210, 1234.980224, -680.474914, 1085.290527, 90.000000, 0.000000, -69.839988, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(1893, 1237.197387, -671.491943, 1088.355590, 0.000000, 0.000000, 91.439987, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(1893, 1242.928222, -672.048095, 1088.355590, 0.000000, 0.000000, 179.099960, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2069, 1227.641723, -675.516235, 1084.705810, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2853, 1233.183227, -690.940246, 1086.266967, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19824, 1231.854125, -690.927795, 1086.266967, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(19818, 1231.970703, -691.044860, 1086.351318, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2855, 1231.407836, -675.582397, 1084.746948, 0.000000, 0.000000, -5.760000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2855, 1230.064819, -671.549926, 1084.746948, 0.000000, 0.000000, -5.760000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2069, 1228.242431, -672.238708, 1084.707519, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2372, 1234.954467, -673.303710, 1084.692871, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2394, 1234.737060, -672.648254, 1085.421142, 0.000000, 0.000000, 90.059997, -1, -1, -1, 300.00, 300.00);
	tmpobjid = CreateDynamicObject(2845, 1231.510131, -672.103454, 1085.389648, 0.000000, 0.000000, 0.000000, -1, -1, -1, 300.00, 300.00);
    CreateObject(18692, 1229.32, -688.47, 1081.27, 0.00, 0.00, 0.00, 300.0);
}

fun SAMP_AC_SEND_WARNING_FOR_MODE(CALLERID, const SAMP_AC_NAME[], SAMP_AC_CODE, SAMP_AC_DOOM)
{
    if(gettime() > AntiCheat[CALLERID][ac_Tick])
    {
		foreach(Player, p)
	    {
	        if(Player[p][pAdmin] > 0 && Player[p][pLogged])
	        {
	            SendClientMessageFormat(p, -1, "{6A8EE2}>> %s(%d) supposedly uses %s", Player[CALLERID][UserName], CALLERID, SAMP_AC_NAME);
	        }
	    }
	    // if(AntiCheatAlertMode) SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Hacks? Type:{FFFFFF} yes, Amelia{FFF000} if he/she is.", Player[CALLERID][UserName], CALLERID);
	    AntiCheat[CALLERID][ac_Tick] = gettime()+1;
	}
    return true;
}

//[Кэлбэк оповещения о смерте игрока от огнестрельного оружия]
//forward SAMP_AC_PLAYER_DEATH(playerid, killerid, reason);
fun SAMP_AC_PLAYER_DEATH(playerid, killerid, reason)
{
	/*У кого AMX вставляем весь код из OnPlayerDeath(CTRL + C && CTRL + V), а из OnPlayerDeath не чего не удаляем!
	У кого PWN не надо создавать кэлбэк, он уже есть в античите и тоже самое (CTRL + C && CTRL + V)*/
	return true;
}

fun AC_CheckForAntiExplosions(playerid)
{
    if(Player[playerid][aDuty] || AFK[playerid] >= -2) {}
    else
    {
		if(AntiCheat[playerid][ex_OldHP] != 0.00)
		{
			new Float:zw;
		    GetPlayerHealthEx(playerid, zw);
			if(zw >= AntiCheat[playerid][ex_OldHP])
			{
			    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Health Hack (Explosions)", Player[playerid][UserName], playerid);
		        strmid(AC_Requests[playerid][ac_reason], "Health Hack", 0, 128, 128);
				AC_Requests[playerid][ac_time] = gettime();
				AC_Requests[playerid][ac_type] = 0;
				AC_Requests[playerid][ac_additional] = 0;
				AC_Requests[playerid][ac_pl] = NetStats_PacketLossPercent(playerid);
				AntiCheat[playerid][ac_Tick] = (gettime()+1);
				
				if(AntiCheatAlertMode)
				{
				    ++AntiCheat[playerid][ac_ex_warns];
				    if(AntiCheat[playerid][ac_ex_warns] > AC_MAX_EXPLOSION_PROOF_WARNINGS && AntiCheat[playerid][ac_health_hack] >= AC_MAX_REPORTS) BanPlayer(playerid, "Health Hack - Consensus");
				}
			}
		}
	}
	AntiCheat[playerid][ex_OldHP] = 0.0;
}

stock SendToBulletCheck(playerid)
{
	GetPlayerHealthEx(playerid, AntiCheat[playerid][weap_OldHP]);
	SetTimerEx("AC_CheckForAntiBullets", 4000, 0, "i", playerid);
}

fun AC_CheckForAntiBullets(playerid)
{
    if(Player[playerid][aDuty] || AFK[playerid] >= -2) {}
    else
    {
		if(AntiCheat[playerid][weap_OldHP] >= -99.0)
		{
			new Float:zw;
		    GetPlayerHealthEx(playerid, zw);
			if(zw >= AntiCheat[playerid][weap_OldHP] && AntiCheat[playerid][weap_OldHP] >= 2.5)
			{
			    AntiCheat[playerid][weap_bp_ticks]++;
			    if(AntiCheat[playerid][weap_bp_ticks] >= 3)
			    {
				    foreach(Player, i) if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Health Hack (Bullet Proof)", Player[playerid][UserName], playerid);
			        strmid(AC_Requests[playerid][ac_reason], "Health Hack", 0, 128, 128);
					AC_Requests[playerid][ac_time] = gettime();
					AC_Requests[playerid][ac_type] = 0;
					AC_Requests[playerid][ac_additional] = 0;
					AC_Requests[playerid][ac_pl] = NetStats_PacketLossPercent(playerid);
					AntiCheat[playerid][ac_Tick] = (gettime()+1);
					AntiCheat[playerid][weap_bp_ticks] = 0;
					
					if(AntiCheatAlertMode) SendMessageFormatToAll(-1, "{FFF000}Amelia[BOT]: Is %s(%d) uses Bullet Proof? Type:{FFFFFF} /report %d BP{FFF000} if he/she is.", Player[playerid][UserName], playerid, playerid);
				}
			}
			
			if(AntiCheatAlertMode)
			{
			    ++AntiCheat[playerid][ac_bp_warns];
			    if(AntiCheat[playerid][ac_bp_warns] > AC_MAX_BULLET_PROOF_WARNINGS && AntiCheat[playerid][ac_health_hack] >= AC_MAX_REPORTS) BanPlayer(playerid, "Health Hack - Consensus");
			}
		}
	}
	AntiCheat[playerid][weap_OldHP] = -100.0;
}

stock IsValueNotAString(const str[])
{
	new i;
	for( i = strlen(str); i > -1; i-- ) if(str[i] == '%') return 1;
	for( i = strlen(str); i > -1; i-- ) if('0' <= str[i] <= '9') return 1;

	return 0;
}

stock StringHasSpaces(const str[])
{
	for( new i = 0; i < strlen(str); i++ ) if(str[i] == ' ') return 1;
	return 0;
}

new AC_ReasonFor[] =
{
	ac_weapon_hack, ac_weapon_hack, ac_weapon_hack,
	ac_weapon_hack, ac_weapon_hack, ac_weapon_hack,
	
	ac_teleport_hack, ac_teleport_hack, ac_teleport_hack,
	
	ac_jump_hack, ac_jump_hack, ac_jump_hack,
	ac_jump_hack, ac_jump_hack,
	
	ac_airbreak_hack, ac_airbreak_hack,
	ac_airbreak_hack, ac_airbreak_hack, ac_airbreak_hack,
	
	ac_airbreak_hack, ac_airbreak_hack, ac_airbreak_hack,
	
	ac_health_hack, ac_health_hack, ac_health_hack,
	ac_health_hack, ac_health_hack, ac_health_hack,
	
	ac_parkour, ac_parkour, ac_parkour, ac_parkour
};

static const ac_bans[][] =
{
	"WH","Weapon","Weapon Hack",
	"AM","Ammo","Ammo Hack",
	
	"TP","Teleport","Teleport Hack",

	"JH","Jump Hack","Jump",
	"Slap","Slapper",

	"AB","AirBreak",
	"Fly", "FH", "Fly Hack",

	"SH", "Speed Hack", "Speed",

	"HH", "Health", "Health Hack",
	"GM", "God", "God mode",
	
	"PM", "Parkour", "Parkour Hack", "Parkour Mode"
};

stock AC_CompareScales(playerid, reportedid, const reason[])
{
	if(!IsPlayerConnected(playerid)) return 0;
	if(!IsPlayerConnected(reportedid)) return 0;
	for( new i = 0; i < sizeof(ac_bans); i++)
	{
	    if(!strcmp(ac_bans[i], reason, false))
	    {
            ++AntiCheat[reportedid][e_ac:AC_ReasonFor[i]];
            return 1;
	    }
	}
	return 1;
}

fun Drugsoff(playerid)
{
    SetCameraBehindPlayer(playerid);
	SetPlayerDrunkLevel(playerid, 0);
	SetPlayerWeather(playerid, Map[m_Weather]);
	SetPlayerTime(playerid,Map[m_Time],0);
	
    return 0;
}

public OnIncomingPacket(playerid, packetid, BitStream:bs)
{
	switch(packetid)
	{
    	case 200:
     	{
            new ac_cData[RAKNET_DRIVER_SYNC];
            BS_IgnoreBits(bs, 8);
            BS_ReadInCarSync(bs, ac_cData);
            if(!(1 <= ac_cData[RAKNET_VEHICLE] < MAX_VEHICLES))
            {
                foreach(Player, i)
			    {
			        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Vehicle Crasher #1", Player[playerid][UserName], playerid);
				}
				PlayerKick(playerid);
            }
            BS_ResetReadPointer(bs);
        }
        case 203:
        {
            new ac_aData[PR_AimSync];
            BS_IgnoreBits(bs, 8);
            BS_ReadAimSync(bs, ac_aData);
            if(ac_aData[PR_aimZ] != ac_aData[PR_aimZ])
            {
                ac_aData[PR_aimZ] = 0.0;
                BS_SetWriteOffset(bs, 8);
                BS_WriteAimSync(bs, ac_aData);
                BS_ResetWritePointer(bs);
            }
            BS_ResetReadPointer(bs);
        }
        case 207:
        {
            new ac_fData[RAKNET_ONFOOT_SYNC];
            BS_IgnoreBits(bs, 8);
            BS_ReadOnFootSync(bs, ac_fData);
            
            if(ac_fData[RAKNET_QUATERION_X] > 1.0 || ac_fData[RAKNET_QUATERION_X] < -1.0
			|| ac_fData[RAKNET_QUATERION_Y] > 1.0 || ac_fData[RAKNET_QUATERION_Y] < -1.0
			|| ac_fData[RAKNET_QUATERION_Z] > 1.0 || ac_fData[RAKNET_QUATERION_Z] < -1.0
			|| ac_fData[RAKNET_QUATERION_R] > 1.0 || ac_fData[RAKNET_QUATERION_R] < -1.0)
			{
				foreach(Player, i)
			    {
			        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Quaterion Crasher #1", Player[playerid][UserName], playerid);
				}
				BS_ResetReadPointer(bs);
				return 0;
			}
            
            if(ac_fData[RAKNET_SURFING_X] != ac_fData[RAKNET_SURFING_X] ||
            ac_fData[RAKNET_SURFING_Y] != ac_fData[RAKNET_SURFING_Y] ||
            ac_fData[RAKNET_SURFING_Z] != ac_fData[RAKNET_SURFING_Z])
            {
                ac_fData[RAKNET_SURFING_X] =
                ac_fData[RAKNET_SURFING_Y] =
                ac_fData[RAKNET_SURFING_Z] = 0.0;
                ac_fData[RAKNET_SURFING_CAR_ID] = 0;
                BS_SetWriteOffset(bs, 8);
                BS_WriteOnFootSync(bs, ac_fData);
                BS_ResetWritePointer(bs);
            }
            BS_ResetReadPointer(bs);
        }
        case 209:
        {
            new ac_uData[PR_UnoccupiedSync];
            BS_IgnoreBits(bs, 8);
            BS_ReadUnoccupiedSync(bs, ac_uData);
            if(ac_uData[PR_seatId] > 0 &&
            (!IsPlayerInVehicle(playerid, ac_uData[PR_vehicleId])) ||
            ac_uData[PR_roll][0] != ac_uData[PR_roll][0] ||
            ac_uData[PR_roll][1] != ac_uData[PR_roll][1] ||
            ac_uData[PR_roll][2] != ac_uData[PR_roll][2] ||
            ac_uData[PR_direction][0] != ac_uData[PR_direction][0] ||
            ac_uData[PR_direction][1] != ac_uData[PR_direction][1] ||
            ac_uData[PR_direction][2] != ac_uData[PR_direction][2] ||
            ac_uData[PR_angularVelocity][0] != ac_uData[PR_angularVelocity][0] ||
            ac_uData[PR_angularVelocity][1] != ac_uData[PR_angularVelocity][1] ||
            ac_uData[PR_angularVelocity][2] != ac_uData[PR_angularVelocity][2] ||
            floatabs(ac_uData[PR_roll][0]) >= 1.0 ||
            floatabs(ac_uData[PR_roll][1]) >= 1.0 ||
            floatabs(ac_uData[PR_roll][2]) >= 1.0 ||
            floatabs(ac_uData[PR_direction][0]) >= 1.0 ||
            floatabs(ac_uData[PR_direction][1]) >= 1.0 ||
            floatabs(ac_uData[PR_direction][2]) >= 1.0 ||
            floatabs(ac_uData[PR_angularVelocity][0]) >= 1.0 ||
            floatabs(ac_uData[PR_angularVelocity][1]) >= 1.0 ||
            floatabs(ac_uData[PR_angularVelocity][2]) >= 1.0 ||
            ac_uData[PR_roll][0] == ac_uData[PR_direction][0] &&
            ac_uData[PR_roll][1] == ac_uData[PR_direction][1] &&
            ac_uData[PR_roll][2] == ac_uData[PR_direction][2]) return 0;
            BS_ResetReadPointer(bs);
        }
		case 211:
        {
            new ac_pData[RAKNET_PASSENGER_SYNC];
            BS_IgnoreBits(bs, 8);
            BS_ReadPassengerSync(bs, ac_pData);
            if(ac_pData[PR_seatId] < 1 || !(1 <= ac_pData[RAKNET_VEHICLE] < MAX_VEHICLES))
            {
                foreach(Player, i)
			    {
			        if(Player[i][pAdmin] > 0 && Player[i][pLogged]) SendClientMessageFormat(i, -1, "{6A8EE2}>> %s(%d) supposedly uses Vehicle Crasher #3", Player[playerid][UserName], playerid);
				}
				PlayerKick(playerid);
            }
            BS_ResetReadPointer(bs);
        }
	}
    return 1;
}

enum eDisabledKeys
{
    Disable_LeftKey,
    Disable_RightKey,
    Disable_UpKey,
    Disable_DownKey,
    Disabled_Keys
};

new gPlayerDisabledKeys[MAX_PLAYERS][eDisabledKeys];

stock ProcessDisabledKeys(playerid, &lrKey, &udKey, &keys)
{
    if (
        (lrKey == KEY_LEFT && gPlayerDisabledKeys[playerid][Disable_LeftKey]) ||
        (lrKey == KEY_RIGHT && gPlayerDisabledKeys[playerid][Disable_RightKey])
    ) {
        lrKey = 0;
    }

    if (
        (udKey == KEY_UP && gPlayerDisabledKeys[playerid][Disable_UpKey]) ||
        (udKey == KEY_DOWN && gPlayerDisabledKeys[playerid][Disable_DownKey])
    ) {
        udKey = 0;
    }

    keys &= ~gPlayerDisabledKeys[playerid][Disabled_Keys];
}

stock SetPlayerDisableKeysSync(playerid, keys, left = false, right = false, up = false, down = false)
{
    gPlayerDisabledKeys[playerid][Disable_LeftKey] = left;
    gPlayerDisabledKeys[playerid][Disable_RightKey] = right;
    gPlayerDisabledKeys[playerid][Disable_UpKey] = up;
    gPlayerDisabledKeys[playerid][Disable_DownKey] = down;

    gPlayerDisabledKeys[playerid][Disabled_Keys] = keys;
}
stock KickGangMembers()
{
	new query[300], DAYS = 14;
    mysql_format(Base, query, sizeof(query), "SELECT userinfo.last_log, userinfo.id FROM `userinfo` JOIN `users` ON users.id = userinfo.id WHERE `last_log` < %d - (86400*%d) AND users.ClanRank < 5 AND users.Clan > 0", gettime(), DAYS);
	mysql_tquery(Base, query, "KickMembers", "i", playerid);
}

// SELECT users.id FROM `users` JOIN `userinfo` ON users.id = userinfo.id WHERE `last_log` < 1577395469 - (86400*30) AND users.ClanRank < 5 AND users.Clan > 0

// UPDATE `users` SET Clan = 0, ClanRank = 0 WHERE ID = (SELECT users.id FROM `users` JOIN `userinfo` ON users.id = userinfo.id WHERE `last_log` < 1590942456 - (86400 * 30) AND users.ClanRank < 5 AND users.Clan > 0)

//UPDATE `users` SET `Clan=0, ClanRank=0` WHERE `users`.`ID` = (SELECT userinfo.id FROM `userinfo` JOIN `users` ON users.id = userinfo.id WHERE `last_log` < %d - (86400*%d) AND users.ClanRank < 5 AND users.Clan > 0

fun IsOldUser(playerid)
{
	if(cache_num_rows())
	{
	    switch(Player[playerid][pLang])
	    {
	        case 0:
	        {
				SendClientMessage(playerid, -1, "{0080ff}>> Welcome back!");
				SendClientMessage(playerid, -1, "{0080ff}>> We noticed that you haven't joined the server for a long time");
				SendClientMessage(playerid, -1, "{0080ff}>> And we give you a bonus to make it easier to get into operation!");
				SendClientMessage(playerid, -1, "{0080ff}>> Check your {FFF000}Inventory{FFFFFF}(/inv)");
			}
			case 1:
	        {
				SendClientMessage(playerid, -1, "{0080ff}>> Сколько лет, сколько зим!");
				SendClientMessage(playerid, -1, "{0080ff}>> Мы заметили, что вы не заходили на сервер в течении долгого времени");
				SendClientMessage(playerid, -1, "{0080ff}>> И даём вам бонус, чтобы вы быстрее пришли в былой строй!");
				SendClientMessage(playerid, -1, "{0080ff}>> Проверьте ваш {FFF000}Инвентарь{FFFFFF}(/inv)");
			}
			case 2:
	        {
				SendClientMessage(playerid, -1, "{0080ff}>> Dar una buena acogida!");
				SendClientMessage(playerid, -1, "{0080ff}>> Notamos que no te has unido al servidor por mucho tiempo");
				SendClientMessage(playerid, -1, "{0080ff}>> Y le damos una bonificacion para que sea mas facil entrar en funcionamiento!");
				SendClientMessage(playerid, -1, "{0080ff}>> Revisar su {FFF000}Inventario{FFFFFF}(/inv)");
			}
		}
		
		new query[256];
		mysql_format(Base, query, sizeof(query), "UPDATE `userinfo` SET `last_log`='%d' WHERE `id` = '%d'", gettime(), Player[playerid][pAccountID]);
		mysql_tquery(Base, query, "", "", "");
	}
	return 1;
}

stock GetPlayerVirtualWorldForPlayer(playerid) return PR_VirtualWorldForPlayer[playerid];
stock SetPlayerVirtualWorldForPlayer(toplayerid, playerid, worldid)
{
    PR_VirtualWorldForPlayer[playerid] = worldid;

    new BitStream:bs = BS_New();

    if(worldid != 0)
    {
	    BS_WriteValue(
	        bs,
	        PR_UINT16,
			playerid
	    );

	    BS_SetWriteOffset(bs, worldid);
		BS_RPC(bs, toplayerid, 163, PR_LOW_PRIORITY, PR_RELIABLE_ORDERED); // HIDE
	}
    else
	{
	    new Float:p[4];
	    GetPlayerPos(playerid, p[0], p[1], p[2]);
	    GetPlayerFacingAngle(playerid, p[3]);

	    BS_WriteValue(bs,
	    PR_UINT16, playerid,
		PR_UINT8, GetPlayerTeamEx(playerid),
		PR_UINT32, GetPlayerSkin(playerid),
		PR_FLOAT, p[0],
        PR_FLOAT, p[1],
        PR_FLOAT, p[2],
        PR_FLOAT, p[3],
        PR_UINT32, GetPlayerColor(playerid),
		PR_UINT8, GetPlayerFightingStyle(playerid));

		BS_RPC(bs, toplayerid, 32, PR_LOW_PRIORITY, PR_RELIABLE_ORDERED); // SHOW?
    }
    BS_Delete(bs);
    return 1;
}

stock ClearPlayerShopInfo(playerid)
{
    SetPVarInt(playerid, "stype", -1);
	SetPVarInt(playerid, "pl", -1);
	SetPVarInt(playerid, "inx", -1);
	SetPVarInt(playerid, "pr", -1);
	SetPVarInt(playerid, "vp", -1);
	SetPVarInt(playerid, "ct", -1);
	SetPVarInt(playerid, "buyt", -1);
	SetPVarInt(playerid, "clbuy", -1);
}

stock TryToAddAmmoOrAntidote(playerid, dropper_id)
{
    AchievementAddProgress(playerid, ach_COLLECTED_MEATS);
    
	if(IsPlayerConnected(dropper_id))
	{
    	if(GetPlayerTeamEx(dropper_id) == TEAM_ZOMBIE && Player[dropper_id][pClass][TEAM_ZOMBIE+1] == FLESHERZOMBIE && !Player[playerid][IsPlayerInfected])
		{
			if(classCanBeInfected(playerid) && Player[playerid][pClass][TEAM_HUMAN] != SCAVENGER)
 			{
				InfectPlayer(9999.9, playerid, dropper_id);
    			foreach(Player, j) SendClientMessageFormat(j, -1, serverLang[Player[j][pLang]][74], Player[playerid][UserName], Player[dropper_id][UserName]);
       			GivePlayerXP(dropper_id, 2);
          		return 1;
       		}
       		else{
   				TryToAddAmmoOrAntidote(playerid, -1);
   				return 1;
       		}
		}
	}
	
	if(random(4) == 0 && getZombieClass(playerid) == ADVANCEDZOMBIEFAN)
	{
		new Float:h;
		GetPlayerHealthEx(playerid, h);
		if(h <= 67.0)
		{
			SetPlayerHealthAC(playerid, 33.0);
	    	return 1;
		}
	}

    if(random(3) == 0 && Player[playerid][IsPlayerInfected])
    {
        if(CurePlayer(playerid, playerid))
        {
        	GameTextForPlayer(playerid,"~g~ANTEDOTE TAKEN", 2000, 5);
        	return 1;
		}
		return 1;
    }
    else if(!Player[playerid][IsPlayerInfected])
	{
	    new slot, weap, ammo, randomammo = 0, scva = 0, gunname[32];
	    if(GetPlayerTeamEx(playerid) == TEAM_HUMAN && Player[playerid][pClass][TEAM_HUMAN] == SCAVENGER) scva = 5;
	    
	    for ( slot = 0; slot < 14; slot++ )
	    {
	        GetPlayerWeaponData(playerid, slot, weap, ammo);
	        if(IsValidWeapon(weap))
	        {
	            switch(weap)
	            {
	                case 23: randomammo = 25;
	                case 24,34: randomammo = 7 + random(7+scva);
	                case 25: randomammo = 10 + random(10+scva);
	                case 30,31,29: randomammo = 20 + random(40+scva);
	                case 32: randomammo = 50 + random(30+scva);
	                default: randomammo = 0;
				}
			}
			
	        GetWeaponName(weap, gunname, sizeof(gunname));
	        if(GetPVarInt(playerid, gunname) >= 1 && weap <= 34)
			{
				GivePlayerWeaponAC(playerid, weap, GetPVarInt(playerid, gunname) + randomammo, false);
				SetPlayerAmmoAC(playerid, weap, ammo + randomammo);
			}
		}
		switch(Player[playerid][pLang])
	    {
			case 0, 2: SendClientMessage(playerid, -1, "{FFFFFF}|: You picked up meat and you've found some ammo");
			case 1: SendClientMessage(playerid, -1, "{FFFFFF}|:  Вы подобрали мясо и нашли немного патронов");
		}
		return 1;
	}
	return 1;
}

stock getZombieClass(const playerid) return Player[playerid][pClass][TEAM_ZOMBIE+1];
stock getHumanClass(const playerid) return Player[playerid][pClass][TEAM_HUMAN];

stock SaveAchievements(playerid)
{
	//nac
    new query[2048], nac[512], saves[256];
    
	new pvalue = (GetBitSlot(Achievements[playerid][ach_BMask][1], 46) | GetBitSlot(Achievements[playerid][ach_BMask][1], 47));
    format(nac, sizeof(nac), "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
    0, 0, GetBitSlot(Achievements[playerid][ach_BMask][1], 44),
    0, GetBitSlot(Achievements[playerid][ach_BMask][1], 45), 0, 0,
    pvalue, 0, 0, 0, 0, 0);

	format(saves, sizeof(saves), "%d,%d", Achievements[playerid][ach_BMask][0], Achievements[playerid][ach_BMask][1]);

    mysql_format(Base, query, sizeof(query), "UPDATE `Achievements` SET `thropyManiac`='%d',`AbilityUses`='%d',`Runned`='%f',`Lucky`='%d',`HumansKilled`='%d',`ZombiesKilled`='%d',`MeatsCollected`='%d',`Deaths`='%d',`CuredHumans`='%d',`Purchases`='%d',`reportTimes`='%d',`h`='%d',`m`='%d',`s`='%d',`nac`='%e',`saves`='%e' WHERE `ID`='%d'",
    Achievements[playerid][ach_CONQUEROR],
    Achievements[playerid][ach_USED_ABILITY],
    Achievements[playerid][ach_RUNNED],
    Achievements[playerid][ach_SURVIVED],
    Achievements[playerid][ach_KILLED_HUMANS],
    Achievements[playerid][ach_KILLED_ZOMBIE],
	Achievements[playerid][ach_COLLECTED_MEATS],
	Achievements[playerid][ach_DIED_TIMES],
	Achievements[playerid][ach_CURED_HUMANS],
	Achievements[playerid][ach_SHOP_TIMES],
	Achievements[playerid][ach_REPORTED_TIMES],
 	Achievements[playerid][Hours],
 	Achievements[playerid][Minutes],
 	Achievements[playerid][Seconds],
 	nac,
 	saves,
 	Player[playerid][pAccountID]);
	mysql_tquery(Base, query, "", "", "");
}

fun LoadAchievements(playerid)
{
    if(cache_num_rows() > 0)
 	{
 	    new nac[256], ac[256], temp_var, pul, ctb, pt;
 	    cache_get_value_name_int(0,    "thropyManiac", Achievements[playerid][ach_CONQUEROR]);
        cache_get_value_name_int(0,    "AbilityUses", Achievements[playerid][ach_USED_ABILITY]);
        cache_get_value_name_float(0,  "Runned", Achievements[playerid][ach_RUNNED]);
        cache_get_value_name_int(0,    "Lucky", Achievements[playerid][ach_SURVIVED]);
        cache_get_value_name_int(0,    "HumansKilled", Achievements[playerid][ach_KILLED_HUMANS]);
        cache_get_value_name_int(0,    "ZombiesKilled", Achievements[playerid][ach_KILLED_ZOMBIE]);
        cache_get_value_name_int(0,    "MeatsCollected", Achievements[playerid][ach_COLLECTED_MEATS]);
        cache_get_value_name_int(0,    "Deaths", Achievements[playerid][ach_DIED_TIMES]);
        cache_get_value_name_int(0,    "CuredHumans", Achievements[playerid][ach_CURED_HUMANS]);
        cache_get_value_name_int(0,    "Purchases", Achievements[playerid][ach_SHOP_TIMES]);
        cache_get_value_name_int(0,    "reportTimes", Achievements[playerid][ach_REPORTED_TIMES]);
        cache_get_value_name_int(0,    "h", Achievements[playerid][Hours]);
        cache_get_value_name_int(0,    "m", Achievements[playerid][Minutes]);
        cache_get_value_name_int(0,    "s", Achievements[playerid][Seconds]);
        cache_get_value_name(0, 	   "saves", nac, 256);
        sscanf(nac, "p<,>dd", Achievements[playerid][ach_BMask][0], Achievements[playerid][ach_BMask][1]);
        
        cache_get_value_name(0, "nac", ac, 256);
        sscanf(nac, "p<,>iiiiiiiiiiiii", temp_var, // 1
	    temp_var, // 2
	    pul, // 3
	    temp_var, // 4
	    ctb, // 5
	    temp_var, // 6
	    temp_var, // 7
	    pt, // 8
	   	temp_var, // 9
	    temp_var, // 10
	    temp_var, // 11
		temp_var, // 12
        temp_var // 13
		);
        
        if(!ItsNewbie(playerid) && Achievements[playerid][ach_BMask][0] == 0 && Achievements[playerid][ach_BMask][1] == 0) IntegrateAchievements(playerid, pul, ctb, pt);
 	}
 	else
 	{
 	    new query[128];
 	    mysql_format(Base, query, sizeof(query), "INSERT INTO `Achievements` (`ID`) VALUE ('%d')", Player[playerid][pAccountID]);
  		mysql_tquery(Base, query, "", "", "");
 	}
 	
 	if(GetBitSlot(Achievements[playerid][ach_BMask][1], 46) <= 0) HoursForAch[playerid][0] = (Achievements[playerid][Hours]+2);
    if(GetBitSlot(Achievements[playerid][ach_BMask][1], 47) <= 0) HoursForAch[playerid][1] = (Achievements[playerid][Hours]+8);
}

stock GetAchievementProgress(playerid, index)
{
	switch(index)
	{
	    case 0: return Achievements[playerid][ach_CONQUEROR];
	    case 1, 2, 3: return Achievements[playerid][ach_USED_ABILITY];
	    case 4, 5, 6: return 0;
	    case 7, 8, 9: return Achievements[playerid][ach_SURVIVED];
	    case 10, 11, 12: return Achievements[playerid][ach_KILLED_HUMANS];
	    case 13, 14, 15: return Achievements[playerid][ach_KILLED_ZOMBIE];
	    case 16: return Player[playerid][pKills];
	    case 17, 18, 19: return Achievements[playerid][ach_COLLECTED_MEATS];
	    case 20, 21, 22: return Player[playerid][pKillstreakMax];
	    case 23, 24, 25: return Achievements[playerid][ach_CURED_HUMANS];
	    case 26, 27, 28: return Player[playerid][DuelsWin];
	    case 29: return (Player[playerid][pKillstreakMax] >= 99);
	    case 30, 31, 32: return Achievements[playerid][ach_DIED_TIMES];
	    case 33, 34, 35: return Achievements[playerid][ach_REPORTED_TIMES];
	    case 36, 37, 38: return Achievements[playerid][ach_SHOP_TIMES];
	    case 39: return GetBitSlot(Achievements[playerid][ach_BMask][1], 39);
	    case 40: return Player[playerid][RoundsWin];
	    case 41, 42, 43: return Achievements[playerid][Hours];
		case 44: return GetBitSlot(Achievements[playerid][ach_BMask][1], 44);
	    case 45: return GetBitSlot(Achievements[playerid][ach_BMask][1], 45);
	    case 46: return GetBitSlot(Achievements[playerid][ach_BMask][1], 46);
	    case 47: return GetBitSlot(Achievements[playerid][ach_BMask][1], 47);
	}
	return 0;
}

stock IntegrateAchievements(playerid, &pulsation, &cuttingthebring, &playedtime)
{
    if(Achievements[playerid][ach_USED_ABILITY] >= 5) UnlockAchievement(playerid, 	1, false);
    if(Achievements[playerid][ach_USED_ABILITY] >= 500) UnlockAchievement(playerid, 2, false);
    if(Achievements[playerid][ach_USED_ABILITY] >= 1000) UnlockAchievement(playerid, 3, false);

	if(Achievements[playerid][ach_RUNNED] >= 10.000) UnlockAchievement(playerid,  4, false);
	if(Achievements[playerid][ach_RUNNED] >= 50.000) UnlockAchievement(playerid,  5, false);
	if(Achievements[playerid][ach_RUNNED] >= 200.000) UnlockAchievement(playerid, 6, false);
	
	if(Achievements[playerid][ach_SURVIVED] >= 3) UnlockAchievement(playerid,  7, false);
	if(Achievements[playerid][ach_SURVIVED] >= 10) UnlockAchievement(playerid, 8, false);
	if(Achievements[playerid][ach_SURVIVED] >= 20) UnlockAchievement(playerid, 9, false);
	
	if(Achievements[playerid][ach_KILLED_HUMANS] >= 10) UnlockAchievement(playerid, 10, false);
	if(Achievements[playerid][ach_KILLED_HUMANS] >= 100) UnlockAchievement(playerid, 11, false);
	if(Achievements[playerid][ach_KILLED_HUMANS] >= 1000) UnlockAchievement(playerid, 12, false);
	
	if(Achievements[playerid][ach_KILLED_ZOMBIE] >= 10) UnlockAchievement(playerid,   13, false);
	if(Achievements[playerid][ach_KILLED_ZOMBIE] >= 100) UnlockAchievement(playerid,  14, false);
	if(Achievements[playerid][ach_KILLED_ZOMBIE] >= 1000) UnlockAchievement(playerid, 15, false);
	
	if(Player[playerid][pKills] >= 10000) UnlockAchievement(playerid, 16, false);

	if(Achievements[playerid][ach_COLLECTED_MEATS] >= 100) UnlockAchievement(playerid,  17, false);
	if(Achievements[playerid][ach_COLLECTED_MEATS] >= 1000) UnlockAchievement(playerid, 18, false);
	if(Achievements[playerid][ach_COLLECTED_MEATS] >= 5000) UnlockAchievement(playerid, 19, false);

	if(Player[playerid][pKillstreakMax] >= 5)   UnlockAchievement(playerid,  20, false);
	if(Player[playerid][pKillstreakMax] >= 50)   UnlockAchievement(playerid, 21, false);
	if(Player[playerid][pKillstreakMax] >= 100)   UnlockAchievement(playerid, 22, false);

	if(Achievements[playerid][ach_CURED_HUMANS] >= 1)   UnlockAchievement(playerid,  23, false);
	if(Achievements[playerid][ach_CURED_HUMANS] >= 50)   UnlockAchievement(playerid, 24, false);
	if(Achievements[playerid][ach_CURED_HUMANS] >= 100)   UnlockAchievement(playerid, 25, false);

	if(Player[playerid][DuelsWin] >= 10)    UnlockAchievement(playerid, 26, false);
	if(Player[playerid][DuelsWin] >= 100)    UnlockAchievement(playerid, 27, false);
	if(Player[playerid][DuelsWin] >= 250)    UnlockAchievement(playerid, 28, false);
	    
    if(Player[playerid][pKillstreakMax] >= 99)   UnlockAchievement(playerid, 29, false);
	    
 	if(Achievements[playerid][ach_DIED_TIMES] >= 10)     UnlockAchievement(playerid, 30, false);
 	if(Achievements[playerid][ach_DIED_TIMES] >= 100)    UnlockAchievement(playerid, 31, false);
 	if(Achievements[playerid][ach_DIED_TIMES] >= 1000)   UnlockAchievement(playerid, 32, false);
	    
	if(Achievements[playerid][ach_REPORTED_TIMES] >= 10)  UnlockAchievement(playerid, 33, false);
	if(Achievements[playerid][ach_REPORTED_TIMES] >= 50)  UnlockAchievement(playerid, 34, false);
	if(Achievements[playerid][ach_REPORTED_TIMES] >= 1000)  UnlockAchievement(playerid, 35, false);
	    
	if(Achievements[playerid][ach_SHOP_TIMES] >= 25) UnlockAchievement(playerid, 36, false);
	if(Achievements[playerid][ach_SHOP_TIMES] >= 50) UnlockAchievement(playerid, 37, false);
	if(Achievements[playerid][ach_SHOP_TIMES] >= 100) UnlockAchievement(playerid, 38, false);

	if(Player[playerid][RoundsWin] >= 300) UnlockAchievement(playerid, 40, false);

	if(Achievements[playerid][Hours] >= 24) UnlockAchievement(playerid,  41, false);
	if(Achievements[playerid][Hours] >= 300) UnlockAchievement(playerid, 42, false);
	if(Achievements[playerid][Hours] >= 650) UnlockAchievement(playerid, 43, false);
	    
 	if(pulsation >= 1) 		 				UnlockAchievement(playerid, 44, false);
	if(cuttingthebring >= 1) 				UnlockAchievement(playerid, 45, false);
	if(GetBitSlot(playedtime, 0) >= 1) 		UnlockAchievement(playerid, 46, false);
	if(GetBitSlot(playedtime, 1) >= 1) 		UnlockAchievement(playerid, 47, false);
}

fun LoadMapGang(playerid) {

    if(cache_num_rows())
	{
	    new id, name[64], gang, tnx;
	    cache_get_value_name_int(0, "ID", id);
	    cache_get_value_name_int(0, "controlled", gang);
	    cache_get_value_name_int(0, "tnx", tnx);
	    cache_get_value_name(0, "Name", name, 64);
	    
	    printf("MYID: %d | GANG: %d", Player[playerid][pClan], gang);
	    
	    if(gang == Player[playerid][pClan]) {
	        SendClientMessage(playerid, -1, "{FFF000}>> This map already owned by your gang");
			return 1;
		}
		
		if(GetWeekDay() != GANG_WARS_DAY) {
		    SendClientMessage(playerid, -1, "{FFF000}>> You can only capture maps on Fridays (17:00 - 20:00)");
			return 1;
		}
		
		new hour, minutes, seconds;
		gettime(hour, minutes, seconds);
		if(hour < 15 || hour >= 20 && minutes >= 0 && seconds >= 0) {
		    SendClientMessage(playerid, -1, "{FFF000}>> You can only capture maps on Fridays (15:00 - 20:00)");
			return 1;
		}
		
		if(gettime() < tnx) {
		    SendClientMessage(playerid, -1, "{FFF000}>> You cannot capture this map");
			return 1;
		}
		
		if(Clan[gang][g_WarType] > -1) {
		    SendClientMessage(playerid, -1, "{FFF000}>> Try later");
			return 1;
		}
		
	    new gid = Player[playerid][pClan], query[128];
	    
	    if(gang > 0)
		{
		    printf("gang > 0");
	        if(Clan[gang][g_AllianceWith][gid] >= 2) {
	    		SendClientMessage(playerid, -1, "{FFF000}>> This map belongs to your alliance!");
			    return 1;
			}
			
            if(gettime() < Clan[gang][g_TimesPlayed]) {
                SendClientMessage(playerid, -1, "{FFF000}>> Give this gang a break, they need to gather their strength after the previous match");
                SendClientMessage(playerid, -1, "{FFF000}>> One match per 15 minutes, or choose another opponent");
                return 1;
            }
            
            SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: %s wants a match with %s for %s #%d!", Clan[gid][Full], Clan[gang][Full], name, id+1);
		    SendMessageFormatToAll(-1, "{ffcc99}[GANG MATCH]: We are waiting for the leaders' decision! (/gang agree %d)", gid);
		    //Clan[gid][g_TimesPlayed] = gettime()+1800;
		    
		    Clan[gid][g_CupsAlliance][gang] = gang;
		    Clan[gang][g_CupsAlliance][gid] = gid;
		    Clan[gang][g_ForMapID] = id;
		 	return 1;
	    }
		else
		{
		    printf("gang < 0 | gettime(): %d | Clan[gid][g_TimesPlayed]: %d", gettime(), Clan[gid][g_TimesPlayed]);
	        if(Clan[gid][g_TimesPlayed] < gettime())
			{
			    printf("NO GANG");
	         	SendMessageFormatToAll(-1, "{ffcc99}>> %s stated that %s is now their map!", Clan[gid][Full], name);
	          	SendMessageFormatToAll(-1, "{ffcc99}>> If you do not agree with this - declare war on them! (/gang war %d)", gid);
	          	SendClientMessageToAll(-1, "{ffcc99}>> Castles that HAVE NOT been PROTECTED will be destroyed! (/maps)");
	          	if(mapid == id) Map[m_GangControll] = gid;
	            mysql_format(Base, query, sizeof(query), "UPDATE `maps` SET `controlled`='%d' WHERE `ID` = '%d'", gid, id);
	   			mysql_tquery(Base, query, "", "");
	   			Clan[gid][g_OwnedMaps]++;
	   			Clan[gang][g_OwnedMaps]--;
	   			//Clan[gid][g_TimesPlayed] = gettime()+1800;
			}
			else SendClientMessage(playerid, -1, "{FFF000}>> You ask for a maps too often, take a break for 15 minutes!");

			return 1;
	    }
	}
	return 1;
}

fun LoadTimeout(playerid)
{
    if(cache_num_rows())
	{
	    new time, val;
	    cache_get_value_name_int(0, "mute", Player[playerid][Muted]);
    	cache_get_value_name_int(0, "jail", Player[playerid][Jailed]);
    	cache_get_value_name_int(0, "zom",  WasZombieTimes[playerid]);
    	cache_get_value_name_int(0, "hum",  WasHumanTimes[playerid]);
		cache_get_value_name_int(0, "h",  	time);
    	
    	val = max(1, (time-gettime()));
   		Player[playerid][pRestTime] = min(1.5, 1.0+floatmul(floatdiv(2.0, 12.0), val/3600));
    	
    	if(Player[playerid][Jailed] > 0) {
    		SetPlayerSkinAC(playerid, 62, 1);
			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CUFFED);
			SetPlayerPosAC(playerid,264.1425,77.4712,1001.0391);
			SetPlayerFacingAngle(playerid, 263.0160);
			SetPlayerInterior(playerid, 6);
			SetPlayerColor(playerid, 0x000000FF);
			SetPlayerTeamEx(playerid, TEAM_ZOMBIE);
			ResetWeapons(playerid);
			SetPlayerArmourAC(playerid, 0.0);
			SetPlayerHealthAC(playerid, 100.0);
		}
	}
	else
	{
	    new query[340];
	    mysql_format(Base, query, sizeof(query), "INSERT INTO `timeout` (`ID`) VALUES ('%d')", Player[playerid][pAccountID]);
	    mysql_tquery(Base, query, "", "", "");
	}
	return 1;
}

stock SaveTimeout(playerid)
{
    new query[340];
   	mysql_format(Base, query, sizeof(query), "UPDATE `timeout` SET `h`='%d',`mute`='%d',`jail`='%d',`zom`='%d',`hum`='%d' WHERE `ID` = '%d'", gettime(), Player[playerid][Muted], Player[playerid][Jailed], WasZombieTimes[playerid], WasHumanTimes[playerid], Player[playerid][pAccountID]);
	mysql_tquery(Base, query, "", "", "");
}

main() {
    
}

fun GangWarGo(gang_id, opponent_id, for_map) {

	if(Clan[gang_id][g_WarForCup] >= 1) {
		foreach(Player, i)
		{
			if(Player[i][pClan] == gang_id || Player[i][pClan] == opponent_id) SendClientMessage(i, -1, "{C659B6}>> Time to join the match is out");
		}

		for( new j = 0; j < sizeof(Clan); j++ ) {
			if(Clan[gang_id][g_AllianceWith][j] >= 2) Clan[j][g_TimeToJoin] = 0;
			if(Clan[opponent_id][g_AllianceWith][j] >= 2) Clan[j][g_TimeToJoin] = 0;
		}

		Clan[gang_id][g_TimeToJoin] = 0;
		Clan[opponent_id][g_TimeToJoin] = 0;
		Clan[gang_id][g_ObjectHealth] = 1000.0;
		Clan[opponent_id][g_ObjectHealth] = 1000.0;
		Delete3DTextLabel(Clan[gang_id][g_ObjectStatus]);
		Delete3DTextLabel(Clan[opponent_id][g_ObjectStatus]);
		if(IsValidTimer(Clan[gang_id][g_GWTimer])) KillTimerEx(Clan[gang_id][g_GWTimer]);
		Clan[gang_id][g_GWTimer] = SetTimerEx("GangWarEnd", 600000, 0, "ddd", gang_id, opponent_id, for_map);

		new Float:up = 6.0, Float:pos[3];
		GetObjectPos(castle_object[0], pos[0], pos[1], pos[2]);
		SendMessageFormatToAll(-1, "{ff0000}[MAP MATCH]: A match between %s and %s has just started!", Clan[gang_id][Full], Clan[opponent_id][Full]);
        
		new str[128];
		format(str, sizeof(str), "{FFF000}%s's {FFFFFF} CASTLE\n\nHealth: %.1f\n\nDestroy it to capture the map", Clan[gang_id][Full], Clan[gang_id][g_ObjectHealth]);
		Clan[gang_id][g_ObjectStatus] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2]+up, 500.0, Clan[gang_id][g_Emblem], 0);
		
		GetObjectPos(castle_object[1], pos[0], pos[1], pos[2]);
		format(str, sizeof(str), "{FFF000}%s's{FFFFFF} CASTLE\n\nHealth: %.1f\n\nDestroy it to capture the map", Clan[opponent_id][Full], Clan[opponent_id][g_ObjectHealth]);
		Clan[opponent_id][g_ObjectStatus] = Create3DTextLabel(str, 0xFF0000FF, pos[0], pos[1], pos[2]+up, 500.0, Clan[opponent_id][g_Emblem], 0);
	}
	printf("VW: %d", Clan[gang_id][g_Emblem]);
	return 1;
}

fun GangWarEnd(gang_id, opponent_id, for_map) return EndMatch(gang_id, opponent_id, for_map);

stock SetGangMatchClass(playerid, classid, td_type) {
	
	Player[playerid][pAdditionalDamage] = 0.0;
	
	if(!Player[playerid][pInGangMatch]) {
	    foreach(Player, i) {
	        if(Player[i][pClan] == Player[playerid][pClan] || Clan[Player[i][pClan]][g_AllianceWith][Player[playerid][pClan]] >= 2) SendClientMessageFormat(i, -1, "{C659B6}[MATCH]: %s has just joined the match", Player[playerid][UserName]);
	    }
	}
	
    ResetWeapons(playerid);
    
    SetPlayerVirtualWorld(playerid, Clan[Player[playerid][pClan]][g_Emblem]);
    printf("VW: %d", Clan[Player[playerid][pClan]][g_Emblem]);
    
	if(td_type == 0) {
	    SendClientMessage(playerid, -1, "{C659B6}[MAP MATCH]: You need to protect your {FFFFFF}'CASTLE'{C659B6} for 10 minutes");
	    
		new r = random(sizeof(defenders_poses));
		SetPlayerPosAC(playerid, defenders_poses[r][0], defenders_poses[r][1], defenders_poses[r][2]);
		SetPlayerFacingAngle(playerid, defenders_poses[r][3]);
		
		SetCameraBehindPlayer(playerid);
		SetPlayerTeamEx(playerid, NO_TEAM);
		SetPlayerColor(playerid, 0xfffb00FF);
    } else {
        SendClientMessage(playerid, -1, "{C659B6}[MAP MATCH]: You need to destroy enemy's {FFFFFF}'CASTLE'{C659B6} for 10 minutes");

		new r = random(sizeof(atatckers_poses));
		SetPlayerPosAC(playerid, atatckers_poses[r][0], atatckers_poses[r][1], atatckers_poses[r][2]);
		SetPlayerFacingAngle(playerid, atatckers_poses[r][3]);
		SetCameraBehindPlayer(playerid);
		SetPlayerTeamEx(playerid, NO_TEAM);
		SetPlayerColor(playerid, 0x7300ffFF);
    }
    
    new each_three = (Player[playerid][pRank]/3),
    	each_five =  (Player[playerid][pRank]/5);

	switch(classid)
	{
	    case 0: // Tank
	    {
			SetPlayerArmourAC(playerid, 100 + each_three * 5, true);
			SetPlayerHealthAC(playerid, 100 + each_three * 6, true, 100 + each_three * 6);
			
			GivePlayerWeaponAC(playerid, 24, 1000);
			GivePlayerWeaponAC(playerid, 25, 1000);
			SetPlayerSkinAC(playerid, 5, 1);
	    }
	    case 1: // MELEE
	    {
	        SetPlayerArmourAC(playerid, 100 + each_five * 2, true);
			SetPlayerHealthAC(playerid, 100 + each_five * 3, true, 100 + each_five * 3);
			
	        GivePlayerWeaponAC(playerid, 24, 1000);
			GivePlayerWeaponAC(playerid, 31, 1000);
			SetPlayerSkinAC(playerid, 0, 1);
	    }
	    case 2: // RANGED
	    {
	        SetPlayerArmourAC(playerid, 100 + each_five, true);
	        GivePlayerWeaponAC(playerid, 34, 1000);
			SetPlayerSkinAC(playerid, 160, 1);
	    }
	}
	Player[playerid][pInGangMatch] = true;
	return 1;
}

stock EndMatch(gang_id, war_id, map) {
    SendMessageFormatToAll(-1, "{ffcc99}>> %s beat %s and took their castle! (CASTLE PROTECTED - /maps)", Clan[gang_id][Full], Clan[war_id][Full]);

    Clan[gang_id][g_OwnedMaps]++;
	Clan[war_id][g_OwnedMaps]--;

    new gid = gang_id;
    Clan[gid][g_TimesPlayed] = gettime()+900;
    Clan[gid][g_TimesPlayed] = 0;
	Clan[gid][g_WeeksToKick] = 0;
	Clan[gid][g_Emblem] = 0;
	Clan[gid][g_WarForCup] = 0;
	Clan[gid][g_TimeToJoin] = 0;
	Clan[gid][g_WarType] = -1;
    Clan[gid][g_CupsAlliance][war_id] = 0;
    
    if(mapid == Clan[gid][g_ForMapID]) {
        Map[m_GangControll] = gang_id;
    } else {
        new query[200];
        mysql_format(Base, query, sizeof(query), "UPDATE `maps` SET `controlled`='%d',`tnx`='%d' WHERE `ID` = '%d'", gang_id, gettime() + 604800, map);
  		mysql_tquery(Base, query, "", "");
    }
    
    for( new i = 0; i < 30; i++ ) {
        Clan[gang_id][g_CupsAlliance][i] = 0;
        Clan[war_id][g_CupsAlliance][i] = 0;
    }
    
    gid = war_id;
    Clan[gid][g_TimesPlayed] = gettime()+900;
    Clan[gid][g_TimesPlayed] = 0;
	Clan[gid][g_WeeksToKick] = 0;
	Clan[gid][g_Emblem] = 0;
	Clan[gid][g_WarForCup] = 0;
	Clan[gid][g_TimeToJoin] = 0;
	Clan[gid][g_WarType] = -1;
    Clan[gid][g_CupsAlliance][gang_id] = 0;
    
    Clan[gang_id][g_LastKill] = (gettime()+604800);
    
    foreach(Player, i) {
        if((Player[i][pClan] == gang_id || Player[i][pClan] == war_id || Clan[Player[i][pClan]][g_AllianceWith][gang_id] >= 2 || Clan[Player[i][pClan]][g_AllianceWith][war_id] >= 2) && Player[i][pInGangMatch]) {
            if(Player[i][pClan] == gang_id || Clan[Player[i][pClan]][g_AllianceWith][gang_id] >= 2) {
				Player[i][pPlayerKills] += 50;
                setHumanColor(i);
                SendClientMessage(i, -1, "{FFF000}>> +50 CP for a win");
			}
			Player[i][pInGangMatch] = false;
            SetPlayerTeamEx(i, TEAM_ZOMBIE);
            SpawnPlayer(i);
            
        }
    }
    return 1;
}
 
stock split(const strsrc[], strdest[][], delimiter){
	new i, li;
	new aNum;
	new len;
	while(i <= strlen(strsrc)){
		if(strsrc[i]==delimiter || i==strlen(strsrc)){
			len = strmid(strdest[aNum], strsrc, li, i, 128);
			strdest[aNum][len] = 0;
			li = i+1;
			aNum++;
		}
		i++;
	}
	return 1;
}

#define BODY_TYPE_CHEST 0
#define BODY_TYPE_HELMET 1
#define BODY_TYPE_HANDS 2
#define BODY_TYPE_LEGS 3

////////////////////////////////////////////////////////////////////////////////
new CharacterArmour[MAX_PLAYERS][4];
new CharacterWeapon[MAX_PLAYERS][4];

CMD:mychar(playerid) {
	new info[128];
	format(info, sizeof(info), "+%d Helmet\n+%d Body\n+%d Arms\n+%d Legs",
		CharacterArmour[playerid][BODY_TYPE_HELMET],
		CharacterArmour[playerid][BODY_TYPE_CHEST],
		CharacterArmour[playerid][BODY_TYPE_HANDS],
		CharacterArmour[playerid][BODY_TYPE_LEGS]);
		
	ShowPlayerDialog(playerid, DIALOG_UPGRADE_CHAR, DIALOG_STYLE_LIST, "Character Armour", info, "Select", "Close");
	return 1;
}

CMD:myweapons(playerid) {
	new info[128];
	format(info, sizeof(info), "+%d Deagle\n+%d Shotgun\n+%d M4A1\n+%d Sniper Rifle",
		CharacterWeapon[playerid][0],
		CharacterWeapon[playerid][1],
		CharacterWeapon[playerid][2],
		CharacterWeapon[playerid][3]);
		
	ShowPlayerDialog(playerid, DIALOG_UPGRADE_WEAPONS, DIALOG_STYLE_LIST, "Character Weapons", info, "Select", "Close");
    return 1;
}

static const upgrade_chances[] = {
	2, 	3, 	4, 	5,
	6, 	7, 	8, 	9,
	10, 11, 12, 13
};

stock TryToUgprade() {
	return (random(upgrade_chances[level]) == 0);
	// 1 - (100 / 2) = 50 '/.
	// 2 - (100 / 3) = 33 '/.
	// 3 - (100 / 4) = 25 '/.
	// 4 - (100 / 5) = 20 '/.
	// 5 - (100 / 6) = 16 '/.
	// 6 - (100 / 7) = 14 '/.
	// 7 - (100 / 8) = 12 '/.
	// 8 - (100 / 9) = 11 '/.
	// 9 - (100 / 10) = 10 '/.
	// 10 - (100 / 11) = 9 '/.
	// 11 - (100 / 12) = 8 '/.
	// 12 - (100 / 13) = 7 '/.
	// Increases the level of equipment by 1 if the upgrade was successful, otherwise set to 0
}

stock Float:Weapon_GiveHit(playerid, targetid, weaponid, Float:damage) {
	if(weaponid == 0) return 0.0;
	new
		dodge = Armour_Dodge(targetid, BODY_TYPE_HELMET) + Armour_Dodge(targetid, BODY_TYPE_LEGS) + (Player[targetid][pRank]/4),
	    accuracy = (Weapon_GiveAccuracy(playerid, weaponid)/2) + Armour_Accuracy(playerid) + (Player[playerid][pRank]/4);
	if(random(dodge) <= accuracy) return (damage - (damage*(0.12 - float(CharacterWeapon[weaponid] / 100))))-float(Armour_Absorption(targetid));
	return 0.0;
}

stock Float:Weapon_GiveAccuracy(playerid, weaponid) return 1.0+float(CharacterWeapon[playerid][weaponid]);    // Give additional accuracy

static const crit_chances[4][] =
{
    // Deagle,
	{	0, 1, 1, 2,
        2, 3, 3, 4,
        4, 5, 5, 6
	},
	// Shotgun
	{
        0, 0, 1, 1,
        1, 2, 2, 2,
        3, 3, 3, 4
	},
	// M4A1
	{
        0, 0, 0, 1,
        1, 1, 1, 2,
        2, 2, 2, 3
	},
	// Sniper Rifle
	{
		0, 1,  2,  3,
		4, 5,  6,  7,
		8, 9, 10, 11
	}
};

stock Float:Weapon_GiveCritChance(playerid, weaponid) 
{

}

stock Armour_Absorption(playerid) return CharacterArmour[playerid][BODY_TYPE_CHEST]; 						// Body (Absorption)
stock Armour_Dodge(playerid, armour_id) {                                      								// Helmet, Legs (Dodge)
    switch(CharacterArmour[playerid][armour_id])
    {
        case 1: return 1;
        case 2, 3: return 2;
        case 4, 5: return 3;
        case 6: return 4;
        case 7: return 5;
        case 8: return 6;
        case 9: return 7;
        case 10: return 8;
        case 11: return 9;
        case 12: return 10;
    	default: return 0;
	}
	return 0;
}

stock Armour_Accuracy(playerid) {                                      										// Hands (Accuracy)
    switch(CharacterArmour[playerid][BODY_TYPE_HANDS])
    {
        case 1: return 2;
        case 2, 3: return 4;
        case 4, 5: return 6;
        case 6: return 8;
        case 7: return 10;
        case 8: return 12;
        case 9: return 14;
        case 10: return 16;
        case 11: return 18;
        case 12: return 20;
    	default: return 0;
	}
	return 0;
}

stock setHumanColor(playerid)
{
    if(Player[playerid][IsPlayerInfected]) SetPlayerColor(playerid,COLOR_INFECTED);
    else if(Player[playerid][pClan] <= 0) SetPlayerColor(playerid,COLOR_HUMAN);
    else {
	    switch(Player[playerid][pPlayerKills])
	    {
			case 0: SetPlayerColor(playerid, 0x00ccccFF);
			case 1: SetPlayerColor(playerid, 0x00b3b3FF);
			case 2: SetPlayerColor(playerid, 0x009999FF);
			case 3: SetPlayerColor(playerid, 0x008080FF);
			case 4: SetPlayerColor(playerid, 0x006666FF);
			case 5: SetPlayerColor(playerid, 0x004d4dFF);
			case 6: SetPlayerColor(playerid, 0x003333FF);
			case 7: SetPlayerColor(playerid, 0x330000FF);
			case 8: SetPlayerColor(playerid, 0x4d0000FF);
			case 9: SetPlayerColor(playerid, 0x4d0000FF);
			case 10: SetPlayerColor(playerid, 0x660000FF);
			case 11: SetPlayerColor(playerid, 0x800000FF);
			case 12: SetPlayerColor(playerid, 0x990000FF);
			case 13: SetPlayerColor(playerid, 0xb30000FF);
			case 14: SetPlayerColor(playerid, 0xcc0000FF);
			case 15: SetPlayerColor(playerid, 0xff1a1aFF);
			case 16: SetPlayerColor(playerid, 0x990099FF);
			case 17: SetPlayerColor(playerid, 0xb300b3FF);
			case 18: SetPlayerColor(playerid, 0xcc00ccFF);
			case 19: SetPlayerColor(playerid, 0xe600e6FF);
			case 20: SetPlayerColor(playerid, 0xC659B6FF);
			case 21: SetPlayerColor(playerid, 0xcb67bcFF);
			case 22: SetPlayerColor(playerid, 0xd17ac4FF);
			case 23: SetPlayerColor(playerid, 0xd88dcdFF);
			case 24: SetPlayerColor(playerid, 0xdea0d5FF);
			case 25: SetPlayerColor(playerid, 0xe4b4ddFF);
			case 26: SetPlayerColor(playerid, 0xebc7e5FF);
			case 27: SetPlayerColor(playerid, 0xf1daedFF);
			case 28: SetPlayerColor(playerid, 0xf8edf6FF);
			case 29: SetPlayerColor(playerid, 0xffe6e6FF);
			case 30: SetPlayerColor(playerid, 0xffccccFF);
			case 31: SetPlayerColor(playerid, 0xffb3b3FF);
			case 32: SetPlayerColor(playerid, 0xff9999FF);
			case 33: SetPlayerColor(playerid, 0xff8080FF);
		  	case 34: SetPlayerColor(playerid, 0xff6666FF);
            case 35: SetPlayerColor(playerid, 0xff4d4dFF);
			case 36: SetPlayerColor(playerid, 0xff3333FF);
			case 37: SetPlayerColor(playerid, 0xff1a1aFF);
			case 38: SetPlayerColor(playerid, 0xff0000FF);
			case 39: SetPlayerColor(playerid, 0xe60000FF);
			case 40: SetPlayerColor(playerid, 0xcc0000FF);
			case 41: SetPlayerColor(playerid, 0xb30000FF);
			case 42: SetPlayerColor(playerid, 0x990000FF);
			case 43: SetPlayerColor(playerid, 0x800000FF);
			case 44: SetPlayerColor(playerid, 0x660000FF);
			case 45: SetPlayerColor(playerid, 0x4d0000FF);
			case 46: SetPlayerColor(playerid, 0x330000FF);
			case 47: SetPlayerColor(playerid, 0x1a0000FF);
			case 48: SetPlayerColor(playerid, 0x000000FF);
			default: SetPlayerColor(playerid, 0x000000FF);
	    }
	}
}
